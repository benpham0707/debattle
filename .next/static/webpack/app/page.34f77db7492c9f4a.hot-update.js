"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/roleManager.ts":
/*!********************************!*\
  !*** ./src/lib/roleManager.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getStablePlayerRole: function() { return /* binding */ getStablePlayerRole; },\n/* harmony export */   getStableSessionId: function() { return /* binding */ getStableSessionId; },\n/* harmony export */   roleManager: function() { return /* binding */ roleManager; },\n/* harmony export */   usePlayerRole: function() { return /* binding */ usePlayerRole; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n// src/lib/roleManager.ts\n// Bulletproof role management system that maintains player roles throughout the entire game session\n\n// Helper function to generate a proper UUID v4\nfunction generateUUID() {\n    // Use crypto.randomUUID if available (modern browsers)\n    if (typeof crypto !== \"undefined\" && crypto.randomUUID) {\n        return crypto.randomUUID();\n    }\n    // Fallback to manual generation (proper UUID v4 format)\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n        const r = Math.random() * 16 | 0;\n        const v = c === \"x\" ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n    });\n}\n// Single source of truth for role management\nclass RoleManager {\n    static getInstance() {\n        if (!RoleManager.instance) {\n            RoleManager.instance = new RoleManager();\n        }\n        return RoleManager.instance;\n    }\n    // Generate a consistent session ID for this browser (proper UUID format)\n    generateSessionId() {\n        // First check if we already have a global session ID\n        let globalSessionId = localStorage.getItem(\"debattle_global_session\");\n        if (!globalSessionId || !this.isValidUUID(globalSessionId)) {\n            globalSessionId = generateUUID() // Use proper UUID\n            ;\n            localStorage.setItem(\"debattle_global_session\", globalSessionId);\n            console.log(\"\\uD83C\\uDD95 ROLE MANAGER - Generated new global session UUID:\", globalSessionId.slice(-8));\n        }\n        return globalSessionId;\n    }\n    // Validate UUID format\n    isValidUUID(uuid) {\n        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n        return uuidRegex.test(uuid);\n    }\n    // Initialize or retrieve role for a specific room\n    async initializeRole(roomId, room) {\n        const sessionKey = \"debattle_role_\".concat(roomId);\n        // First, check if we already have a locked role for this room\n        const existingSession = localStorage.getItem(sessionKey);\n        if (existingSession) {\n            try {\n                const parsed = JSON.parse(existingSession);\n                // Validate that the session is still valid and has proper UUID\n                if (this.isValidUUID(parsed.sessionId) && this.validateSession(parsed, room)) {\n                    console.log(\"✅ ROLE MANAGER - Restored existing valid session:\", {\n                        role: parsed.playerRole,\n                        sessionId: parsed.sessionId.slice(-8),\n                        isLocked: parsed.isLocked\n                    });\n                    this.currentSession = parsed;\n                    return parsed;\n                } else {\n                    console.log(\"❌ ROLE MANAGER - Existing session invalid, will create new one\");\n                    localStorage.removeItem(sessionKey);\n                }\n            } catch (error) {\n                console.error(\"❌ ROLE MANAGER - Error parsing existing session:\", error);\n                localStorage.removeItem(sessionKey);\n            }\n        }\n        // Create new session if none exists or existing is invalid\n        const sessionId = this.generateSessionId();\n        const playerRole = await this.determineRoleFromRoom(room, sessionId);\n        const newSession = {\n            sessionId,\n            playerRole,\n            roomId,\n            assignedAt: Date.now(),\n            isLocked: room.status === \"debating\" // Lock role once game starts\n        };\n        // Save the session\n        localStorage.setItem(sessionKey, JSON.stringify(newSession));\n        this.currentSession = newSession;\n        console.log(\"\\uD83C\\uDFAD ROLE MANAGER - Created new session:\", {\n            role: newSession.playerRole,\n            sessionId: newSession.sessionId.slice(-8),\n            isLocked: newSession.isLocked,\n            roomStatus: room.status\n        });\n        return newSession;\n    }\n    // Validate that a session is still valid for the current room state\n    validateSession(session, room) {\n        // Check if room still exists and session ID matches expected player\n        if (session.playerRole === \"player_a\") {\n            return room.player_a_id === session.sessionId;\n        } else if (session.playerRole === \"player_b\") {\n            return room.player_b_id === session.sessionId;\n        } else {\n            return session.playerRole === \"spectator\" // Spectators are always valid\n            ;\n        }\n    }\n    // Determine role based on room state and session ID\n    async determineRoleFromRoom(room, sessionId) {\n        var _room_player_a_id, _room_player_b_id;\n        console.log(\"\\uD83D\\uDD0D ROLE MANAGER - Determining role from room:\", {\n            sessionId: sessionId.slice(-8),\n            roomPlayerA: (_room_player_a_id = room.player_a_id) === null || _room_player_a_id === void 0 ? void 0 : _room_player_a_id.slice(-8),\n            roomPlayerB: (_room_player_b_id = room.player_b_id) === null || _room_player_b_id === void 0 ? void 0 : _room_player_b_id.slice(-8)\n        });\n        // Check direct ID matches first\n        if (room.player_a_id === sessionId) {\n            console.log(\"✅ ROLE MANAGER - Matched as Player A by ID\");\n            return \"player_a\";\n        }\n        if (room.player_b_id === sessionId) {\n            console.log(\"✅ ROLE MANAGER - Matched as Player B by ID\");\n            return \"player_b\";\n        }\n        // If no match found, user is a spectator\n        console.log(\"\\uD83D\\uDC40 ROLE MANAGER - No match found, assigned as spectator\");\n        return \"spectator\";\n    }\n    // Get current session (used by components)\n    getCurrentSession() {\n        return this.currentSession;\n    }\n    // Lock the role once game starts (prevents changes during game)\n    lockRole(roomId) {\n        if (this.currentSession && this.currentSession.roomId === roomId) {\n            this.currentSession.isLocked = true;\n            const sessionKey = \"debattle_role_\".concat(roomId);\n            localStorage.setItem(sessionKey, JSON.stringify(this.currentSession));\n            console.log(\"\\uD83D\\uDD12 ROLE MANAGER - Role locked for game session\");\n        }\n    }\n    // Clear role when leaving room\n    clearRole(roomId) {\n        const sessionKey = \"debattle_role_\".concat(roomId);\n        localStorage.removeItem(sessionKey);\n        if (this.currentSession && this.currentSession.roomId === roomId) {\n            this.currentSession = null;\n        }\n        console.log(\"\\uD83E\\uDDF9 ROLE MANAGER - Cleared role for room:\", roomId.slice(-8));\n    }\n    // Get session ID for room service compatibility (ensures proper UUID format)\n    getSessionId() {\n        if (this.currentSession && this.isValidUUID(this.currentSession.sessionId)) {\n            return this.currentSession.sessionId;\n        }\n        // Generate new UUID if current session is invalid\n        const newId = this.generateSessionId();\n        console.log(\"\\uD83C\\uDD95 ROLE MANAGER - Generated new session ID:\", newId.slice(-8));\n        return newId;\n    }\n    // Debug helper\n    debugSession(roomId) {\n        const sessionKey = \"debattle_role_\".concat(roomId);\n        const stored = localStorage.getItem(sessionKey);\n        console.log(\"\\uD83D\\uDD0D ROLE MANAGER DEBUG:\", {\n            currentSession: this.currentSession,\n            storedSession: stored ? JSON.parse(stored) : null,\n            allDebattleKeys: Object.keys(localStorage).filter((k)=>k.includes(\"debattle\")),\n            globalSession: localStorage.getItem(\"debattle_global_session\")\n        });\n    }\n    // Clean up invalid session data\n    cleanupInvalidSessions() {\n        const keys = Object.keys(localStorage).filter((k)=>k.includes(\"debattle\"));\n        let cleaned = 0;\n        keys.forEach((key)=>{\n            try {\n                const value = localStorage.getItem(key);\n                if (value) {\n                    // For role sessions, check if they have valid UUIDs\n                    if (key.includes(\"debattle_role_\")) {\n                        const session = JSON.parse(value);\n                        if (!this.isValidUUID(session.sessionId)) {\n                            localStorage.removeItem(key);\n                            cleaned++;\n                            console.log(\"\\uD83E\\uDDF9 ROLE MANAGER - Cleaned invalid session:\", key);\n                        }\n                    } else if (key === \"debattle_global_session\") {\n                        if (!this.isValidUUID(value)) {\n                            localStorage.removeItem(key);\n                            cleaned++;\n                            console.log(\"\\uD83E\\uDDF9 ROLE MANAGER - Cleaned invalid global session\");\n                        }\n                    }\n                }\n            } catch (error) {\n                localStorage.removeItem(key);\n                cleaned++;\n                console.log(\"\\uD83E\\uDDF9 ROLE MANAGER - Cleaned corrupted session:\", key);\n            }\n        });\n        if (cleaned > 0) {\n            console.log(\"\\uD83E\\uDDF9 ROLE MANAGER - Cleaned \".concat(cleaned, \" invalid sessions\"));\n        }\n    }\n    constructor(){\n        this.currentSession = null;\n    }\n}\nconst roleManager = RoleManager.getInstance();\n// Initialize cleanup on module load\nif (true) {\n    roleManager.cleanupInvalidSessions();\n}\n// Helper hook for React components\nfunction usePlayerRole(roomId, room) {\n    const [session, setSession] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(null);\n    const [isLoading, setIsLoading] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(true);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(()=>{\n        if (!room) return;\n        const initRole = async ()=>{\n            try {\n                const playerSession = await roleManager.initializeRole(roomId, room);\n                setSession(playerSession);\n                // Lock role if game is in progress\n                if (room.status === \"debating\" && !playerSession.isLocked) {\n                    roleManager.lockRole(roomId);\n                }\n            } catch (error) {\n                console.error(\"Error initializing role:\", error);\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        initRole();\n    }, [\n        roomId,\n        room === null || room === void 0 ? void 0 : room.id\n    ]) // Only re-run if roomId or room.id changes\n    ;\n    return {\n        session,\n        isLoading\n    };\n}\n// Compatibility functions for existing code\nfunction getStablePlayerRole(roomId) {\n    const session = roleManager.getCurrentSession();\n    if (session && session.roomId === roomId) {\n        return session.playerRole;\n    }\n    return \"spectator\";\n}\nfunction getStableSessionId() {\n    return roleManager.getSessionId();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvcm9sZU1hbmFnZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEseUJBQXlCO0FBQ3pCLG9HQUFvRztBQUUzRTtBQVV6QiwrQ0FBK0M7QUFDL0MsU0FBU0M7SUFDUCx1REFBdUQ7SUFDdkQsSUFBSSxPQUFPQyxXQUFXLGVBQWVBLE9BQU9DLFVBQVUsRUFBRTtRQUN0RCxPQUFPRCxPQUFPQyxVQUFVO0lBQzFCO0lBRUEsd0RBQXdEO0lBQ3hELE9BQU8sdUNBQXVDQyxPQUFPLENBQUMsU0FBUyxTQUFTQyxDQUFDO1FBQ3ZFLE1BQU1DLElBQUksS0FBTUUsTUFBTSxLQUFLLEtBQU07UUFDakMsTUFBTUMsSUFBSUosTUFBTSxNQUFNQyxJQUFJLElBQUssTUFBTztRQUN0QyxPQUFPRyxFQUFFQyxRQUFRLENBQUM7SUFDcEI7QUFDRjtBQUVBLDZDQUE2QztBQUM3QyxNQUFNQztJQUlKLE9BQU9DLGNBQTJCO1FBQ2hDLElBQUksQ0FBQ0QsWUFBWUUsUUFBUSxFQUFFO1lBQ3pCRixZQUFZRSxRQUFRLEdBQUcsSUFBSUY7UUFDN0I7UUFDQSxPQUFPQSxZQUFZRSxRQUFRO0lBQzdCO0lBRUEseUVBQXlFO0lBQ2pFQyxvQkFBNEI7UUFDbEMscURBQXFEO1FBQ3JELElBQUlDLGtCQUFrQkMsYUFBYUMsT0FBTyxDQUFDO1FBQzNDLElBQUksQ0FBQ0YsbUJBQW1CLENBQUMsSUFBSSxDQUFDRyxXQUFXLENBQUNILGtCQUFrQjtZQUMxREEsa0JBQWtCZCxlQUFlLGtCQUFrQjs7WUFDbkRlLGFBQWFHLE9BQU8sQ0FBQywyQkFBMkJKO1lBQ2hESyxRQUFRQyxHQUFHLENBQUMsa0VBQXdETixnQkFBZ0JPLEtBQUssQ0FBQyxDQUFDO1FBQzdGO1FBQ0EsT0FBT1A7SUFDVDtJQUVBLHVCQUF1QjtJQUNmRyxZQUFZSyxJQUFZLEVBQVc7UUFDekMsTUFBTUMsWUFBWTtRQUNsQixPQUFPQSxVQUFVQyxJQUFJLENBQUNGO0lBQ3hCO0lB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Q0FBMkM7O0lBRWxFLE9BQU87UUFBRWxDO1FBQVM2QjtJQUFVO0FBQzlCO0FBRUEsNENBQTRDO0FBQ3JDLFNBQVNNLG9CQUFvQjFELE1BQWM7SUFDaEQsTUFBTXVCLFVBQVV5QixZQUFZcEIsaUJBQWlCO0lBQzdDLElBQUlMLFdBQVdBLFFBQVF2QixNQUFNLEtBQUtBLFFBQVE7UUFDeEMsT0FBT3VCLFFBQVFiLFVBQVU7SUFDM0I7SUFDQSxPQUFPO0FBQ1Q7QUFFTyxTQUFTaUQ7SUFDZCxPQUFPWCxZQUFZakIsWUFBWTtBQUNqQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL3JvbGVNYW5hZ2VyLnRzP2UzYmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2xpYi9yb2xlTWFuYWdlci50c1xuLy8gQnVsbGV0cHJvb2Ygcm9sZSBtYW5hZ2VtZW50IHN5c3RlbSB0aGF0IG1haW50YWlucyBwbGF5ZXIgcm9sZXMgdGhyb3VnaG91dCB0aGUgZW50aXJlIGdhbWUgc2Vzc2lvblxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmV4cG9ydCBpbnRlcmZhY2UgUGxheWVyU2Vzc2lvbiB7XG4gIHNlc3Npb25JZDogc3RyaW5nXG4gIHBsYXllclJvbGU6ICdwbGF5ZXJfYScgfCAncGxheWVyX2InIHwgJ3NwZWN0YXRvcidcbiAgcm9vbUlkOiBzdHJpbmdcbiAgYXNzaWduZWRBdDogbnVtYmVyIC8vIHRpbWVzdGFtcCB3aGVuIHJvbGUgd2FzIGFzc2lnbmVkXG4gIGlzTG9ja2VkOiBib29sZWFuIC8vIHByZXZlbnRzIHJvbGUgY2hhbmdlcyBvbmNlIGdhbWUgc3RhcnRzXG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSBhIHByb3BlciBVVUlEIHY0XG5mdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKTogc3RyaW5nIHtcbiAgLy8gVXNlIGNyeXB0by5yYW5kb21VVUlEIGlmIGF2YWlsYWJsZSAobW9kZXJuIGJyb3dzZXJzKVxuICBpZiAodHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLnJhbmRvbVVVSUQpIHtcbiAgICByZXR1cm4gY3J5cHRvLnJhbmRvbVVVSUQoKVxuICB9XG4gIFxuICAvLyBGYWxsYmFjayB0byBtYW51YWwgZ2VuZXJhdGlvbiAocHJvcGVyIFVVSUQgdjQgZm9ybWF0KVxuICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XG4gICAgY29uc3QgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMFxuICAgIGNvbnN0IHYgPSBjID09PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4XG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpXG4gIH0pXG59XG5cbi8vIFNpbmdsZSBzb3VyY2Ugb2YgdHJ1dGggZm9yIHJvbGUgbWFuYWdlbWVudFxuY2xhc3MgUm9sZU1hbmFnZXIge1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogUm9sZU1hbmFnZXJcbiAgcHJpdmF0ZSBjdXJyZW50U2Vzc2lvbjogUGxheWVyU2Vzc2lvbiB8IG51bGwgPSBudWxsXG4gIFxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogUm9sZU1hbmFnZXIge1xuICAgIGlmICghUm9sZU1hbmFnZXIuaW5zdGFuY2UpIHtcbiAgICAgIFJvbGVNYW5hZ2VyLmluc3RhbmNlID0gbmV3IFJvbGVNYW5hZ2VyKClcbiAgICB9XG4gICAgcmV0dXJuIFJvbGVNYW5hZ2VyLmluc3RhbmNlXG4gIH1cblxuICAvLyBHZW5lcmF0ZSBhIGNvbnNpc3RlbnQgc2Vzc2lvbiBJRCBmb3IgdGhpcyBicm93c2VyIChwcm9wZXIgVVVJRCBmb3JtYXQpXG4gIHByaXZhdGUgZ2VuZXJhdGVTZXNzaW9uSWQoKTogc3RyaW5nIHtcbiAgICAvLyBGaXJzdCBjaGVjayBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBnbG9iYWwgc2Vzc2lvbiBJRFxuICAgIGxldCBnbG9iYWxTZXNzaW9uSWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZGViYXR0bGVfZ2xvYmFsX3Nlc3Npb24nKVxuICAgIGlmICghZ2xvYmFsU2Vzc2lvbklkIHx8ICF0aGlzLmlzVmFsaWRVVUlEKGdsb2JhbFNlc3Npb25JZCkpIHtcbiAgICAgIGdsb2JhbFNlc3Npb25JZCA9IGdlbmVyYXRlVVVJRCgpIC8vIFVzZSBwcm9wZXIgVVVJRFxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2RlYmF0dGxlX2dsb2JhbF9zZXNzaW9uJywgZ2xvYmFsU2Vzc2lvbklkKVxuICAgICAgY29uc29sZS5sb2coJ/CfhpUgUk9MRSBNQU5BR0VSIC0gR2VuZXJhdGVkIG5ldyBnbG9iYWwgc2Vzc2lvbiBVVUlEOicsIGdsb2JhbFNlc3Npb25JZC5zbGljZSgtOCkpXG4gICAgfVxuICAgIHJldHVybiBnbG9iYWxTZXNzaW9uSWRcbiAgfVxuXG4gIC8vIFZhbGlkYXRlIFVVSUQgZm9ybWF0XG4gIHByaXZhdGUgaXNWYWxpZFVVSUQodXVpZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdXVpZFJlZ2V4ID0gL15bMC05YS1mXXs4fS1bMC05YS1mXXs0fS00WzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9JC9pXG4gICAgcmV0dXJuIHV1aWRSZWdleC50ZXN0KHV1aWQpXG4gIH1cblxuICAvLyBJbml0aWFsaXplIG9yIHJldHJpZXZlIHJvbGUgZm9yIGEgc3BlY2lmaWMgcm9vbVxuICBhc3luYyBpbml0aWFsaXplUm9sZShyb29tSWQ6IHN0cmluZywgcm9vbTogYW55KTogUHJvbWlzZTxQbGF5ZXJTZXNzaW9uPiB7XG4gICAgY29uc3Qgc2Vzc2lvbktleSA9IGBkZWJhdHRsZV9yb2xlXyR7cm9vbUlkfWBcbiAgICBcbiAgICAvLyBGaXJzdCwgY2hlY2sgaWYgd2UgYWxyZWFkeSBoYXZlIGEgbG9ja2VkIHJvbGUgZm9yIHRoaXMgcm9vbVxuICAgIGNvbnN0IGV4aXN0aW5nU2Vzc2lvbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHNlc3Npb25LZXkpXG4gICAgaWYgKGV4aXN0aW5nU2Vzc2lvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFyc2VkOiBQbGF5ZXJTZXNzaW9uID0gSlNPTi5wYXJzZShleGlzdGluZ1Nlc3Npb24pXG4gICAgICAgIFxuICAgICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBzZXNzaW9uIGlzIHN0aWxsIHZhbGlkIGFuZCBoYXMgcHJvcGVyIFVVSURcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZFVVSUQocGFyc2VkLnNlc3Npb25JZCkgJiYgdGhpcy52YWxpZGF0ZVNlc3Npb24ocGFyc2VkLCByb29tKSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgUk9MRSBNQU5BR0VSIC0gUmVzdG9yZWQgZXhpc3RpbmcgdmFsaWQgc2Vzc2lvbjonLCB7XG4gICAgICAgICAgICByb2xlOiBwYXJzZWQucGxheWVyUm9sZSxcbiAgICAgICAgICAgIHNlc3Npb25JZDogcGFyc2VkLnNlc3Npb25JZC5zbGljZSgtOCksXG4gICAgICAgICAgICBpc0xvY2tlZDogcGFyc2VkLmlzTG9ja2VkXG4gICAgICAgICAgfSlcbiAgICAgICAgICB0aGlzLmN1cnJlbnRTZXNzaW9uID0gcGFyc2VkXG4gICAgICAgICAgcmV0dXJuIHBhcnNlZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfinYwgUk9MRSBNQU5BR0VSIC0gRXhpc3Rpbmcgc2Vzc2lvbiBpbnZhbGlkLCB3aWxsIGNyZWF0ZSBuZXcgb25lJylcbiAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShzZXNzaW9uS2V5KVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgUk9MRSBNQU5BR0VSIC0gRXJyb3IgcGFyc2luZyBleGlzdGluZyBzZXNzaW9uOicsIGVycm9yKVxuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShzZXNzaW9uS2V5KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENyZWF0ZSBuZXcgc2Vzc2lvbiBpZiBub25lIGV4aXN0cyBvciBleGlzdGluZyBpcyBpbnZhbGlkXG4gICAgY29uc3Qgc2Vzc2lvbklkID0gdGhpcy5nZW5lcmF0ZVNlc3Npb25JZCgpXG4gICAgY29uc3QgcGxheWVyUm9sZSA9IGF3YWl0IHRoaXMuZGV0ZXJtaW5lUm9sZUZyb21Sb29tKHJvb20sIHNlc3Npb25JZClcbiAgICBcbiAgICBjb25zdCBuZXdTZXNzaW9uOiBQbGF5ZXJTZXNzaW9uID0ge1xuICAgICAgc2Vzc2lvbklkLFxuICAgICAgcGxheWVyUm9sZSxcbiAgICAgIHJvb21JZCxcbiAgICAgIGFzc2lnbmVkQXQ6IERhdGUubm93KCksXG4gICAgICBpc0xvY2tlZDogcm9vbS5zdGF0dXMgPT09ICdkZWJhdGluZycgLy8gTG9jayByb2xlIG9uY2UgZ2FtZSBzdGFydHNcbiAgICB9XG5cbiAgICAvLyBTYXZlIHRoZSBzZXNzaW9uXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oc2Vzc2lvbktleSwgSlNPTi5zdHJpbmdpZnkobmV3U2Vzc2lvbikpXG4gICAgdGhpcy5jdXJyZW50U2Vzc2lvbiA9IG5ld1Nlc3Npb25cblxuICAgIGNvbnNvbGUubG9nKCfwn46tIFJPTEUgTUFOQUdFUiAtIENyZWF0ZWQgbmV3IHNlc3Npb246Jywge1xuICAgICAgcm9sZTogbmV3U2Vzc2lvbi5wbGF5ZXJSb2xlLFxuICAgICAgc2Vzc2lvbklkOiBuZXdTZXNzaW9uLnNlc3Npb25JZC5zbGljZSgtOCksXG4gICAgICBpc0xvY2tlZDogbmV3U2Vzc2lvbi5pc0xvY2tlZCxcbiAgICAgIHJvb21TdGF0dXM6IHJvb20uc3RhdHVzXG4gICAgfSlcblxuICAgIHJldHVybiBuZXdTZXNzaW9uXG4gIH1cblxuICAvLyBWYWxpZGF0ZSB0aGF0IGEgc2Vzc2lvbiBpcyBzdGlsbCB2YWxpZCBmb3IgdGhlIGN1cnJlbnQgcm9vbSBzdGF0ZVxuICBwcml2YXRlIHZhbGlkYXRlU2Vzc2lvbihzZXNzaW9uOiBQbGF5ZXJTZXNzaW9uLCByb29tOiBhbnkpOiBib29sZWFuIHtcbiAgICAvLyBDaGVjayBpZiByb29tIHN0aWxsIGV4aXN0cyBhbmQgc2Vzc2lvbiBJRCBtYXRjaGVzIGV4cGVjdGVkIHBsYXllclxuICAgIGlmIChzZXNzaW9uLnBsYXllclJvbGUgPT09ICdwbGF5ZXJfYScpIHtcbiAgICAgIHJldHVybiByb29tLnBsYXllcl9hX2lkID09PSBzZXNzaW9uLnNlc3Npb25JZFxuICAgIH0gZWxzZSBpZiAoc2Vzc2lvbi5wbGF5ZXJSb2xlID09PSAncGxheWVyX2InKSB7XG4gICAgICByZXR1cm4gcm9vbS5wbGF5ZXJfYl9pZCA9PT0gc2Vzc2lvbi5zZXNzaW9uSWRcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNlc3Npb24ucGxheWVyUm9sZSA9PT0gJ3NwZWN0YXRvcicgLy8gU3BlY3RhdG9ycyBhcmUgYWx3YXlzIHZhbGlkXG4gICAgfVxuICB9XG5cbiAgLy8gRGV0ZXJtaW5lIHJvbGUgYmFzZWQgb24gcm9vbSBzdGF0ZSBhbmQgc2Vzc2lvbiBJRFxuICBwcml2YXRlIGFzeW5jIGRldGVybWluZVJvbGVGcm9tUm9vbShyb29tOiBhbnksIHNlc3Npb25JZDogc3RyaW5nKTogUHJvbWlzZTwncGxheWVyX2EnIHwgJ3BsYXllcl9iJyB8ICdzcGVjdGF0b3InPiB7XG4gICAgY29uc29sZS5sb2coJ/CflI0gUk9MRSBNQU5BR0VSIC0gRGV0ZXJtaW5pbmcgcm9sZSBmcm9tIHJvb206Jywge1xuICAgICAgc2Vzc2lvbklkOiBzZXNzaW9uSWQuc2xpY2UoLTgpLFxuICAgICAgcm9vbVBsYXllckE6IHJvb20ucGxheWVyX2FfaWQ/LnNsaWNlKC04KSxcbiAgICAgIHJvb21QbGF5ZXJCOiByb29tLnBsYXllcl9iX2lkPy5zbGljZSgtOClcbiAgICB9KVxuXG4gICAgLy8gQ2hlY2sgZGlyZWN0IElEIG1hdGNoZXMgZmlyc3RcbiAgICBpZiAocm9vbS5wbGF5ZXJfYV9pZCA9PT0gc2Vzc2lvbklkKSB7XG4gICAgICBjb25zb2xlLmxvZygn4pyFIFJPTEUgTUFOQUdFUiAtIE1hdGNoZWQgYXMgUGxheWVyIEEgYnkgSUQnKVxuICAgICAgcmV0dXJuICdwbGF5ZXJfYSdcbiAgICB9XG4gICAgXG4gICAgaWYgKHJvb20ucGxheWVyX2JfaWQgPT09IHNlc3Npb25JZCkge1xuICAgICAgY29uc29sZS5sb2coJ+KchSBST0xFIE1BTkFHRVIgLSBNYXRjaGVkIGFzIFBsYXllciBCIGJ5IElEJylcbiAgICAgIHJldHVybiAncGxheWVyX2InXG4gICAgfVxuXG4gICAgLy8gSWYgbm8gbWF0Y2ggZm91bmQsIHVzZXIgaXMgYSBzcGVjdGF0b3JcbiAgICBjb25zb2xlLmxvZygn8J+RgCBST0xFIE1BTkFHRVIgLSBObyBtYXRjaCBmb3VuZCwgYXNzaWduZWQgYXMgc3BlY3RhdG9yJylcbiAgICByZXR1cm4gJ3NwZWN0YXRvcidcbiAgfVxuXG4gIC8vIEdldCBjdXJyZW50IHNlc3Npb24gKHVzZWQgYnkgY29tcG9uZW50cylcbiAgZ2V0Q3VycmVudFNlc3Npb24oKTogUGxheWVyU2Vzc2lvbiB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTZXNzaW9uXG4gIH1cblxuICAvLyBMb2NrIHRoZSByb2xlIG9uY2UgZ2FtZSBzdGFydHMgKHByZXZlbnRzIGNoYW5nZXMgZHVyaW5nIGdhbWUpXG4gIGxvY2tSb2xlKHJvb21JZDogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY3VycmVudFNlc3Npb24gJiYgdGhpcy5jdXJyZW50U2Vzc2lvbi5yb29tSWQgPT09IHJvb21JZCkge1xuICAgICAgdGhpcy5jdXJyZW50U2Vzc2lvbi5pc0xvY2tlZCA9IHRydWVcbiAgICAgIGNvbnN0IHNlc3Npb25LZXkgPSBgZGViYXR0bGVfcm9sZV8ke3Jvb21JZH1gXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShzZXNzaW9uS2V5LCBKU09OLnN0cmluZ2lmeSh0aGlzLmN1cnJlbnRTZXNzaW9uKSlcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SSIFJPTEUgTUFOQUdFUiAtIFJvbGUgbG9ja2VkIGZvciBnYW1lIHNlc3Npb24nKVxuICAgIH1cbiAgfVxuXG4gIC8vIENsZWFyIHJvbGUgd2hlbiBsZWF2aW5nIHJvb21cbiAgY2xlYXJSb2xlKHJvb21JZDogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3Qgc2Vzc2lvbktleSA9IGBkZWJhdHRsZV9yb2xlXyR7cm9vbUlkfWBcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShzZXNzaW9uS2V5KVxuICAgIFxuICAgIGlmICh0aGlzLmN1cnJlbnRTZXNzaW9uICYmIHRoaXMuY3VycmVudFNlc3Npb24ucm9vbUlkID09PSByb29tSWQpIHtcbiAgICAgIHRoaXMuY3VycmVudFNlc3Npb24gPSBudWxsXG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCfwn6e5IFJPTEUgTUFOQUdFUiAtIENsZWFyZWQgcm9sZSBmb3Igcm9vbTonLCByb29tSWQuc2xpY2UoLTgpKVxuICB9XG5cbiAgLy8gR2V0IHNlc3Npb24gSUQgZm9yIHJvb20gc2VydmljZSBjb21wYXRpYmlsaXR5IChlbnN1cmVzIHByb3BlciBVVUlEIGZvcm1hdClcbiAgZ2V0U2Vzc2lvbklkKCk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMuY3VycmVudFNlc3Npb24gJiYgdGhpcy5pc1ZhbGlkVVVJRCh0aGlzLmN1cnJlbnRTZXNzaW9uLnNlc3Npb25JZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTZXNzaW9uLnNlc3Npb25JZFxuICAgIH1cbiAgICBcbiAgICAvLyBHZW5lcmF0ZSBuZXcgVVVJRCBpZiBjdXJyZW50IHNlc3Npb24gaXMgaW52YWxpZFxuICAgIGNvbnN0IG5ld0lkID0gdGhpcy5nZW5lcmF0ZVNlc3Npb25JZCgpXG4gICAgY29uc29sZS5sb2coJ/CfhpUgUk9MRSBNQU5BR0VSIC0gR2VuZXJhdGVkIG5ldyBzZXNzaW9uIElEOicsIG5ld0lkLnNsaWNlKC04KSlcbiAgICByZXR1cm4gbmV3SWRcbiAgfVxuXG4gIC8vIERlYnVnIGhlbHBlclxuICBkZWJ1Z1Nlc3Npb24ocm9vbUlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBzZXNzaW9uS2V5ID0gYGRlYmF0dGxlX3JvbGVfJHtyb29tSWR9YFxuICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHNlc3Npb25LZXkpXG4gICAgXG4gICAgY29uc29sZS5sb2coJ/CflI0gUk9MRSBNQU5BR0VSIERFQlVHOicsIHtcbiAgICAgIGN1cnJlbnRTZXNzaW9uOiB0aGlzLmN1cnJlbnRTZXNzaW9uLFxuICAgICAgc3RvcmVkU2Vzc2lvbjogc3RvcmVkID8gSlNPTi5wYXJzZShzdG9yZWQpIDogbnVsbCxcbiAgICAgIGFsbERlYmF0dGxlS2V5czogT2JqZWN0LmtleXMobG9jYWxTdG9yYWdlKS5maWx0ZXIoayA9PiBrLmluY2x1ZGVzKCdkZWJhdHRsZScpKSxcbiAgICAgIGdsb2JhbFNlc3Npb246IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdkZWJhdHRsZV9nbG9iYWxfc2Vzc2lvbicpXG4gICAgfSlcbiAgfVxuXG4gIC8vIENsZWFuIHVwIGludmFsaWQgc2Vzc2lvbiBkYXRhXG4gIGNsZWFudXBJbnZhbGlkU2Vzc2lvbnMoKTogdm9pZCB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGxvY2FsU3RvcmFnZSkuZmlsdGVyKGsgPT4gay5pbmNsdWRlcygnZGViYXR0bGUnKSlcbiAgICBsZXQgY2xlYW5lZCA9IDBcbiAgICBcbiAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KVxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAvLyBGb3Igcm9sZSBzZXNzaW9ucywgY2hlY2sgaWYgdGhleSBoYXZlIHZhbGlkIFVVSURzXG4gICAgICAgICAgaWYgKGtleS5pbmNsdWRlcygnZGViYXR0bGVfcm9sZV8nKSkge1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IEpTT04ucGFyc2UodmFsdWUpXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZFVVSUQoc2Vzc2lvbi5zZXNzaW9uSWQpKSB7XG4gICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSlcbiAgICAgICAgICAgICAgY2xlYW5lZCsrXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn6e5IFJPTEUgTUFOQUdFUiAtIENsZWFuZWQgaW52YWxpZCBzZXNzaW9uOicsIGtleSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRm9yIGdsb2JhbCBzZXNzaW9uLCBjaGVjayBpZiBpdCdzIGEgdmFsaWQgVVVJRFxuICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ2RlYmF0dGxlX2dsb2JhbF9zZXNzaW9uJykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWRVVUlEKHZhbHVlKSkge1xuICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpXG4gICAgICAgICAgICAgIGNsZWFuZWQrK1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygn8J+nuSBST0xFIE1BTkFHRVIgLSBDbGVhbmVkIGludmFsaWQgZ2xvYmFsIHNlc3Npb24nKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KVxuICAgICAgICBjbGVhbmVkKytcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfp7kgUk9MRSBNQU5BR0VSIC0gQ2xlYW5lZCBjb3JydXB0ZWQgc2Vzc2lvbjonLCBrZXkpXG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgICBpZiAoY2xlYW5lZCA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn6e5IFJPTEUgTUFOQUdFUiAtIENsZWFuZWQgJHtjbGVhbmVkfSBpbnZhbGlkIHNlc3Npb25zYClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHJvbGVNYW5hZ2VyID0gUm9sZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKVxuXG4vLyBJbml0aWFsaXplIGNsZWFudXAgb24gbW9kdWxlIGxvYWRcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICByb2xlTWFuYWdlci5jbGVhbnVwSW52YWxpZFNlc3Npb25zKClcbn1cblxuLy8gSGVscGVyIGhvb2sgZm9yIFJlYWN0IGNvbXBvbmVudHNcbmV4cG9ydCBmdW5jdGlvbiB1c2VQbGF5ZXJSb2xlKHJvb21JZDogc3RyaW5nLCByb29tOiBhbnkpIHtcbiAgY29uc3QgW3Nlc3Npb24sIHNldFNlc3Npb25dID0gUmVhY3QudXNlU3RhdGU8UGxheWVyU2Vzc2lvbiB8IG51bGw+KG51bGwpXG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSBSZWFjdC51c2VTdGF0ZSh0cnVlKVxuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFyb29tKSByZXR1cm5cblxuICAgIGNvbnN0IGluaXRSb2xlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGxheWVyU2Vzc2lvbiA9IGF3YWl0IHJvbGVNYW5hZ2VyLmluaXRpYWxpemVSb2xlKHJvb21JZCwgcm9vbSlcbiAgICAgICAgc2V0U2Vzc2lvbihwbGF5ZXJTZXNzaW9uKVxuICAgICAgICBcbiAgICAgICAgLy8gTG9jayByb2xlIGlmIGdhbWUgaXMgaW4gcHJvZ3Jlc3NcbiAgICAgICAgaWYgKHJvb20uc3RhdHVzID09PSAnZGViYXRpbmcnICYmICFwbGF5ZXJTZXNzaW9uLmlzTG9ja2VkKSB7XG4gICAgICAgICAgcm9sZU1hbmFnZXIubG9ja1JvbGUocm9vbUlkKVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbml0aWFsaXppbmcgcm9sZTonLCBlcnJvcilcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzTG9hZGluZyhmYWxzZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0Um9sZSgpXG4gIH0sIFtyb29tSWQsIHJvb20/LmlkXSkgLy8gT25seSByZS1ydW4gaWYgcm9vbUlkIG9yIHJvb20uaWQgY2hhbmdlc1xuXG4gIHJldHVybiB7IHNlc3Npb24sIGlzTG9hZGluZyB9XG59XG5cbi8vIENvbXBhdGliaWxpdHkgZnVuY3Rpb25zIGZvciBleGlzdGluZyBjb2RlXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhYmxlUGxheWVyUm9sZShyb29tSWQ6IHN0cmluZyk6ICdwbGF5ZXJfYScgfCAncGxheWVyX2InIHwgJ3NwZWN0YXRvcicge1xuICBjb25zdCBzZXNzaW9uID0gcm9sZU1hbmFnZXIuZ2V0Q3VycmVudFNlc3Npb24oKVxuICBpZiAoc2Vzc2lvbiAmJiBzZXNzaW9uLnJvb21JZCA9PT0gcm9vbUlkKSB7XG4gICAgcmV0dXJuIHNlc3Npb24ucGxheWVyUm9sZVxuICB9XG4gIHJldHVybiAnc3BlY3RhdG9yJ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhYmxlU2Vzc2lvbklkKCk6IHN0cmluZyB7XG4gIHJldHVybiByb2xlTWFuYWdlci5nZXRTZXNzaW9uSWQoKVxufSJdLCJuYW1lcyI6WyJSZWFjdCIsImdlbmVyYXRlVVVJRCIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJyZXBsYWNlIiwiYyIsInIiLCJNYXRoIiwicmFuZG9tIiwidiIsInRvU3RyaW5nIiwiUm9sZU1hbmFnZXIiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwiZ2VuZXJhdGVTZXNzaW9uSWQiLCJnbG9iYWxTZXNzaW9uSWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiaXNWYWxpZFVVSUQiLCJzZXRJdGVtIiwiY29uc29sZSIsImxvZyIsInNsaWNlIiwidXVpZCIsInV1aWRSZWdleCIsInRlc3QiLCJpbml0aWFsaXplUm9sZSIsInJvb21JZCIsInJvb20iLCJzZXNzaW9uS2V5IiwiZXhpc3RpbmdTZXNzaW9uIiwicGFyc2VkIiwiSlNPTiIsInBhcnNlIiwic2Vzc2lvbklkIiwidmFsaWRhdGVTZXNzaW9uIiwicm9sZSIsInBsYXllclJvbGUiLCJpc0xvY2tlZCIsImN1cnJlbnRTZXNzaW9uIiwicmVtb3ZlSXRlbSIsImVycm9yIiwiZGV0ZXJtaW5lUm9sZUZyb21Sb29tIiwibmV3U2Vzc2lvbiIsImFzc2lnbmVkQXQiLCJEYXRlIiwibm93Iiwic3RhdHVzIiwic3RyaW5naWZ5Iiwicm9vbVN0YXR1cyIsInNlc3Npb24iLCJwbGF5ZXJfYV9pZCIsInBsYXllcl9iX2lkIiwicm9vbVBsYXllckEiLCJyb29tUGxheWVyQiIsImdldEN1cnJlbnRTZXNzaW9uIiwibG9ja1JvbGUiLCJjbGVhclJvbGUiLCJnZXRTZXNzaW9uSWQiLCJuZXdJZCIsImRlYnVnU2Vzc2lvbiIsInN0b3JlZCIsInN0b3JlZFNlc3Npb24iLCJhbGxEZWJhdHRsZUtleXMiLCJPYmplY3QiLCJrZXlzIiwiZmlsdGVyIiwiayIsImluY2x1ZGVzIiwiZ2xvYmFsU2Vzc2lvbiIsImNsZWFudXBJbnZhbGlkU2Vzc2lvbnMiLCJjbGVhbmVkIiwiZm9yRWFjaCIsImtleSIsInZhbHVlIiwicm9sZU1hbmFnZXIiLCJ1c2VQbGF5ZXJSb2xlIiwic2V0U2Vzc2lvbiIsInVzZVN0YXRlIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwidXNlRWZmZWN0IiwiaW5pdFJvbGUiLCJwbGF5ZXJTZXNzaW9uIiwiaWQiLCJnZXRTdGFibGVQbGF5ZXJSb2xlIiwiZ2V0U3RhYmxlU2Vzc2lvbklkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/roleManager.ts\n"));

/***/ })

});