"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/room/[id]/page",{

/***/ "(app-pages-browser)/./src/lib/roleManager.ts":
/*!********************************!*\
  !*** ./src/lib/roleManager.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getStablePlayerRole: function() { return /* binding */ getStablePlayerRole; },\n/* harmony export */   getStableSessionId: function() { return /* binding */ getStableSessionId; },\n/* harmony export */   roleManager: function() { return /* binding */ roleManager; },\n/* harmony export */   usePlayerRole: function() { return /* binding */ usePlayerRole; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n// src/lib/roleManager.ts\n// Bulletproof role management system that maintains player roles throughout the entire game session\n\n// Single source of truth for role management\nclass RoleManager {\n    static getInstance() {\n        if (!RoleManager.instance) {\n            RoleManager.instance = new RoleManager();\n        }\n        return RoleManager.instance;\n    }\n    // Generate a consistent session ID for this browser\n    generateSessionId() {\n        // First check if we already have a global session ID\n        let globalSessionId = localStorage.getItem(\"debattle_global_session\");\n        if (!globalSessionId) {\n            globalSessionId = \"session_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9));\n            localStorage.setItem(\"debattle_global_session\", globalSessionId);\n            console.log(\"\\uD83C\\uDD95 Generated new global session ID:\", globalSessionId.slice(-8));\n        }\n        return globalSessionId;\n    }\n    // Initialize or retrieve role for a specific room\n    async initializeRole(roomId, room) {\n        const sessionKey = \"debattle_role_\".concat(roomId);\n        // First, check if we already have a locked role for this room\n        const existingSession = localStorage.getItem(sessionKey);\n        if (existingSession) {\n            try {\n                const parsed = JSON.parse(existingSession);\n                // Validate that the session is still valid\n                if (this.validateSession(parsed, room)) {\n                    console.log(\"✅ ROLE MANAGER - Restored existing valid session:\", {\n                        role: parsed.playerRole,\n                        sessionId: parsed.sessionId.slice(-8),\n                        isLocked: parsed.isLocked\n                    });\n                    this.currentSession = parsed;\n                    return parsed;\n                } else {\n                    console.log(\"❌ ROLE MANAGER - Existing session invalid, will create new one\");\n                    localStorage.removeItem(sessionKey);\n                }\n            } catch (error) {\n                console.error(\"❌ ROLE MANAGER - Error parsing existing session:\", error);\n                localStorage.removeItem(sessionKey);\n            }\n        }\n        // Create new session if none exists or existing is invalid\n        const sessionId = this.generateSessionId();\n        const playerRole = await this.determineRoleFromRoom(room, sessionId);\n        const newSession = {\n            sessionId,\n            playerRole,\n            roomId,\n            assignedAt: Date.now(),\n            isLocked: room.status === \"debating\" // Lock role once game starts\n        };\n        // Save the session\n        localStorage.setItem(sessionKey, JSON.stringify(newSession));\n        this.currentSession = newSession;\n        console.log(\"\\uD83C\\uDFAD ROLE MANAGER - Created new session:\", {\n            role: newSession.playerRole,\n            sessionId: newSession.sessionId.slice(-8),\n            isLocked: newSession.isLocked,\n            roomStatus: room.status\n        });\n        return newSession;\n    }\n    // Validate that a session is still valid for the current room state\n    validateSession(session, room) {\n        // Check if room still exists and session ID matches expected player\n        if (session.playerRole === \"player_a\") {\n            return room.player_a_id === session.sessionId;\n        } else if (session.playerRole === \"player_b\") {\n            return room.player_b_id === session.sessionId;\n        } else {\n            return session.playerRole === \"spectator\" // Spectators are always valid\n            ;\n        }\n    }\n    // Determine role based on room state and session ID\n    async determineRoleFromRoom(room, sessionId) {\n        var _room_player_a_id, _room_player_b_id;\n        console.log(\"\\uD83D\\uDD0D ROLE MANAGER - Determining role from room:\", {\n            sessionId: sessionId.slice(-8),\n            roomPlayerA: (_room_player_a_id = room.player_a_id) === null || _room_player_a_id === void 0 ? void 0 : _room_player_a_id.slice(-8),\n            roomPlayerB: (_room_player_b_id = room.player_b_id) === null || _room_player_b_id === void 0 ? void 0 : _room_player_b_id.slice(-8)\n        });\n        // Check direct ID matches first\n        if (room.player_a_id === sessionId) {\n            console.log(\"✅ ROLE MANAGER - Matched as Player A by ID\");\n            return \"player_a\";\n        }\n        if (room.player_b_id === sessionId) {\n            console.log(\"✅ ROLE MANAGER - Matched as Player B by ID\");\n            return \"player_b\";\n        }\n        // If no match found, user is a spectator\n        console.log(\"\\uD83D\\uDC40 ROLE MANAGER - No match found, assigned as spectator\");\n        return \"spectator\";\n    }\n    // Get current session (used by components)\n    getCurrentSession() {\n        return this.currentSession;\n    }\n    // Lock the role once game starts (prevents changes during game)\n    lockRole(roomId) {\n        if (this.currentSession && this.currentSession.roomId === roomId) {\n            this.currentSession.isLocked = true;\n            const sessionKey = \"debattle_role_\".concat(roomId);\n            localStorage.setItem(sessionKey, JSON.stringify(this.currentSession));\n            console.log(\"\\uD83D\\uDD12 ROLE MANAGER - Role locked for game session\");\n        }\n    }\n    // Clear role when leaving room\n    clearRole(roomId) {\n        const sessionKey = \"debattle_role_\".concat(roomId);\n        localStorage.removeItem(sessionKey);\n        if (this.currentSession && this.currentSession.roomId === roomId) {\n            this.currentSession = null;\n        }\n        console.log(\"\\uD83E\\uDDF9 ROLE MANAGER - Cleared role for room:\", roomId.slice(-8));\n    }\n    // Get session ID for room service compatibility\n    getSessionId() {\n        if (this.currentSession) {\n            return this.currentSession.sessionId;\n        }\n        return this.generateSessionId();\n    }\n    // Debug helper\n    debugSession(roomId) {\n        const sessionKey = \"debattle_role_\".concat(roomId);\n        const stored = localStorage.getItem(sessionKey);\n        console.log(\"\\uD83D\\uDD0D ROLE MANAGER DEBUG:\", {\n            currentSession: this.currentSession,\n            storedSession: stored ? JSON.parse(stored) : null,\n            allDebattleKeys: Object.keys(localStorage).filter((k)=>k.includes(\"debattle\"))\n        });\n    }\n    constructor(){\n        this.currentSession = null;\n    }\n}\nconst roleManager = RoleManager.getInstance();\n// Helper hook for React components\nfunction usePlayerRole(roomId, room) {\n    const [session, setSession] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(null);\n    const [isLoading, setIsLoading] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(true);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(()=>{\n        if (!room) return;\n        const initRole = async ()=>{\n            try {\n                const playerSession = await roleManager.initializeRole(roomId, room);\n                setSession(playerSession);\n                // Lock role if game is in progress\n                if (room.status === \"debating\" && !playerSession.isLocked) {\n                    roleManager.lockRole(roomId);\n                }\n            } catch (error) {\n                console.error(\"Error initializing role:\", error);\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        initRole();\n    }, [\n        roomId,\n        room === null || room === void 0 ? void 0 : room.id\n    ]) // Only re-run if roomId or room.id changes\n    ;\n    return {\n        session,\n        isLoading\n    };\n}\n// Compatibility functions for existing code\nfunction getStablePlayerRole(roomId) {\n    const session = roleManager.getCurrentSession();\n    if (session && session.roomId === roomId) {\n        return session.playerRole;\n    }\n    return \"spectator\";\n}\nfunction getStableSessionId() {\n    return roleManager.getSessionId();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvcm9sZU1hbmFnZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEseUJBQXlCO0FBQ3pCLG9HQUFvRztBQUUzRTtBQVV6Qiw2Q0FBNkM7QUFDN0MsTUFBTUM7SUFJSixPQUFPQyxjQUEyQjtRQUNoQyxJQUFJLENBQUNELFlBQVlFLFFBQVEsRUFBRTtZQUN6QkYsWUFBWUUsUUFBUSxHQUFHLElBQUlGO1FBQzdCO1FBQ0EsT0FBT0EsWUFBWUUsUUFBUTtJQUM3QjtJQUVBLG9EQUFvRDtJQUM1Q0Msb0JBQTRCO1FBQ2xDLHFEQUFxRDtRQUNyRCxJQUFJQyxrQkFBa0JDLGFBQWFDLE9BQU8sQ0FBQztRQUMzQyxJQUFJLENBQUNGLGlCQUFpQjtZQUNwQkEsa0JBQWtCLFdBQXlCRyxPQUFkQyxLQUFLQyxHQUFHLElBQUcsS0FBMkMsT0FBeENGLEtBQUtHLE1BQU0sR0FBR0MsUUFBUSxDQUFDLElBQUlDLE1BQU0sQ0FBQyxHQUFHO1lBQ2hGUCxhQUFhUSxPQUFPLENBQUMsMkJBQTJCVDtZQUNoRFUsUUFBUUMsR0FBRyxDQUFDLGlEQUF1Q1gsZ0JBQWdCWSxLQUFLLENBQUMsQ0FBQztRQUM1RTtRQUNBLE9BQU9aO0lBQ1Q7SUFFQSxrREFBa0Q7SUFDbEQsTUFBTWEsZUFBZUMsTUFBYyxFQUFFQyxJQUFTLEVBQTBCO1FBQ3RFLE1BQU1DLGFBQWEsaUJBQXdCLE9BQVBGO1FBRXBDLDhEQUE4RDtRQUM5RCxNQUFNRyxrQkFBa0JoQixhQUFhQyxPQUFPLENBQUNjO1FBQzdDLElBQUlDLGlCQUFpQjtZQUNuQixJQUFJO2dCQUNGLE1BQU1DLFNBQXdCQyxLQUFLQyxLQUFLLENBQUNIO2dCQUV6QywyQ0FBMkM7Z0JBQzNDLElBQUksSUFBSSxDQUFDSSxlQUFlLENBQUNILFFBQVFILE9BQU87b0JBQ3RDTCxRQUFRQyxHQUFHLENBQUMscURBQXFEO3dCQUMvRFcsTUFBTUosT0FBT0ssVUFBVTt3QkFDdkJDLFdBQVdOLE9BQU9N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QUFXQyxhQUFhLEdBQUcvRCxxREFBYyxDQUFDO0lBRWpEQSxzREFBZSxDQUFDO1FBQ2QsSUFBSSxDQUFDb0IsTUFBTTtRQUVYLE1BQU02QyxXQUFXO1lBQ2YsSUFBSTtnQkFDRixNQUFNQyxnQkFBZ0IsTUFBTVIsWUFBWXhDLGNBQWMsQ0FBQ0MsUUFBUUM7Z0JBQy9Ed0MsV0FBV007Z0JBRVgsbUNBQW1DO2dCQUNuQyxJQUFJOUMsS0FBS2lCLE1BQU0sS0FBSyxjQUFjLENBQUM2QixjQUFjcEMsUUFBUSxFQUFFO29CQUN6RDRCLFlBQVlaLFFBQVEsQ0FBQzNCO2dCQUN2QjtZQUNGLEVBQUUsT0FBT2MsT0FBTztnQkFDZGxCLFFBQVFrQixLQUFLLENBQUMsNEJBQTRCQTtZQUM1QyxTQUFVO2dCQUNSOEIsYUFBYTtZQUNmO1FBQ0Y7UUFFQUU7SUFDRixHQUFHO1FBQUM5QztRQUFRQyxpQkFBQUEsMkJBQUFBLEtBQU0rQyxFQUFFO0tBQUMsRUFBRSwyQ0FBMkM7O0lBRWxFLE9BQU87UUFBRTNCO1FBQVNzQjtJQUFVO0FBQzlCO0FBRUEsNENBQTRDO0FBQ3JDLFNBQVNNLG9CQUFvQmpELE1BQWM7SUFDaEQsTUFBTXFCLFVBQVVrQixZQUFZYixpQkFBaUI7SUFDN0MsSUFBSUwsV0FBV0EsUUFBUXJCLE1BQU0sS0FBS0EsUUFBUTtRQUN4QyxPQUFPcUIsUUFBUVosVUFBVTtJQUMzQjtJQUNBLE9BQU87QUFDVDtBQUVPLFNBQVN5QztJQUNkLE9BQU9YLFlBQVlWLFlBQVk7QUFDakMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9yb2xlTWFuYWdlci50cz9lM2JkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9saWIvcm9sZU1hbmFnZXIudHNcbi8vIEJ1bGxldHByb29mIHJvbGUgbWFuYWdlbWVudCBzeXN0ZW0gdGhhdCBtYWludGFpbnMgcGxheWVyIHJvbGVzIHRocm91Z2hvdXQgdGhlIGVudGlyZSBnYW1lIHNlc3Npb25cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5leHBvcnQgaW50ZXJmYWNlIFBsYXllclNlc3Npb24ge1xuICBzZXNzaW9uSWQ6IHN0cmluZ1xuICBwbGF5ZXJSb2xlOiAncGxheWVyX2EnIHwgJ3BsYXllcl9iJyB8ICdzcGVjdGF0b3InXG4gIHJvb21JZDogc3RyaW5nXG4gIGFzc2lnbmVkQXQ6IG51bWJlciAvLyB0aW1lc3RhbXAgd2hlbiByb2xlIHdhcyBhc3NpZ25lZFxuICBpc0xvY2tlZDogYm9vbGVhbiAvLyBwcmV2ZW50cyByb2xlIGNoYW5nZXMgb25jZSBnYW1lIHN0YXJ0c1xufVxuXG4vLyBTaW5nbGUgc291cmNlIG9mIHRydXRoIGZvciByb2xlIG1hbmFnZW1lbnRcbmNsYXNzIFJvbGVNYW5hZ2VyIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFJvbGVNYW5hZ2VyXG4gIHByaXZhdGUgY3VycmVudFNlc3Npb246IFBsYXllclNlc3Npb24gfCBudWxsID0gbnVsbFxuICBcbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IFJvbGVNYW5hZ2VyIHtcbiAgICBpZiAoIVJvbGVNYW5hZ2VyLmluc3RhbmNlKSB7XG4gICAgICBSb2xlTWFuYWdlci5pbnN0YW5jZSA9IG5ldyBSb2xlTWFuYWdlcigpXG4gICAgfVxuICAgIHJldHVybiBSb2xlTWFuYWdlci5pbnN0YW5jZVxuICB9XG5cbiAgLy8gR2VuZXJhdGUgYSBjb25zaXN0ZW50IHNlc3Npb24gSUQgZm9yIHRoaXMgYnJvd3NlclxuICBwcml2YXRlIGdlbmVyYXRlU2Vzc2lvbklkKCk6IHN0cmluZyB7XG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgd2UgYWxyZWFkeSBoYXZlIGEgZ2xvYmFsIHNlc3Npb24gSURcbiAgICBsZXQgZ2xvYmFsU2Vzc2lvbklkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2RlYmF0dGxlX2dsb2JhbF9zZXNzaW9uJylcbiAgICBpZiAoIWdsb2JhbFNlc3Npb25JZCkge1xuICAgICAgZ2xvYmFsU2Vzc2lvbklkID0gYHNlc3Npb25fJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnZGViYXR0bGVfZ2xvYmFsX3Nlc3Npb24nLCBnbG9iYWxTZXNzaW9uSWQpXG4gICAgICBjb25zb2xlLmxvZygn8J+GlSBHZW5lcmF0ZWQgbmV3IGdsb2JhbCBzZXNzaW9uIElEOicsIGdsb2JhbFNlc3Npb25JZC5zbGljZSgtOCkpXG4gICAgfVxuICAgIHJldHVybiBnbG9iYWxTZXNzaW9uSWRcbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgb3IgcmV0cmlldmUgcm9sZSBmb3IgYSBzcGVjaWZpYyByb29tXG4gIGFzeW5jIGluaXRpYWxpemVSb2xlKHJvb21JZDogc3RyaW5nLCByb29tOiBhbnkpOiBQcm9taXNlPFBsYXllclNlc3Npb24+IHtcbiAgICBjb25zdCBzZXNzaW9uS2V5ID0gYGRlYmF0dGxlX3JvbGVfJHtyb29tSWR9YFxuICAgIFxuICAgIC8vIEZpcnN0LCBjaGVjayBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBsb2NrZWQgcm9sZSBmb3IgdGhpcyByb29tXG4gICAgY29uc3QgZXhpc3RpbmdTZXNzaW9uID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oc2Vzc2lvbktleSlcbiAgICBpZiAoZXhpc3RpbmdTZXNzaW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXJzZWQ6IFBsYXllclNlc3Npb24gPSBKU09OLnBhcnNlKGV4aXN0aW5nU2Vzc2lvbilcbiAgICAgICAgXG4gICAgICAgIC8vIFZhbGlkYXRlIHRoYXQgdGhlIHNlc3Npb24gaXMgc3RpbGwgdmFsaWRcbiAgICAgICAgaWYgKHRoaXMudmFsaWRhdGVTZXNzaW9uKHBhcnNlZCwgcm9vbSkpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIFJPTEUgTUFOQUdFUiAtIFJlc3RvcmVkIGV4aXN0aW5nIHZhbGlkIHNlc3Npb246Jywge1xuICAgICAgICAgICAgcm9sZTogcGFyc2VkLnBsYXllclJvbGUsXG4gICAgICAgICAgICBzZXNzaW9uSWQ6IHBhcnNlZC5zZXNzaW9uSWQuc2xpY2UoLTgpLFxuICAgICAgICAgICAgaXNMb2NrZWQ6IHBhcnNlZC5pc0xvY2tlZFxuICAgICAgICAgIH0pXG4gICAgICAgICAgdGhpcy5jdXJyZW50U2Vzc2lvbiA9IHBhcnNlZFxuICAgICAgICAgIHJldHVybiBwYXJzZWRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygn4p2MIFJPTEUgTUFOQUdFUiAtIEV4aXN0aW5nIHNlc3Npb24gaW52YWxpZCwgd2lsbCBjcmVhdGUgbmV3IG9uZScpXG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oc2Vzc2lvbktleSlcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFJPTEUgTUFOQUdFUiAtIEVycm9yIHBhcnNpbmcgZXhpc3Rpbmcgc2Vzc2lvbjonLCBlcnJvcilcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oc2Vzc2lvbktleSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgbmV3IHNlc3Npb24gaWYgbm9uZSBleGlzdHMgb3IgZXhpc3RpbmcgaXMgaW52YWxpZFxuICAgIGNvbnN0IHNlc3Npb25JZCA9IHRoaXMuZ2VuZXJhdGVTZXNzaW9uSWQoKVxuICAgIGNvbnN0IHBsYXllclJvbGUgPSBhd2FpdCB0aGlzLmRldGVybWluZVJvbGVGcm9tUm9vbShyb29tLCBzZXNzaW9uSWQpXG4gICAgXG4gICAgY29uc3QgbmV3U2Vzc2lvbjogUGxheWVyU2Vzc2lvbiA9IHtcbiAgICAgIHNlc3Npb25JZCxcbiAgICAgIHBsYXllclJvbGUsXG4gICAgICByb29tSWQsXG4gICAgICBhc3NpZ25lZEF0OiBEYXRlLm5vdygpLFxuICAgICAgaXNMb2NrZWQ6IHJvb20uc3RhdHVzID09PSAnZGViYXRpbmcnIC8vIExvY2sgcm9sZSBvbmNlIGdhbWUgc3RhcnRzXG4gICAgfVxuXG4gICAgLy8gU2F2ZSB0aGUgc2Vzc2lvblxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHNlc3Npb25LZXksIEpTT04uc3RyaW5naWZ5KG5ld1Nlc3Npb24pKVxuICAgIHRoaXMuY3VycmVudFNlc3Npb24gPSBuZXdTZXNzaW9uXG5cbiAgICBjb25zb2xlLmxvZygn8J+OrSBST0xFIE1BTkFHRVIgLSBDcmVhdGVkIG5ldyBzZXNzaW9uOicsIHtcbiAgICAgIHJvbGU6IG5ld1Nlc3Npb24ucGxheWVyUm9sZSxcbiAgICAgIHNlc3Npb25JZDogbmV3U2Vzc2lvbi5zZXNzaW9uSWQuc2xpY2UoLTgpLFxuICAgICAgaXNMb2NrZWQ6IG5ld1Nlc3Npb24uaXNMb2NrZWQsXG4gICAgICByb29tU3RhdHVzOiByb29tLnN0YXR1c1xuICAgIH0pXG5cbiAgICByZXR1cm4gbmV3U2Vzc2lvblxuICB9XG5cbiAgLy8gVmFsaWRhdGUgdGhhdCBhIHNlc3Npb24gaXMgc3RpbGwgdmFsaWQgZm9yIHRoZSBjdXJyZW50IHJvb20gc3RhdGVcbiAgcHJpdmF0ZSB2YWxpZGF0ZVNlc3Npb24oc2Vzc2lvbjogUGxheWVyU2Vzc2lvbiwgcm9vbTogYW55KTogYm9vbGVhbiB7XG4gICAgLy8gQ2hlY2sgaWYgcm9vbSBzdGlsbCBleGlzdHMgYW5kIHNlc3Npb24gSUQgbWF0Y2hlcyBleHBlY3RlZCBwbGF5ZXJcbiAgICBpZiAoc2Vzc2lvbi5wbGF5ZXJSb2xlID09PSAncGxheWVyX2EnKSB7XG4gICAgICByZXR1cm4gcm9vbS5wbGF5ZXJfYV9pZCA9PT0gc2Vzc2lvbi5zZXNzaW9uSWRcbiAgICB9IGVsc2UgaWYgKHNlc3Npb24ucGxheWVyUm9sZSA9PT0gJ3BsYXllcl9iJykge1xuICAgICAgcmV0dXJuIHJvb20ucGxheWVyX2JfaWQgPT09IHNlc3Npb24uc2Vzc2lvbklkXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzZXNzaW9uLnBsYXllclJvbGUgPT09ICdzcGVjdGF0b3InIC8vIFNwZWN0YXRvcnMgYXJlIGFsd2F5cyB2YWxpZFxuICAgIH1cbiAgfVxuXG4gIC8vIERldGVybWluZSByb2xlIGJhc2VkIG9uIHJvb20gc3RhdGUgYW5kIHNlc3Npb24gSURcbiAgcHJpdmF0ZSBhc3luYyBkZXRlcm1pbmVSb2xlRnJvbVJvb20ocm9vbTogYW55LCBzZXNzaW9uSWQ6IHN0cmluZyk6IFByb21pc2U8J3BsYXllcl9hJyB8ICdwbGF5ZXJfYicgfCAnc3BlY3RhdG9yJz4ge1xuICAgIGNvbnNvbGUubG9nKCfwn5SNIFJPTEUgTUFOQUdFUiAtIERldGVybWluaW5nIHJvbGUgZnJvbSByb29tOicsIHtcbiAgICAgIHNlc3Npb25JZDogc2Vzc2lvbklkLnNsaWNlKC04KSxcbiAgICAgIHJvb21QbGF5ZXJBOiByb29tLnBsYXllcl9hX2lkPy5zbGljZSgtOCksXG4gICAgICByb29tUGxheWVyQjogcm9vbS5wbGF5ZXJfYl9pZD8uc2xpY2UoLTgpXG4gICAgfSlcblxuICAgIC8vIENoZWNrIGRpcmVjdCBJRCBtYXRjaGVzIGZpcnN0XG4gICAgaWYgKHJvb20ucGxheWVyX2FfaWQgPT09IHNlc3Npb25JZCkge1xuICAgICAgY29uc29sZS5sb2coJ+KchSBST0xFIE1BTkFHRVIgLSBNYXRjaGVkIGFzIFBsYXllciBBIGJ5IElEJylcbiAgICAgIHJldHVybiAncGxheWVyX2EnXG4gICAgfVxuICAgIFxuICAgIGlmIChyb29tLnBsYXllcl9iX2lkID09PSBzZXNzaW9uSWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgUk9MRSBNQU5BR0VSIC0gTWF0Y2hlZCBhcyBQbGF5ZXIgQiBieSBJRCcpXG4gICAgICByZXR1cm4gJ3BsYXllcl9iJ1xuICAgIH1cblxuICAgIC8vIElmIG5vIG1hdGNoIGZvdW5kLCB1c2VyIGlzIGEgc3BlY3RhdG9yXG4gICAgY29uc29sZS5sb2coJ/CfkYAgUk9MRSBNQU5BR0VSIC0gTm8gbWF0Y2ggZm91bmQsIGFzc2lnbmVkIGFzIHNwZWN0YXRvcicpXG4gICAgcmV0dXJuICdzcGVjdGF0b3InXG4gIH1cblxuICAvLyBHZXQgY3VycmVudCBzZXNzaW9uICh1c2VkIGJ5IGNvbXBvbmVudHMpXG4gIGdldEN1cnJlbnRTZXNzaW9uKCk6IFBsYXllclNlc3Npb24gfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50U2Vzc2lvblxuICB9XG5cbiAgLy8gTG9jayB0aGUgcm9sZSBvbmNlIGdhbWUgc3RhcnRzIChwcmV2ZW50cyBjaGFuZ2VzIGR1cmluZyBnYW1lKVxuICBsb2NrUm9sZShyb29tSWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGlzLmN1cnJlbnRTZXNzaW9uICYmIHRoaXMuY3VycmVudFNlc3Npb24ucm9vbUlkID09PSByb29tSWQpIHtcbiAgICAgIHRoaXMuY3VycmVudFNlc3Npb24uaXNMb2NrZWQgPSB0cnVlXG4gICAgICBjb25zdCBzZXNzaW9uS2V5ID0gYGRlYmF0dGxlX3JvbGVfJHtyb29tSWR9YFxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oc2Vzc2lvbktleSwgSlNPTi5zdHJpbmdpZnkodGhpcy5jdXJyZW50U2Vzc2lvbikpXG4gICAgICBjb25zb2xlLmxvZygn8J+UkiBST0xFIE1BTkFHRVIgLSBSb2xlIGxvY2tlZCBmb3IgZ2FtZSBzZXNzaW9uJylcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhciByb2xlIHdoZW4gbGVhdmluZyByb29tXG4gIGNsZWFyUm9sZShyb29tSWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IHNlc3Npb25LZXkgPSBgZGViYXR0bGVfcm9sZV8ke3Jvb21JZH1gXG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oc2Vzc2lvbktleSlcbiAgICBcbiAgICBpZiAodGhpcy5jdXJyZW50U2Vzc2lvbiAmJiB0aGlzLmN1cnJlbnRTZXNzaW9uLnJvb21JZCA9PT0gcm9vbUlkKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTZXNzaW9uID0gbnVsbFxuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZygn8J+nuSBST0xFIE1BTkFHRVIgLSBDbGVhcmVkIHJvbGUgZm9yIHJvb206Jywgcm9vbUlkLnNsaWNlKC04KSlcbiAgfVxuXG4gIC8vIEdldCBzZXNzaW9uIElEIGZvciByb29tIHNlcnZpY2UgY29tcGF0aWJpbGl0eVxuICBnZXRTZXNzaW9uSWQoKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy5jdXJyZW50U2Vzc2lvbikge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFNlc3Npb24uc2Vzc2lvbklkXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdlbmVyYXRlU2Vzc2lvbklkKClcbiAgfVxuXG4gIC8vIERlYnVnIGhlbHBlclxuICBkZWJ1Z1Nlc3Npb24ocm9vbUlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBzZXNzaW9uS2V5ID0gYGRlYmF0dGxlX3JvbGVfJHtyb29tSWR9YFxuICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHNlc3Npb25LZXkpXG4gICAgXG4gICAgY29uc29sZS5sb2coJ/CflI0gUk9MRSBNQU5BR0VSIERFQlVHOicsIHtcbiAgICAgIGN1cnJlbnRTZXNzaW9uOiB0aGlzLmN1cnJlbnRTZXNzaW9uLFxuICAgICAgc3RvcmVkU2Vzc2lvbjogc3RvcmVkID8gSlNPTi5wYXJzZShzdG9yZWQpIDogbnVsbCxcbiAgICAgIGFsbERlYmF0dGxlS2V5czogT2JqZWN0LmtleXMobG9jYWxTdG9yYWdlKS5maWx0ZXIoayA9PiBrLmluY2x1ZGVzKCdkZWJhdHRsZScpKVxuICAgIH0pXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHJvbGVNYW5hZ2VyID0gUm9sZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKVxuXG4vLyBIZWxwZXIgaG9vayBmb3IgUmVhY3QgY29tcG9uZW50c1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVBsYXllclJvbGUocm9vbUlkOiBzdHJpbmcsIHJvb206IGFueSkge1xuICBjb25zdCBbc2Vzc2lvbiwgc2V0U2Vzc2lvbl0gPSBSZWFjdC51c2VTdGF0ZTxQbGF5ZXJTZXNzaW9uIHwgbnVsbD4obnVsbClcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IFJlYWN0LnVzZVN0YXRlKHRydWUpXG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXJvb20pIHJldHVyblxuXG4gICAgY29uc3QgaW5pdFJvbGUgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwbGF5ZXJTZXNzaW9uID0gYXdhaXQgcm9sZU1hbmFnZXIuaW5pdGlhbGl6ZVJvbGUocm9vbUlkLCByb29tKVxuICAgICAgICBzZXRTZXNzaW9uKHBsYXllclNlc3Npb24pXG4gICAgICAgIFxuICAgICAgICAvLyBMb2NrIHJvbGUgaWYgZ2FtZSBpcyBpbiBwcm9ncmVzc1xuICAgICAgICBpZiAocm9vbS5zdGF0dXMgPT09ICdkZWJhdGluZycgJiYgIXBsYXllclNlc3Npb24uaXNMb2NrZWQpIHtcbiAgICAgICAgICByb2xlTWFuYWdlci5sb2NrUm9sZShyb29tSWQpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyByb2xlOicsIGVycm9yKVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKVxuICAgICAgfVxuICAgIH1cblxuICAgIGluaXRSb2xlKClcbiAgfSwgW3Jvb21JZCwgcm9vbT8uaWRdKSAvLyBPbmx5IHJlLXJ1biBpZiByb29tSWQgb3Igcm9vbS5pZCBjaGFuZ2VzXG5cbiAgcmV0dXJuIHsgc2Vzc2lvbiwgaXNMb2FkaW5nIH1cbn1cblxuLy8gQ29tcGF0aWJpbGl0eSBmdW5jdGlvbnMgZm9yIGV4aXN0aW5nIGNvZGVcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGFibGVQbGF5ZXJSb2xlKHJvb21JZDogc3RyaW5nKTogJ3BsYXllcl9hJyB8ICdwbGF5ZXJfYicgfCAnc3BlY3RhdG9yJyB7XG4gIGNvbnN0IHNlc3Npb24gPSByb2xlTWFuYWdlci5nZXRDdXJyZW50U2Vzc2lvbigpXG4gIGlmIChzZXNzaW9uICYmIHNlc3Npb24ucm9vbUlkID09PSByb29tSWQpIHtcbiAgICByZXR1cm4gc2Vzc2lvbi5wbGF5ZXJSb2xlXG4gIH1cbiAgcmV0dXJuICdzcGVjdGF0b3InXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGFibGVTZXNzaW9uSWQoKTogc3RyaW5nIHtcbiAgcmV0dXJuIHJvbGVNYW5hZ2VyLmdldFNlc3Npb25JZCgpXG59Il0sIm5hbWVzIjpbIlJlYWN0IiwiUm9sZU1hbmFnZXIiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwiZ2VuZXJhdGVTZXNzaW9uSWQiLCJnbG9iYWxTZXNzaW9uSWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiTWF0aCIsIkRhdGUiLCJub3ciLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsInNldEl0ZW0iLCJjb25zb2xlIiwibG9nIiwic2xpY2UiLCJpbml0aWFsaXplUm9sZSIsInJvb21JZCIsInJvb20iLCJzZXNzaW9uS2V5IiwiZXhpc3RpbmdTZXNzaW9uIiwicGFyc2VkIiwiSlNPTiIsInBhcnNlIiwidmFsaWRhdGVTZXNzaW9uIiwicm9sZSIsInBsYXllclJvbGUiLCJzZXNzaW9uSWQiLCJpc0xvY2tlZCIsImN1cnJlbnRTZXNzaW9uIiwicmVtb3ZlSXRlbSIsImVycm9yIiwiZGV0ZXJtaW5lUm9sZUZyb21Sb29tIiwibmV3U2Vzc2lvbiIsImFzc2lnbmVkQXQiLCJzdGF0dXMiLCJzdHJpbmdpZnkiLCJyb29tU3RhdHVzIiwic2Vzc2lvbiIsInBsYXllcl9hX2lkIiwicGxheWVyX2JfaWQiLCJyb29tUGxheWVyQSIsInJvb21QbGF5ZXJCIiwiZ2V0Q3VycmVudFNlc3Npb24iLCJsb2NrUm9sZSIsImNsZWFyUm9sZSIsImdldFNlc3Npb25JZCIsImRlYnVnU2Vzc2lvbiIsInN0b3JlZCIsInN0b3JlZFNlc3Npb24iLCJhbGxEZWJhdHRsZUtleXMiLCJPYmplY3QiLCJrZXlzIiwiZmlsdGVyIiwiayIsImluY2x1ZGVzIiwicm9sZU1hbmFnZXIiLCJ1c2VQbGF5ZXJSb2xlIiwic2V0U2Vzc2lvbiIsInVzZVN0YXRlIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwidXNlRWZmZWN0IiwiaW5pdFJvbGUiLCJwbGF5ZXJTZXNzaW9uIiwiaWQiLCJnZXRTdGFibGVQbGF5ZXJSb2xlIiwiZ2V0U3RhYmxlU2Vzc2lvbklkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/roleManager.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/roomService.ts":
/*!********************************!*\
  !*** ./src/lib/roomService.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   roomService: function() { return /* binding */ roomService; }\n/* harmony export */ });\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n/* harmony import */ var _roleManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./roleManager */ \"(app-pages-browser)/./src/lib/roleManager.ts\");\n\n\n// List of debate topics for the MVP\nconst DEBATE_TOPICS = [\n    \"Should AI be regulated?\",\n    \"Is social media harmful to democracy?\",\n    \"Should college education be free?\",\n    \"Is remote work better than office work?\",\n    \"Should voting be mandatory?\",\n    \"Is climate change the most urgent global issue?\",\n    \"Should universal basic income be implemented?\",\n    \"Is social media more harmful than helpful?\",\n    \"Should genetic engineering be widely used?\",\n    \"Is online learning better than traditional classroom education?\"\n];\n// Helper function to generate a proper UUID v4\nfunction generateUUID() {\n    // Use crypto.randomUUID if available (modern browsers)\n    if (typeof crypto !== \"undefined\" && crypto.randomUUID) {\n        return crypto.randomUUID();\n    }\n    // Fallback to manual generation\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n        const r = Math.random() * 16 | 0;\n        const v = c === \"x\" ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n    });\n}\nconst roomService = {\n    // Helper to get current Supabase user ID\n    async getUserId () {\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (error || !(data === null || data === void 0 ? void 0 : data.user)) {\n            return null;\n        }\n        return data.user.id;\n    },\n    // Get session ID from role manager (ensures consistency)\n    getSessionId () {\n        return _roleManager__WEBPACK_IMPORTED_MODULE_1__.roleManager.getSessionId();\n    },\n    // Create a new room\n    async createRoom () {\n        let userId = await this.getUserId();\n        console.log(\"\\uD83C\\uDFD7️ ROOM SERVICE - Creating room with user:\", userId === null || userId === void 0 ? void 0 : userId.slice(-8));\n        // If no authenticated user, use session UUID for guests\n        if (!userId) {\n            userId = this.getSessionId();\n            console.log(\"\\uD83C\\uDFAF ROOM SERVICE - Using session UUID for creator:\", userId.slice(-8));\n        }\n        const randomTopic = DEBATE_TOPICS[Math.floor(Math.random() * DEBATE_TOPICS.length)];\n        const roomData = {\n            topic: randomTopic,\n            status: \"waiting\",\n            player_a_health: 100,\n            player_b_health: 100,\n            player_a_ready: false,\n            player_b_ready: false,\n            player_a_id: userId\n        };\n        console.log(\"\\uD83C\\uDFD7️ ROOM SERVICE - Room data to insert:\", {\n            ...roomData,\n            player_a_id: roomData.player_a_id.slice(-8)\n        });\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").insert([\n            roomData\n        ]).select().single();\n        if (error) {\n            console.error(\"❌ ROOM SERVICE - Error creating room:\", error);\n            throw new Error(\"Failed to create room: \".concat(error.message));\n        }\n        console.log(\"✅ ROOM SERVICE - Room created successfully\");\n        return {\n            room: data,\n            playerRole: \"player_a\"\n        };\n    },\n    // Join an existing room with proper error handling\n    async joinRoom (roomId, userId) {\n        try {\n            var _currentRoom_player_a_id, _currentRoom_player_b_id;\n            // Use provided userId or get current user ID or use session ID\n            let actualUserId = userId || await this.getUserId();\n            if (!actualUserId) {\n                actualUserId = this.getSessionId();\n                console.log(\"\\uD83C\\uDFAF ROOM SERVICE - Using session UUID for joiner:\", actualUserId.slice(-8));\n            }\n            console.log(\"\\uD83D\\uDEAA ROOM SERVICE - Join attempt:\", {\n                roomId: roomId.slice(-8),\n                userId: actualUserId.slice(-8)\n            });\n            // Validate UUID format\n            const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n            if (!uuidRegex.test(actualUserId)) {\n                console.error(\"❌ ROOM SERVICE - Invalid UUID format:\", actualUserId);\n                // Generate a new proper UUID\n                actualUserId = generateUUID();\n                console.log(\"\\uD83C\\uDD95 ROOM SERVICE - Generated new UUID:\", actualUserId.slice(-8));\n            }\n            // First, check if the room exists and get its current state\n            const { data: currentRoom, error: fetchError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").select(\"*\").eq(\"id\", roomId).single();\n            if (fetchError) {\n                console.error(\"❌ ROOM SERVICE - Error fetching room:\", fetchError);\n                if (fetchError.code === \"PGRST116\") {\n                    throw new Error(\"Room not found\");\n                }\n                throw new Error(\"Database error: \".concat(fetchError.message));\n            }\n            if (!currentRoom) {\n                throw new Error(\"Room not found\");\n            }\n            console.log(\"\\uD83C\\uDFE0 ROOM SERVICE - Current room state:\", {\n                id: currentRoom.id.slice(-8),\n                player_a_id: (_currentRoom_player_a_id = currentRoom.player_a_id) === null || _currentRoom_player_a_id === void 0 ? void 0 : _currentRoom_player_a_id.slice(-8),\n                player_b_id: (_currentRoom_player_b_id = currentRoom.player_b_id) === null || _currentRoom_player_b_id === void 0 ? void 0 : _currentRoom_player_b_id.slice(-8),\n                status: currentRoom.status\n            });\n            // Check if user is already in the room\n            if (currentRoom.player_a_id === actualUserId) {\n                console.log(\"✅ ROOM SERVICE - User already in room as Player A\");\n                return {\n                    room: currentRoom,\n                    playerRole: \"player_a\"\n                };\n            }\n            if (currentRoom.player_b_id === actualUserId) {\n                console.log(\"✅ ROOM SERVICE - User already in room as Player B\");\n                return {\n                    room: currentRoom,\n                    playerRole: \"player_b\"\n                };\n            }\n            // Check if room is full\n            if (currentRoom.player_a_id && currentRoom.player_b_id) {\n                throw new Error(\"Room is full\");\n            }\n            // Determine which slot to fill\n            let updateData;\n            let playerRole;\n            if (!currentRoom.player_a_id) {\n                updateData = {\n                    player_a_id: actualUserId,\n                    player_a_ready: false\n                };\n                playerRole = \"player_a\";\n                console.log(\"\\uD83C\\uDFAD ROOM SERVICE - Joining as Player A\");\n            } else {\n                updateData = {\n                    player_b_id: actualUserId,\n                    player_b_ready: false\n                };\n                playerRole = \"player_b\";\n                console.log(\"\\uD83C\\uDFAD ROOM SERVICE - Joining as Player B\");\n            }\n            // Update the room\n            const { data: updatedRoom, error: updateError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").update(updateData).eq(\"id\", roomId).select().single();\n            if (updateError) {\n                console.error(\"❌ ROOM SERVICE - Error updating room:\", updateError);\n                throw new Error(\"Failed to join room: \".concat(updateError.message));\n            }\n            if (!updatedRoom) {\n                throw new Error(\"Failed to update room - no data returned\");\n            }\n            console.log(\"✅ ROOM SERVICE - Successfully joined as:\", playerRole);\n            return {\n                room: updatedRoom,\n                playerRole\n            };\n        } catch (error) {\n            console.error(\"❌ ROOM SERVICE - Join room error:\", error);\n            throw error;\n        }\n    },\n    // Ready up for the game\n    async readyUp (roomId) {\n        try {\n            // Get user ID from role manager for consistency\n            let userId = await this.getUserId();\n            if (!userId) {\n                userId = this.getSessionId();\n            }\n            console.log(\"\\uD83D\\uDE80 ROOM SERVICE - Ready up with user:\", userId.slice(-8));\n            // Get current room state\n            const { data: room, error: fetchError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").select(\"*\").eq(\"id\", roomId).single();\n            if (fetchError || !room) {\n                console.error(\"❌ ROOM SERVICE - Error fetching room for ready up:\", fetchError);\n                throw new Error(\"Room not found\");\n            }\n            // Determine which player is ready-ing up\n            let updateData = {};\n            if (room.player_a_id === userId) {\n                updateData.player_a_ready = true;\n                console.log(\"\\uD83C\\uDD70️ ROOM SERVICE - Player A readying up\");\n            } else if (room.player_b_id === userId) {\n                updateData.player_b_ready = true;\n                console.log(\"\\uD83C\\uDD71️ ROOM SERVICE - Player B readying up\");\n            } else {\n                var _room_player_a_id, _room_player_b_id;\n                console.error(\"❌ ROOM SERVICE - User not found in room:\", {\n                    userId: userId.slice(-8),\n                    roomPlayerA: (_room_player_a_id = room.player_a_id) === null || _room_player_a_id === void 0 ? void 0 : _room_player_a_id.slice(-8),\n                    roomPlayerB: (_room_player_b_id = room.player_b_id) === null || _room_player_b_id === void 0 ? void 0 : _room_player_b_id.slice(-8)\n                });\n                throw new Error(\"You are not in this room\");\n            }\n            // Check if both players will be ready after this update\n            const bothReady = (room.player_a_id === userId ? true : room.player_a_ready) && (room.player_b_id === userId ? true : room.player_b_ready);\n            console.log(\"✅ ROOM SERVICE - Both players ready after update:\", bothReady);\n            // If both players are ready and present, start side selection\n            if (bothReady && room.player_a_id && room.player_b_id) {\n                // Start side selection phase instead of going straight to debating\n                const deadline = new Date(Date.now() + 10000) // 10 seconds from now\n                ;\n                updateData.status = \"side_selection\";\n                updateData.current_phase = \"side_selection\";\n                updateData.side_selection_deadline = deadline.toISOString();\n                updateData.phase_start_time = new Date().toISOString();\n                updateData.phase_duration = 10;\n                console.log(\"\\uD83C\\uDFAF ROOM SERVICE - Starting side selection phase\");\n            }\n            // Update the room\n            const { data, error: updateError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").update(updateData).eq(\"id\", roomId).select().single();\n            if (updateError) {\n                console.error(\"❌ ROOM SERVICE - Error readying up:\", updateError);\n                throw new Error(\"Failed to ready up: \".concat(updateError.message));\n            }\n            console.log(\"✅ ROOM SERVICE - Successfully readied up\");\n            return data;\n        } catch (error) {\n            console.error(\"❌ ROOM SERVICE - Ready up error:\", error);\n            throw error;\n        }\n    },\n    // Submit side vote\n    async submitSideVote (roomId, side) {\n        try {\n            let userId = await this.getUserId();\n            if (!userId) {\n                userId = this.getSessionId();\n            }\n            console.log(\"\\uD83D\\uDDF3️ ROOM SERVICE - Submitting vote:\", {\n                userId: userId.slice(-8),\n                side,\n                roomId: roomId.slice(-8)\n            });\n            // Get current room to determine player role\n            const { data: room, error: fetchError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").select(\"*\").eq(\"id\", roomId).single();\n            if (fetchError || !room) {\n                throw new Error(\"Room not found\");\n            }\n            let updateData = {};\n            if (room.player_a_id === userId) {\n                updateData.player_a_side_vote = side;\n                console.log(\"\\uD83C\\uDD70️ ROOM SERVICE - Player A voted for:\", side);\n            } else if (room.player_b_id === userId) {\n                updateData.player_b_side_vote = side;\n                console.log(\"\\uD83C\\uDD71️ ROOM SERVICE - Player B voted for:\", side);\n            } else {\n                var _room_player_a_id, _room_player_b_id;\n                console.error(\"❌ ROOM SERVICE - User not in room for voting:\", {\n                    userId: userId.slice(-8),\n                    roomPlayerA: (_room_player_a_id = room.player_a_id) === null || _room_player_a_id === void 0 ? void 0 : _room_player_a_id.slice(-8),\n                    roomPlayerB: (_room_player_b_id = room.player_b_id) === null || _room_player_b_id === void 0 ? void 0 : _room_player_b_id.slice(-8)\n                });\n                throw new Error(\"You are not in this room\");\n            }\n            // Update the room with the vote\n            const { data, error: updateError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").update(updateData).eq(\"id\", roomId).select().single();\n            if (updateError) {\n                console.error(\"❌ ROOM SERVICE - Error submitting vote:\", updateError);\n                throw new Error(\"Failed to submit vote: \".concat(updateError.message));\n            }\n            console.log(\"✅ ROOM SERVICE - Vote submitted successfully\");\n            return data;\n        } catch (error) {\n            console.error(\"❌ ROOM SERVICE - Submit side vote error:\", error);\n            throw error;\n        }\n    },\n    // Calculate final side assignments after voting period\n    async finalizeSideSelection (roomId) {\n        try {\n            const { data: room, error: fetchError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").select(\"*\").eq(\"id\", roomId).single();\n            if (fetchError || !room) {\n                throw new Error(\"Room not found\");\n            }\n            let playerASide;\n            let playerBSide;\n            console.log(\"\\uD83C\\uDFAF ROOM SERVICE - Finalizing side selection:\", {\n                playerAVote: room.player_a_side_vote,\n                playerBVote: room.player_b_side_vote\n            });\n            // Apply side assignment logic\n            if (room.player_a_side_vote && room.player_b_side_vote) {\n                if (room.player_a_side_vote === room.player_b_side_vote) {\n                    // Both chose same side - random assignment\n                    if (Math.random() > 0.5) {\n                        playerASide = \"pro\";\n                        playerBSide = \"con\";\n                    } else {\n                        playerASide = \"con\";\n                        playerBSide = \"pro\";\n                    }\n                    console.log(\"\\uD83C\\uDFB2 ROOM SERVICE - Random assignment (both chose same side)\");\n                } else {\n                    // Different sides - honor their choices\n                    playerASide = room.player_a_side_vote;\n                    playerBSide = room.player_b_side_vote;\n                    console.log(\"✅ ROOM SERVICE - Honored different choices\");\n                }\n            } else if (room.player_a_side_vote && !room.player_b_side_vote) {\n                // Only A voted - A gets choice, B gets opposite\n                playerASide = room.player_a_side_vote;\n                playerBSide = room.player_a_side_vote === \"pro\" ? \"con\" : \"pro\";\n                console.log(\"\\uD83C\\uDD70️ ROOM SERVICE - Only Player A voted\");\n            } else if (!room.player_a_side_vote && room.player_b_side_vote) {\n                // Only B voted - B gets choice, A gets opposite\n                playerBSide = room.player_b_side_vote;\n                playerASide = room.player_b_side_vote === \"pro\" ? \"con\" : \"pro\";\n                console.log(\"\\uD83C\\uDD71️ ROOM SERVICE - Only Player B voted\");\n            } else {\n                // Nobody voted - random assignment\n                if (Math.random() > 0.5) {\n                    playerASide = \"pro\";\n                    playerBSide = \"con\";\n                } else {\n                    playerASide = \"con\";\n                    playerBSide = \"pro\";\n                }\n                console.log(\"\\uD83C\\uDFB2 ROOM SERVICE - Random assignment (no votes)\");\n            }\n            console.log(\"\\uD83C\\uDFAF ROOM SERVICE - Final side assignments:\", {\n                playerASide,\n                playerBSide\n            });\n            // Update room with final assignments and move to opening prep phase\n            const { data, error: updateError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").update({\n                player_a_side: playerASide,\n                player_b_side: playerBSide,\n                current_phase: \"opening_prep\",\n                phase_start_time: new Date().toISOString(),\n                phase_duration: 30 // 30 seconds for opening prep\n            }).eq(\"id\", roomId).select().single();\n            if (updateError) {\n                console.error(\"❌ ROOM SERVICE - Error finalizing side selection:\", updateError);\n                throw new Error(\"Failed to finalize sides: \".concat(updateError.message));\n            }\n            console.log(\"✅ ROOM SERVICE - Side selection finalized\");\n            return data;\n        } catch (error) {\n            console.error(\"❌ ROOM SERVICE - Finalize side selection error:\", error);\n            throw error;\n        }\n    },\n    // Unready\n    async unready (roomId) {\n        try {\n            let userId = await this.getUserId();\n            if (!userId) {\n                userId = this.getSessionId();\n            }\n            const { data: room, error: fetchError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").select(\"*\").eq(\"id\", roomId).single();\n            if (fetchError || !room) {\n                throw new Error(\"Room not found\");\n            }\n            let updateData = {};\n            if (room.player_a_id === userId) {\n                updateData.player_a_ready = false;\n                console.log(\"\\uD83C\\uDD70️ ROOM SERVICE - Player A unreadying\");\n            } else if (room.player_b_id === userId) {\n                updateData.player_b_ready = false;\n                console.log(\"\\uD83C\\uDD71️ ROOM SERVICE - Player B unreadying\");\n            } else {\n                throw new Error(\"You are not in this room\");\n            }\n            // Reset to waiting status\n            updateData.status = \"waiting\";\n            updateData.current_phase = null;\n            const { data, error: updateError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").update(updateData).eq(\"id\", roomId).select().single();\n            if (updateError) {\n                console.error(\"❌ ROOM SERVICE - Error unreadying:\", updateError);\n                throw new Error(\"Failed to unready: \".concat(updateError.message));\n            }\n            console.log(\"✅ ROOM SERVICE - Successfully unreadied\");\n            return data;\n        } catch (error) {\n            console.error(\"❌ ROOM SERVICE - Unready error:\", error);\n            throw error;\n        }\n    },\n    // Leave room\n    async leaveRoom (roomId) {\n        try {\n            let userId = await this.getUserId();\n            if (!userId) {\n                userId = this.getSessionId();\n            }\n            console.log(\"\\uD83D\\uDEAA ROOM SERVICE - Leaving room:\", {\n                roomId: roomId.slice(-8),\n                userId: userId.slice(-8)\n            });\n            const { data: room, error: fetchError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").select(\"*\").eq(\"id\", roomId).single();\n            if (fetchError || !room) {\n                throw new Error(\"Room not found\");\n            }\n            let updateData = {};\n            if (room.player_a_id === userId) {\n                updateData.player_a_id = null;\n                updateData.player_a_ready = false;\n                updateData.player_a_side_vote = null;\n                updateData.player_a_side = null;\n                console.log(\"\\uD83C\\uDD70️ ROOM SERVICE - Player A leaving\");\n            } else if (room.player_b_id === userId) {\n                updateData.player_b_id = null;\n                updateData.player_b_ready = false;\n                updateData.player_b_side_vote = null;\n                updateData.player_b_side = null;\n                console.log(\"\\uD83C\\uDD71️ ROOM SERVICE - Player B leaving\");\n            } else {\n                throw new Error(\"You are not in this room\");\n            }\n            // Reset room status to waiting\n            updateData.status = \"waiting\";\n            updateData.current_phase = null;\n            const { error: updateError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").update(updateData).eq(\"id\", roomId);\n            if (updateError) {\n                console.error(\"❌ ROOM SERVICE - Error leaving room:\", updateError);\n                throw new Error(\"Failed to leave room: \".concat(updateError.message));\n            }\n            console.log(\"✅ ROOM SERVICE - Successfully left room\");\n            return true;\n        } catch (error) {\n            console.error(\"❌ ROOM SERVICE - Leave room error:\", error);\n            throw error;\n        }\n    },\n    // Get room details\n    async getRoom (roomId) {\n        try {\n            const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").select(\"*\").eq(\"id\", roomId).single();\n            if (error) {\n                if (error.code === \"PGRST116\") {\n                    return null // Room not found\n                    ;\n                }\n                console.error(\"❌ ROOM SERVICE - Error fetching room:\", error);\n                throw error;\n            }\n            return data;\n        } catch (error) {\n            console.error(\"❌ ROOM SERVICE - Get room error:\", error);\n            return null;\n        }\n    },\n    // Start opening prep phase\n    async startOpeningPrep (roomId) {\n        try {\n            console.log(\"\\uD83D\\uDCDD ROOM SERVICE - Starting opening prep phase for room:\", roomId.slice(-8));\n            const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").update({\n                current_phase: \"opening_prep\",\n                phase_start_time: new Date().toISOString(),\n                phase_duration: 30 // 30 seconds for prep\n            }).eq(\"id\", roomId).select().single();\n            if (error) {\n                console.error(\"❌ ROOM SERVICE - Error starting opening prep:\", error);\n                throw new Error(\"Failed to start opening prep: \".concat(error.message));\n            }\n            console.log(\"✅ ROOM SERVICE - Opening prep started successfully\");\n            return data;\n        } catch (error) {\n            console.error(\"❌ ROOM SERVICE - Start opening prep error:\", error);\n            throw error;\n        }\n    },\n    // Start opening statements phase\n    async startOpeningStatements (roomId) {\n        try {\n            console.log(\"\\uD83C\\uDFA4 ROOM SERVICE - Starting opening statements for room:\", roomId.slice(-8));\n            const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").update({\n                current_phase: \"opening\",\n                phase_start_time: new Date().toISOString(),\n                phase_duration: 70 // 30s + 10s transition + 30s\n            }).eq(\"id\", roomId).select().single();\n            if (error) {\n                console.error(\"❌ ROOM SERVICE - Error starting opening statements:\", error);\n                throw new Error(\"Failed to start opening statements: \".concat(error.message));\n            }\n            console.log(\"✅ ROOM SERVICE - Opening statements started successfully\");\n            return data;\n        } catch (error) {\n            console.error(\"❌ ROOM SERVICE - Start opening statements error:\", error);\n            throw error;\n        }\n    },\n    // Start game with side selection\n    async startGameWithSideSelection (roomId) {\n        try {\n            console.log(\"\\uD83C\\uDFAE ROOM SERVICE - Starting game with side selection for room:\", roomId.slice(-8));\n            const deadline = new Date(Date.now() + 10000) // 10 seconds from now\n            ;\n            const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").update({\n                status: \"debating\",\n                current_phase: \"side_selection\",\n                side_selection_deadline: deadline.toISOString(),\n                phase_start_time: new Date().toISOString(),\n                phase_duration: 10 // 10 seconds for side selection\n            }).eq(\"id\", roomId).select().single();\n            if (error) {\n                console.error(\"❌ ROOM SERVICE - Error starting game with side selection:\", error);\n                throw new Error(\"Failed to start game: \".concat(error.message));\n            }\n            console.log(\"✅ ROOM SERVICE - Game started with side selection successfully\");\n            return data;\n        } catch (error) {\n            console.error(\"❌ ROOM SERVICE - Start game with side selection error:\", error);\n            throw error;\n        }\n    },\n    // Enhanced subscription with better error handling\n    subscribeToRoom (roomId, callback) {\n        console.log(\"\\uD83D\\uDCE1 ROOM SERVICE - Setting up subscription for room:\", roomId.slice(-8));\n        const channel = _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.channel(\"room:\".concat(roomId, \":\").concat(Date.now())).on(\"postgres_changes\", {\n            event: \"*\",\n            schema: \"public\",\n            table: \"rooms\",\n            filter: \"id=eq.\".concat(roomId)\n        }, (payload)=>{\n            console.log(\"\\uD83D\\uDD04 ROOM SERVICE - Real-time update received:\", {\n                event: payload.eventType,\n                new: payload.new ? {\n                    id: payload.new.id.slice(-8),\n                    player_a_id: payload.new.player_a_id ? payload.new.player_a_id.slice(-8) : null,\n                    player_b_id: payload.new.player_b_id ? payload.new.player_b_id.slice(-8) : null,\n                    status: payload.new.status,\n                    current_phase: payload.new.current_phase\n                } : null\n            });\n            if (payload.new) {\n                callback(payload.new);\n            }\n        }).subscribe((status, error)=>{\n            console.log(\"\\uD83D\\uDCE1 ROOM SERVICE - Subscription status:\", status);\n            if (error) {\n                console.error(\"❌ ROOM SERVICE - Subscription error:\", error);\n            }\n            if (status === \"SUBSCRIBED\") {\n                console.log(\"✅ ROOM SERVICE - Successfully subscribed to room updates\");\n            }\n        });\n        return channel;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvcm9vbVNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFDO0FBRU07QUFFM0Msb0NBQW9DO0FBQ3BDLE1BQU1FLGdCQUFnQjtJQUNwQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsK0NBQStDO0FBQy9DLFNBQVNDO0lBQ1AsdURBQXVEO0lBQ3ZELElBQUksT0FBT0MsV0FBVyxlQUFlQSxPQUFPQyxVQUFVLEVBQUU7UUFDdEQsT0FBT0QsT0FBT0MsVUFBVTtJQUMxQjtJQUVBLGdDQUFnQztJQUNoQyxPQUFPLHVDQUF1Q0MsT0FBTyxDQUFDLFNBQVMsU0FBU0MsQ0FBQztRQUN2RSxNQUFNQyxJQUFJLEtBQU1FLE1BQU0sS0FBSyxLQUFNO1FBQ2pDLE1BQU1DLElBQUlKLE1BQU0sTUFBTUMsSUFBSSxJQUFLLE1BQU87UUFDdEMsT0FBT0csRUFBRUMsUUFBUSxDQUFDO0lBQ3BCO0FBQ0Y7QUFFTyxNQUFNQyxjQUFjO0lBQ3pCLHlDQUF5QztJQUN6QyxNQUFNQztRQUNKLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNaEIsK0NBQVFBLENBQUNpQixJQUFJLENBQUNDLE9BQU87UUFDbkQsSUFBSUYsU0FBUyxFQUFDRCxpQkFBQUEsMkJBQUFBLEtBQU1JLElBQUksR0FBRTtZQUN4QixPQUFPO1FBQ1Q7UUFDQSxPQUFPSixLQUFLSSxJQUFJLENBQUNDLEVBQUU7SUFDckI7SUFFQSx5REFBeUQ7SUFDekRDO1FBQ0UsT0FBT3BCLHFEQUFXQSxDQUFDb0IsWUFBWTtJQUNqQztJQUVBLG9CQUFvQjtJQUNwQixNQUFNQztRQUNKLElBQUlDLFNBQVMsTUFBTSxJQUFJLENBQUNULFNBQVM7UUFFakNVLFFBQVFDLEdBQUcsQ0FBQyx5REFBK0NGLG1CQUFBQSw2QkFBQUEsT0FBUUcsS0FBSyxDQUFDLENBQUM7UUFFMUUsd0RBQXdEO1FBQ3hE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QUFDLEtBQUs7b0JBQzNFNkIsYUFBYTBDLFFBQVFFLEdBQUcsQ0FBQzVDLFdBQVcsR0FBRzBDLFFBQVFFLEdBQUcsQ0FBQzVDLFdBQVcsQ0FBQzdCLEtBQUssQ0FBQyxDQUFDLEtBQUs7b0JBQzNFTSxRQUFRaUUsUUFBUUUsR0FBRyxDQUFDbkUsTUFBTTtvQkFDMUJtQyxlQUFlOEIsUUFBUUUsR0FBRyxDQUFDaEMsYUFBYTtnQkFDMUMsSUFBSTtZQUNOO1lBRUEsSUFBSThCLFFBQVFFLEdBQUcsRUFBRTtnQkFDZlQsU0FBU08sUUFBUUUsR0FBRztZQUN0QjtRQUNGLEdBRURDLFNBQVMsQ0FBQyxDQUFDcEUsUUFBZ0JoQjtZQUMxQlEsUUFBUUMsR0FBRyxDQUFDLG9EQUEwQ087WUFDdEQsSUFBSWhCLE9BQU87Z0JBQ1RRLFFBQVFSLEtBQUssQ0FBQyx3Q0FBd0NBO1lBQ3hEO1lBRUEsSUFBSWdCLFdBQVcsY0FBYztnQkFDM0JSLFFBQVFDLEdBQUcsQ0FBQztZQUNkO1FBQ0Y7UUFFRixPQUFPa0U7SUFDVDtBQUNGLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9yb29tU2VydmljZS50cz9iZTEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN1cGFiYXNlIH0gZnJvbSAnLi9zdXBhYmFzZSdcbmltcG9ydCB7IFJvb20gfSBmcm9tICcuL3N1cGFiYXNlJ1xuaW1wb3J0IHsgcm9sZU1hbmFnZXIgfSBmcm9tICcuL3JvbGVNYW5hZ2VyJ1xuXG4vLyBMaXN0IG9mIGRlYmF0ZSB0b3BpY3MgZm9yIHRoZSBNVlBcbmNvbnN0IERFQkFURV9UT1BJQ1MgPSBbXG4gIFwiU2hvdWxkIEFJIGJlIHJlZ3VsYXRlZD9cIixcbiAgXCJJcyBzb2NpYWwgbWVkaWEgaGFybWZ1bCB0byBkZW1vY3JhY3k/XCIsXG4gIFwiU2hvdWxkIGNvbGxlZ2UgZWR1Y2F0aW9uIGJlIGZyZWU/XCIsXG4gIFwiSXMgcmVtb3RlIHdvcmsgYmV0dGVyIHRoYW4gb2ZmaWNlIHdvcms/XCIsXG4gIFwiU2hvdWxkIHZvdGluZyBiZSBtYW5kYXRvcnk/XCIsXG4gIFwiSXMgY2xpbWF0ZSBjaGFuZ2UgdGhlIG1vc3QgdXJnZW50IGdsb2JhbCBpc3N1ZT9cIixcbiAgXCJTaG91bGQgdW5pdmVyc2FsIGJhc2ljIGluY29tZSBiZSBpbXBsZW1lbnRlZD9cIixcbiAgXCJJcyBzb2NpYWwgbWVkaWEgbW9yZSBoYXJtZnVsIHRoYW4gaGVscGZ1bD9cIixcbiAgXCJTaG91bGQgZ2VuZXRpYyBlbmdpbmVlcmluZyBiZSB3aWRlbHkgdXNlZD9cIixcbiAgXCJJcyBvbmxpbmUgbGVhcm5pbmcgYmV0dGVyIHRoYW4gdHJhZGl0aW9uYWwgY2xhc3Nyb29tIGVkdWNhdGlvbj9cIlxuXVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSBwcm9wZXIgVVVJRCB2NFxuZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKCk6IHN0cmluZyB7XG4gIC8vIFVzZSBjcnlwdG8ucmFuZG9tVVVJRCBpZiBhdmFpbGFibGUgKG1vZGVybiBicm93c2VycylcbiAgaWYgKHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5yYW5kb21VVUlEKSB7XG4gICAgcmV0dXJuIGNyeXB0by5yYW5kb21VVUlEKClcbiAgfVxuICBcbiAgLy8gRmFsbGJhY2sgdG8gbWFudWFsIGdlbmVyYXRpb25cbiAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24oYykge1xuICAgIGNvbnN0IHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2KSB8IDBcbiAgICBjb25zdCB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4OFxuICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KVxuICB9KVxufVxuXG5leHBvcnQgY29uc3Qgcm9vbVNlcnZpY2UgPSB7XG4gIC8vIEhlbHBlciB0byBnZXQgY3VycmVudCBTdXBhYmFzZSB1c2VyIElEXG4gIGFzeW5jIGdldFVzZXJJZCgpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKVxuICAgIGlmIChlcnJvciB8fCAhZGF0YT8udXNlcikge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmV0dXJuIGRhdGEudXNlci5pZFxuICB9LFxuXG4gIC8vIEdldCBzZXNzaW9uIElEIGZyb20gcm9sZSBtYW5hZ2VyIChlbnN1cmVzIGNvbnNpc3RlbmN5KVxuICBnZXRTZXNzaW9uSWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcm9sZU1hbmFnZXIuZ2V0U2Vzc2lvbklkKClcbiAgfSxcblxuICAvLyBDcmVhdGUgYSBuZXcgcm9vbVxuICBhc3luYyBjcmVhdGVSb29tKCk6IFByb21pc2U8eyByb29tOiBSb29tOyBwbGF5ZXJSb2xlOiAncGxheWVyX2EnIHwgJ3BsYXllcl9iJyB9PiB7XG4gICAgbGV0IHVzZXJJZCA9IGF3YWl0IHRoaXMuZ2V0VXNlcklkKClcbiAgICBcbiAgICBjb25zb2xlLmxvZygn8J+Pl++4jyBST09NIFNFUlZJQ0UgLSBDcmVhdGluZyByb29tIHdpdGggdXNlcjonLCB1c2VySWQ/LnNsaWNlKC04KSlcbiAgICBcbiAgICAvLyBJZiBubyBhdXRoZW50aWNhdGVkIHVzZXIsIHVzZSBzZXNzaW9uIFVVSUQgZm9yIGd1ZXN0c1xuICAgIGlmICghdXNlcklkKSB7XG4gICAgICB1c2VySWQgPSB0aGlzLmdldFNlc3Npb25JZCgpXG4gICAgICBjb25zb2xlLmxvZygn8J+OryBST09NIFNFUlZJQ0UgLSBVc2luZyBzZXNzaW9uIFVVSUQgZm9yIGNyZWF0b3I6JywgdXNlcklkLnNsaWNlKC04KSlcbiAgICB9XG4gICAgXG4gICAgY29uc3QgcmFuZG9tVG9waWMgPSBERUJBVEVfVE9QSUNTW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIERFQkFURV9UT1BJQ1MubGVuZ3RoKV1cblxuICAgIGNvbnN0IHJvb21EYXRhID0ge1xuICAgICAgdG9waWM6IHJhbmRvbVRvcGljLFxuICAgICAgc3RhdHVzOiAnd2FpdGluZycgYXMgY29uc3QsXG4gICAgICBwbGF5ZXJfYV9oZWFsdGg6IDEwMCxcbiAgICAgIHBsYXllcl9iX2hlYWx0aDogMTAwLFxuICAgICAgcGxheWVyX2FfcmVhZHk6IGZhbHNlLFxuICAgICAgcGxheWVyX2JfcmVhZHk6IGZhbHNlLFxuICAgICAgcGxheWVyX2FfaWQ6IHVzZXJJZCxcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coJ/Cfj5fvuI8gUk9PTSBTRVJWSUNFIC0gUm9vbSBkYXRhIHRvIGluc2VydDonLCB7XG4gICAgICAuLi5yb29tRGF0YSxcbiAgICAgIHBsYXllcl9hX2lkOiByb29tRGF0YS5wbGF5ZXJfYV9pZC5zbGljZSgtOClcbiAgICB9KVxuXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdyb29tcycpXG4gICAgICAuaW5zZXJ0KFtyb29tRGF0YV0pXG4gICAgICAuc2VsZWN0KClcbiAgICAgIC5zaW5nbGUoKVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgUk9PTSBTRVJWSUNFIC0gRXJyb3IgY3JlYXRpbmcgcm9vbTonLCBlcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSByb29tOiAke2Vycm9yLm1lc3NhZ2V9YClcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygn4pyFIFJPT00gU0VSVklDRSAtIFJvb20gY3JlYXRlZCBzdWNjZXNzZnVsbHknKVxuICAgIHJldHVybiB7IHJvb206IGRhdGEsIHBsYXllclJvbGU6ICdwbGF5ZXJfYScgfVxuICB9LFxuXG4gIC8vIEpvaW4gYW4gZXhpc3Rpbmcgcm9vbSB3aXRoIHByb3BlciBlcnJvciBoYW5kbGluZ1xuICBhc3luYyBqb2luUm9vbShyb29tSWQ6IHN0cmluZywgdXNlcklkPzogc3RyaW5nKTogUHJvbWlzZTx7IHJvb206IFJvb207IHBsYXllclJvbGU6ICdwbGF5ZXJfYScgfCAncGxheWVyX2InIH0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gVXNlIHByb3ZpZGVkIHVzZXJJZCBvciBnZXQgY3VycmVudCB1c2VyIElEIG9yIHVzZSBzZXNzaW9uIElEXG4gICAgICBsZXQgYWN0dWFsVXNlcklkID0gdXNlcklkIHx8IGF3YWl0IHRoaXMuZ2V0VXNlcklkKClcbiAgICAgIGlmICghYWN0dWFsVXNlcklkKSB7XG4gICAgICAgIGFjdHVhbFVzZXJJZCA9IHRoaXMuZ2V0U2Vzc2lvbklkKClcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfjq8gUk9PTSBTRVJWSUNFIC0gVXNpbmcgc2Vzc2lvbiBVVUlEIGZvciBqb2luZXI6JywgYWN0dWFsVXNlcklkLnNsaWNlKC04KSlcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ/CfmqogUk9PTSBTRVJWSUNFIC0gSm9pbiBhdHRlbXB0OicsIHtcbiAgICAgICAgcm9vbUlkOiByb29tSWQuc2xpY2UoLTgpLFxuICAgICAgICB1c2VySWQ6IGFjdHVhbFVzZXJJZC5zbGljZSgtOClcbiAgICAgIH0pXG5cbiAgICAgIC8vIFZhbGlkYXRlIFVVSUQgZm9ybWF0XG4gICAgICBjb25zdCB1dWlkUmVnZXggPSAvXlswLTlhLWZdezh9LVswLTlhLWZdezR9LTRbMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn0kL2lcbiAgICAgIGlmICghdXVpZFJlZ2V4LnRlc3QoYWN0dWFsVXNlcklkKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgUk9PTSBTRVJWSUNFIC0gSW52YWxpZCBVVUlEIGZvcm1hdDonLCBhY3R1YWxVc2VySWQpXG4gICAgICAgIC8vIEdlbmVyYXRlIGEgbmV3IHByb3BlciBVVUlEXG4gICAgICAgIGFjdHVhbFVzZXJJZCA9IGdlbmVyYXRlVVVJRCgpXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn4aVIFJPT00gU0VSVklDRSAtIEdlbmVyYXRlZCBuZXcgVVVJRDonLCBhY3R1YWxVc2VySWQuc2xpY2UoLTgpKVxuICAgICAgfVxuXG4gICAgICAvLyBGaXJzdCwgY2hlY2sgaWYgdGhlIHJvb20gZXhpc3RzIGFuZCBnZXQgaXRzIGN1cnJlbnQgc3RhdGVcbiAgICAgIGNvbnN0IHsgZGF0YTogY3VycmVudFJvb20sIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncm9vbXMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCdpZCcsIHJvb21JZClcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIGlmIChmZXRjaEVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBST09NIFNFUlZJQ0UgLSBFcnJvciBmZXRjaGluZyByb29tOicsIGZldGNoRXJyb3IpXG4gICAgICAgIGlmIChmZXRjaEVycm9yLmNvZGUgPT09ICdQR1JTVDExNicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jvb20gbm90IGZvdW5kJylcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGFiYXNlIGVycm9yOiAke2ZldGNoRXJyb3IubWVzc2FnZX1gKVxuICAgICAgfVxuXG4gICAgICBpZiAoIWN1cnJlbnRSb29tKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUm9vbSBub3QgZm91bmQnKVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygn8J+PoCBST09NIFNFUlZJQ0UgLSBDdXJyZW50IHJvb20gc3RhdGU6Jywge1xuICAgICAgICBpZDogY3VycmVudFJvb20uaWQuc2xpY2UoLTgpLFxuICAgICAgICBwbGF5ZXJfYV9pZDogY3VycmVudFJvb20ucGxheWVyX2FfaWQ/LnNsaWNlKC04KSxcbiAgICAgICAgcGxheWVyX2JfaWQ6IGN1cnJlbnRSb29tLnBsYXllcl9iX2lkPy5zbGljZSgtOCksXG4gICAgICAgIHN0YXR1czogY3VycmVudFJvb20uc3RhdHVzXG4gICAgICB9KVxuXG4gICAgICAvLyBDaGVjayBpZiB1c2VyIGlzIGFscmVhZHkgaW4gdGhlIHJvb21cbiAgICAgIGlmIChjdXJyZW50Um9vbS5wbGF5ZXJfYV9pZCA9PT0gYWN0dWFsVXNlcklkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgUk9PTSBTRVJWSUNFIC0gVXNlciBhbHJlYWR5IGluIHJvb20gYXMgUGxheWVyIEEnKVxuICAgICAgICByZXR1cm4geyByb29tOiBjdXJyZW50Um9vbSwgcGxheWVyUm9sZTogJ3BsYXllcl9hJyB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChjdXJyZW50Um9vbS5wbGF5ZXJfYl9pZCA9PT0gYWN0dWFsVXNlcklkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgUk9PTSBTRVJWSUNFIC0gVXNlciBhbHJlYWR5IGluIHJvb20gYXMgUGxheWVyIEInKVxuICAgICAgICByZXR1cm4geyByb29tOiBjdXJyZW50Um9vbSwgcGxheWVyUm9sZTogJ3BsYXllcl9iJyB9XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHJvb20gaXMgZnVsbFxuICAgICAgaWYgKGN1cnJlbnRSb29tLnBsYXllcl9hX2lkICYmIGN1cnJlbnRSb29tLnBsYXllcl9iX2lkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUm9vbSBpcyBmdWxsJylcbiAgICAgIH1cblxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIHNsb3QgdG8gZmlsbFxuICAgICAgbGV0IHVwZGF0ZURhdGE6IGFueVxuICAgICAgbGV0IHBsYXllclJvbGU6ICdwbGF5ZXJfYScgfCAncGxheWVyX2InXG5cbiAgICAgIGlmICghY3VycmVudFJvb20ucGxheWVyX2FfaWQpIHtcbiAgICAgICAgdXBkYXRlRGF0YSA9IHsgXG4gICAgICAgICAgcGxheWVyX2FfaWQ6IGFjdHVhbFVzZXJJZCxcbiAgICAgICAgICBwbGF5ZXJfYV9yZWFkeTogZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBwbGF5ZXJSb2xlID0gJ3BsYXllcl9hJ1xuICAgICAgICBjb25zb2xlLmxvZygn8J+OrSBST09NIFNFUlZJQ0UgLSBKb2luaW5nIGFzIFBsYXllciBBJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZURhdGEgPSB7IFxuICAgICAgICAgIHBsYXllcl9iX2lkOiBhY3R1YWxVc2VySWQsXG4gICAgICAgICAgcGxheWVyX2JfcmVhZHk6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgcGxheWVyUm9sZSA9ICdwbGF5ZXJfYidcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfjq0gUk9PTSBTRVJWSUNFIC0gSm9pbmluZyBhcyBQbGF5ZXIgQicpXG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgcm9vbVxuICAgICAgY29uc3QgeyBkYXRhOiB1cGRhdGVkUm9vbSwgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncm9vbXMnKVxuICAgICAgICAudXBkYXRlKHVwZGF0ZURhdGEpXG4gICAgICAgIC5lcSgnaWQnLCByb29tSWQpXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgaWYgKHVwZGF0ZUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBST09NIFNFUlZJQ0UgLSBFcnJvciB1cGRhdGluZyByb29tOicsIHVwZGF0ZUVycm9yKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBqb2luIHJvb206ICR7dXBkYXRlRXJyb3IubWVzc2FnZX1gKVxuICAgICAgfVxuXG4gICAgICBpZiAoIXVwZGF0ZWRSb29tKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVwZGF0ZSByb29tIC0gbm8gZGF0YSByZXR1cm5lZCcpXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCfinIUgUk9PTSBTRVJWSUNFIC0gU3VjY2Vzc2Z1bGx5IGpvaW5lZCBhczonLCBwbGF5ZXJSb2xlKVxuICAgICAgcmV0dXJuIHsgcm9vbTogdXBkYXRlZFJvb20sIHBsYXllclJvbGUgfVxuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBST09NIFNFUlZJQ0UgLSBKb2luIHJvb20gZXJyb3I6JywgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfSxcblxuICAvLyBSZWFkeSB1cCBmb3IgdGhlIGdhbWVcbiAgYXN5bmMgcmVhZHlVcChyb29tSWQ6IHN0cmluZyk6IFByb21pc2U8Um9vbSB8IG51bGw+IHtcbiAgICB0cnkge1xuICAgICAgLy8gR2V0IHVzZXIgSUQgZnJvbSByb2xlIG1hbmFnZXIgZm9yIGNvbnNpc3RlbmN5XG4gICAgICBsZXQgdXNlcklkID0gYXdhaXQgdGhpcy5nZXRVc2VySWQoKVxuICAgICAgaWYgKCF1c2VySWQpIHtcbiAgICAgICAgdXNlcklkID0gdGhpcy5nZXRTZXNzaW9uSWQoKVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn8J+agCBST09NIFNFUlZJQ0UgLSBSZWFkeSB1cCB3aXRoIHVzZXI6JywgdXNlcklkLnNsaWNlKC04KSlcbiAgICAgIFxuICAgICAgLy8gR2V0IGN1cnJlbnQgcm9vbSBzdGF0ZVxuICAgICAgY29uc3QgeyBkYXRhOiByb29tLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Jvb21zJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5lcSgnaWQnLCByb29tSWQpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBpZiAoZmV0Y2hFcnJvciB8fCAhcm9vbSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgUk9PTSBTRVJWSUNFIC0gRXJyb3IgZmV0Y2hpbmcgcm9vbSBmb3IgcmVhZHkgdXA6JywgZmV0Y2hFcnJvcilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSb29tIG5vdCBmb3VuZCcpXG4gICAgICB9XG5cbiAgICAgIC8vIERldGVybWluZSB3aGljaCBwbGF5ZXIgaXMgcmVhZHktaW5nIHVwXG4gICAgICBsZXQgdXBkYXRlRGF0YTogYW55ID0ge31cbiAgICAgIFxuICAgICAgaWYgKHJvb20ucGxheWVyX2FfaWQgPT09IHVzZXJJZCkge1xuICAgICAgICB1cGRhdGVEYXRhLnBsYXllcl9hX3JlYWR5ID0gdHJ1ZVxuICAgICAgICBjb25zb2xlLmxvZygn8J+FsO+4jyBST09NIFNFUlZJQ0UgLSBQbGF5ZXIgQSByZWFkeWluZyB1cCcpXG4gICAgICB9IGVsc2UgaWYgKHJvb20ucGxheWVyX2JfaWQgPT09IHVzZXJJZCkge1xuICAgICAgICB1cGRhdGVEYXRhLnBsYXllcl9iX3JlYWR5ID0gdHJ1ZVxuICAgICAgICBjb25zb2xlLmxvZygn8J+Fse+4jyBST09NIFNFUlZJQ0UgLSBQbGF5ZXIgQiByZWFkeWluZyB1cCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgUk9PTSBTRVJWSUNFIC0gVXNlciBub3QgZm91bmQgaW4gcm9vbTonLCB7XG4gICAgICAgICAgdXNlcklkOiB1c2VySWQuc2xpY2UoLTgpLFxuICAgICAgICAgIHJvb21QbGF5ZXJBOiByb29tLnBsYXllcl9hX2lkPy5zbGljZSgtOCksXG4gICAgICAgICAgcm9vbVBsYXllckI6IHJvb20ucGxheWVyX2JfaWQ/LnNsaWNlKC04KVxuICAgICAgICB9KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhcmUgbm90IGluIHRoaXMgcm9vbScpXG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIGJvdGggcGxheWVycyB3aWxsIGJlIHJlYWR5IGFmdGVyIHRoaXMgdXBkYXRlXG4gICAgICBjb25zdCBib3RoUmVhZHkgPSAocm9vbS5wbGF5ZXJfYV9pZCA9PT0gdXNlcklkID8gdHJ1ZSA6IHJvb20ucGxheWVyX2FfcmVhZHkpICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAocm9vbS5wbGF5ZXJfYl9pZCA9PT0gdXNlcklkID8gdHJ1ZSA6IHJvb20ucGxheWVyX2JfcmVhZHkpXG5cbiAgICAgIGNvbnNvbGUubG9nKCfinIUgUk9PTSBTRVJWSUNFIC0gQm90aCBwbGF5ZXJzIHJlYWR5IGFmdGVyIHVwZGF0ZTonLCBib3RoUmVhZHkpXG5cbiAgICAgIC8vIElmIGJvdGggcGxheWVycyBhcmUgcmVhZHkgYW5kIHByZXNlbnQsIHN0YXJ0IHNpZGUgc2VsZWN0aW9uXG4gICAgICBpZiAoYm90aFJlYWR5ICYmIHJvb20ucGxheWVyX2FfaWQgJiYgcm9vbS5wbGF5ZXJfYl9pZCkge1xuICAgICAgICAvLyBTdGFydCBzaWRlIHNlbGVjdGlvbiBwaGFzZSBpbnN0ZWFkIG9mIGdvaW5nIHN0cmFpZ2h0IHRvIGRlYmF0aW5nXG4gICAgICAgIGNvbnN0IGRlYWRsaW5lID0gbmV3IERhdGUoRGF0ZS5ub3coKSArIDEwMDAwKSAvLyAxMCBzZWNvbmRzIGZyb20gbm93XG4gICAgICAgIHVwZGF0ZURhdGEuc3RhdHVzID0gJ3NpZGVfc2VsZWN0aW9uJ1xuICAgICAgICB1cGRhdGVEYXRhLmN1cnJlbnRfcGhhc2UgPSAnc2lkZV9zZWxlY3Rpb24nXG4gICAgICAgIHVwZGF0ZURhdGEuc2lkZV9zZWxlY3Rpb25fZGVhZGxpbmUgPSBkZWFkbGluZS50b0lTT1N0cmluZygpXG4gICAgICAgIHVwZGF0ZURhdGEucGhhc2Vfc3RhcnRfdGltZSA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB1cGRhdGVEYXRhLnBoYXNlX2R1cmF0aW9uID0gMTBcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfjq8gUk9PTSBTRVJWSUNFIC0gU3RhcnRpbmcgc2lkZSBzZWxlY3Rpb24gcGhhc2UnKVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgdGhlIHJvb21cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncm9vbXMnKVxuICAgICAgICAudXBkYXRlKHVwZGF0ZURhdGEpXG4gICAgICAgIC5lcSgnaWQnLCByb29tSWQpXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgaWYgKHVwZGF0ZUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBST09NIFNFUlZJQ0UgLSBFcnJvciByZWFkeWluZyB1cDonLCB1cGRhdGVFcnJvcilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcmVhZHkgdXA6ICR7dXBkYXRlRXJyb3IubWVzc2FnZX1gKVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFJPT00gU0VSVklDRSAtIFN1Y2Nlc3NmdWxseSByZWFkaWVkIHVwJylcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBST09NIFNFUlZJQ0UgLSBSZWFkeSB1cCBlcnJvcjonLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9LFxuXG4gIC8vIFN1Ym1pdCBzaWRlIHZvdGVcbiAgYXN5bmMgc3VibWl0U2lkZVZvdGUocm9vbUlkOiBzdHJpbmcsIHNpZGU6ICdwcm8nIHwgJ2NvbicpOiBQcm9taXNlPFJvb20gfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCB1c2VySWQgPSBhd2FpdCB0aGlzLmdldFVzZXJJZCgpXG4gICAgICBpZiAoIXVzZXJJZCkge1xuICAgICAgICB1c2VySWQgPSB0aGlzLmdldFNlc3Npb25JZCgpXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn5ez77iPIFJPT00gU0VSVklDRSAtIFN1Ym1pdHRpbmcgdm90ZTonLCB7XG4gICAgICAgIHVzZXJJZDogdXNlcklkLnNsaWNlKC04KSxcbiAgICAgICAgc2lkZSxcbiAgICAgICAgcm9vbUlkOiByb29tSWQuc2xpY2UoLTgpXG4gICAgICB9KVxuXG4gICAgICAvLyBHZXQgY3VycmVudCByb29tIHRvIGRldGVybWluZSBwbGF5ZXIgcm9sZVxuICAgICAgY29uc3QgeyBkYXRhOiByb29tLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Jvb21zJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5lcSgnaWQnLCByb29tSWQpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBpZiAoZmV0Y2hFcnJvciB8fCAhcm9vbSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jvb20gbm90IGZvdW5kJylcbiAgICAgIH1cblxuICAgICAgbGV0IHVwZGF0ZURhdGE6IGFueSA9IHt9XG4gICAgICBcbiAgICAgIGlmIChyb29tLnBsYXllcl9hX2lkID09PSB1c2VySWQpIHtcbiAgICAgICAgdXBkYXRlRGF0YS5wbGF5ZXJfYV9zaWRlX3ZvdGUgPSBzaWRlXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn4Ww77iPIFJPT00gU0VSVklDRSAtIFBsYXllciBBIHZvdGVkIGZvcjonLCBzaWRlKVxuICAgICAgfSBlbHNlIGlmIChyb29tLnBsYXllcl9iX2lkID09PSB1c2VySWQpIHtcbiAgICAgICAgdXBkYXRlRGF0YS5wbGF5ZXJfYl9zaWRlX3ZvdGUgPSBzaWRlXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn4Wx77iPIFJPT00gU0VSVklDRSAtIFBsYXllciBCIHZvdGVkIGZvcjonLCBzaWRlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFJPT00gU0VSVklDRSAtIFVzZXIgbm90IGluIHJvb20gZm9yIHZvdGluZzonLCB7XG4gICAgICAgICAgdXNlcklkOiB1c2VySWQuc2xpY2UoLTgpLFxuICAgICAgICAgIHJvb21QbGF5ZXJBOiByb29tLnBsYXllcl9hX2lkPy5zbGljZSgtOCksXG4gICAgICAgICAgcm9vbVBsYXllckI6IHJvb20ucGxheWVyX2JfaWQ/LnNsaWNlKC04KVxuICAgICAgICB9KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhcmUgbm90IGluIHRoaXMgcm9vbScpXG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgcm9vbSB3aXRoIHRoZSB2b3RlXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Jvb21zJylcbiAgICAgICAgLnVwZGF0ZSh1cGRhdGVEYXRhKVxuICAgICAgICAuZXEoJ2lkJywgcm9vbUlkKVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIGlmICh1cGRhdGVFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgUk9PTSBTRVJWSUNFIC0gRXJyb3Igc3VibWl0dGluZyB2b3RlOicsIHVwZGF0ZUVycm9yKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzdWJtaXQgdm90ZTogJHt1cGRhdGVFcnJvci5tZXNzYWdlfWApXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCfinIUgUk9PTSBTRVJWSUNFIC0gVm90ZSBzdWJtaXR0ZWQgc3VjY2Vzc2Z1bGx5JylcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBST09NIFNFUlZJQ0UgLSBTdWJtaXQgc2lkZSB2b3RlIGVycm9yOicsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH0sXG5cbiAgLy8gQ2FsY3VsYXRlIGZpbmFsIHNpZGUgYXNzaWdubWVudHMgYWZ0ZXIgdm90aW5nIHBlcmlvZFxuICBhc3luYyBmaW5hbGl6ZVNpZGVTZWxlY3Rpb24ocm9vbUlkOiBzdHJpbmcpOiBQcm9taXNlPFJvb20gfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YTogcm9vbSwgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdyb29tcycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAuZXEoJ2lkJywgcm9vbUlkKVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgaWYgKGZldGNoRXJyb3IgfHwgIXJvb20pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSb29tIG5vdCBmb3VuZCcpXG4gICAgICB9XG5cbiAgICAgIGxldCBwbGF5ZXJBU2lkZTogJ3BybycgfCAnY29uJ1xuICAgICAgbGV0IHBsYXllckJTaWRlOiAncHJvJyB8ICdjb24nXG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn46vIFJPT00gU0VSVklDRSAtIEZpbmFsaXppbmcgc2lkZSBzZWxlY3Rpb246Jywge1xuICAgICAgICBwbGF5ZXJBVm90ZTogcm9vbS5wbGF5ZXJfYV9zaWRlX3ZvdGUsXG4gICAgICAgIHBsYXllckJWb3RlOiByb29tLnBsYXllcl9iX3NpZGVfdm90ZVxuICAgICAgfSlcblxuICAgICAgLy8gQXBwbHkgc2lkZSBhc3NpZ25tZW50IGxvZ2ljXG4gICAgICBpZiAocm9vbS5wbGF5ZXJfYV9zaWRlX3ZvdGUgJiYgcm9vbS5wbGF5ZXJfYl9zaWRlX3ZvdGUpIHtcbiAgICAgICAgaWYgKHJvb20ucGxheWVyX2Ffc2lkZV92b3RlID09PSByb29tLnBsYXllcl9iX3NpZGVfdm90ZSkge1xuICAgICAgICAgIC8vIEJvdGggY2hvc2Ugc2FtZSBzaWRlIC0gcmFuZG9tIGFzc2lnbm1lbnRcbiAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAgICAgICAgcGxheWVyQVNpZGUgPSAncHJvJ1xuICAgICAgICAgICAgcGxheWVyQlNpZGUgPSAnY29uJ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwbGF5ZXJBU2lkZSA9ICdjb24nXG4gICAgICAgICAgICBwbGF5ZXJCU2lkZSA9ICdwcm8nXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn46yIFJPT00gU0VSVklDRSAtIFJhbmRvbSBhc3NpZ25tZW50IChib3RoIGNob3NlIHNhbWUgc2lkZSknKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERpZmZlcmVudCBzaWRlcyAtIGhvbm9yIHRoZWlyIGNob2ljZXNcbiAgICAgICAgICBwbGF5ZXJBU2lkZSA9IHJvb20ucGxheWVyX2Ffc2lkZV92b3RlXG4gICAgICAgICAgcGxheWVyQlNpZGUgPSByb29tLnBsYXllcl9iX3NpZGVfdm90ZVxuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgUk9PTSBTRVJWSUNFIC0gSG9ub3JlZCBkaWZmZXJlbnQgY2hvaWNlcycpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocm9vbS5wbGF5ZXJfYV9zaWRlX3ZvdGUgJiYgIXJvb20ucGxheWVyX2Jfc2lkZV92b3RlKSB7XG4gICAgICAgIC8vIE9ubHkgQSB2b3RlZCAtIEEgZ2V0cyBjaG9pY2UsIEIgZ2V0cyBvcHBvc2l0ZVxuICAgICAgICBwbGF5ZXJBU2lkZSA9IHJvb20ucGxheWVyX2Ffc2lkZV92b3RlXG4gICAgICAgIHBsYXllckJTaWRlID0gcm9vbS5wbGF5ZXJfYV9zaWRlX3ZvdGUgPT09ICdwcm8nID8gJ2NvbicgOiAncHJvJ1xuICAgICAgICBjb25zb2xlLmxvZygn8J+FsO+4jyBST09NIFNFUlZJQ0UgLSBPbmx5IFBsYXllciBBIHZvdGVkJylcbiAgICAgIH0gZWxzZSBpZiAoIXJvb20ucGxheWVyX2Ffc2lkZV92b3RlICYmIHJvb20ucGxheWVyX2Jfc2lkZV92b3RlKSB7XG4gICAgICAgIC8vIE9ubHkgQiB2b3RlZCAtIEIgZ2V0cyBjaG9pY2UsIEEgZ2V0cyBvcHBvc2l0ZVxuICAgICAgICBwbGF5ZXJCU2lkZSA9IHJvb20ucGxheWVyX2Jfc2lkZV92b3RlXG4gICAgICAgIHBsYXllckFTaWRlID0gcm9vbS5wbGF5ZXJfYl9zaWRlX3ZvdGUgPT09ICdwcm8nID8gJ2NvbicgOiAncHJvJ1xuICAgICAgICBjb25zb2xlLmxvZygn8J+Fse+4jyBST09NIFNFUlZJQ0UgLSBPbmx5IFBsYXllciBCIHZvdGVkJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vYm9keSB2b3RlZCAtIHJhbmRvbSBhc3NpZ25tZW50XG4gICAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICAgICAgcGxheWVyQVNpZGUgPSAncHJvJ1xuICAgICAgICAgIHBsYXllckJTaWRlID0gJ2NvbidcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwbGF5ZXJBU2lkZSA9ICdjb24nXG4gICAgICAgICAgcGxheWVyQlNpZGUgPSAncHJvJ1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn46yIFJPT00gU0VSVklDRSAtIFJhbmRvbSBhc3NpZ25tZW50IChubyB2b3RlcyknKVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygn8J+OryBST09NIFNFUlZJQ0UgLSBGaW5hbCBzaWRlIGFzc2lnbm1lbnRzOicsIHsgcGxheWVyQVNpZGUsIHBsYXllckJTaWRlIH0pXG5cbiAgICAgIC8vIFVwZGF0ZSByb29tIHdpdGggZmluYWwgYXNzaWdubWVudHMgYW5kIG1vdmUgdG8gb3BlbmluZyBwcmVwIHBoYXNlXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Jvb21zJylcbiAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgcGxheWVyX2Ffc2lkZTogcGxheWVyQVNpZGUsXG4gICAgICAgICAgcGxheWVyX2Jfc2lkZTogcGxheWVyQlNpZGUsXG4gICAgICAgICAgY3VycmVudF9waGFzZTogJ29wZW5pbmdfcHJlcCcsXG4gICAgICAgICAgcGhhc2Vfc3RhcnRfdGltZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIHBoYXNlX2R1cmF0aW9uOiAzMCAvLyAzMCBzZWNvbmRzIGZvciBvcGVuaW5nIHByZXBcbiAgICAgICAgfSlcbiAgICAgICAgLmVxKCdpZCcsIHJvb21JZClcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBpZiAodXBkYXRlRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFJPT00gU0VSVklDRSAtIEVycm9yIGZpbmFsaXppbmcgc2lkZSBzZWxlY3Rpb246JywgdXBkYXRlRXJyb3IpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZpbmFsaXplIHNpZGVzOiAke3VwZGF0ZUVycm9yLm1lc3NhZ2V9YClcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ+KchSBST09NIFNFUlZJQ0UgLSBTaWRlIHNlbGVjdGlvbiBmaW5hbGl6ZWQnKVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIFJPT00gU0VSVklDRSAtIEZpbmFsaXplIHNpZGUgc2VsZWN0aW9uIGVycm9yOicsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH0sXG5cbiAgLy8gVW5yZWFkeVxuICBhc3luYyB1bnJlYWR5KHJvb21JZDogc3RyaW5nKTogUHJvbWlzZTxSb29tIHwgbnVsbD4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgdXNlcklkID0gYXdhaXQgdGhpcy5nZXRVc2VySWQoKVxuICAgICAgaWYgKCF1c2VySWQpIHtcbiAgICAgICAgdXNlcklkID0gdGhpcy5nZXRTZXNzaW9uSWQoKVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGE6IHJvb20sIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncm9vbXMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCdpZCcsIHJvb21JZClcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIGlmIChmZXRjaEVycm9yIHx8ICFyb29tKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUm9vbSBub3QgZm91bmQnKVxuICAgICAgfVxuXG4gICAgICBsZXQgdXBkYXRlRGF0YTogYW55ID0ge31cbiAgICAgIFxuICAgICAgaWYgKHJvb20ucGxheWVyX2FfaWQgPT09IHVzZXJJZCkge1xuICAgICAgICB1cGRhdGVEYXRhLnBsYXllcl9hX3JlYWR5ID0gZmFsc2VcbiAgICAgICAgY29uc29sZS5sb2coJ/CfhbDvuI8gUk9PTSBTRVJWSUNFIC0gUGxheWVyIEEgdW5yZWFkeWluZycpXG4gICAgICB9IGVsc2UgaWYgKHJvb20ucGxheWVyX2JfaWQgPT09IHVzZXJJZCkge1xuICAgICAgICB1cGRhdGVEYXRhLnBsYXllcl9iX3JlYWR5ID0gZmFsc2VcbiAgICAgICAgY29uc29sZS5sb2coJ/CfhbHvuI8gUk9PTSBTRVJWSUNFIC0gUGxheWVyIEIgdW5yZWFkeWluZycpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhcmUgbm90IGluIHRoaXMgcm9vbScpXG4gICAgICB9XG5cbiAgICAgIC8vIFJlc2V0IHRvIHdhaXRpbmcgc3RhdHVzXG4gICAgICB1cGRhdGVEYXRhLnN0YXR1cyA9ICd3YWl0aW5nJ1xuICAgICAgdXBkYXRlRGF0YS5jdXJyZW50X3BoYXNlID0gbnVsbFxuXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Jvb21zJylcbiAgICAgICAgLnVwZGF0ZSh1cGRhdGVEYXRhKVxuICAgICAgICAuZXEoJ2lkJywgcm9vbUlkKVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIGlmICh1cGRhdGVFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgUk9PTSBTRVJWSUNFIC0gRXJyb3IgdW5yZWFkeWluZzonLCB1cGRhdGVFcnJvcilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gdW5yZWFkeTogJHt1cGRhdGVFcnJvci5tZXNzYWdlfWApXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCfinIUgUk9PTSBTRVJWSUNFIC0gU3VjY2Vzc2Z1bGx5IHVucmVhZGllZCcpXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgUk9PTSBTRVJWSUNFIC0gVW5yZWFkeSBlcnJvcjonLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9LFxuXG4gIC8vIExlYXZlIHJvb21cbiAgYXN5bmMgbGVhdmVSb29tKHJvb21JZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCB1c2VySWQgPSBhd2FpdCB0aGlzLmdldFVzZXJJZCgpXG4gICAgICBpZiAoIXVzZXJJZCkge1xuICAgICAgICB1c2VySWQgPSB0aGlzLmdldFNlc3Npb25JZCgpXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn5qqIFJPT00gU0VSVklDRSAtIExlYXZpbmcgcm9vbTonLCB7XG4gICAgICAgIHJvb21JZDogcm9vbUlkLnNsaWNlKC04KSxcbiAgICAgICAgdXNlcklkOiB1c2VySWQuc2xpY2UoLTgpXG4gICAgICB9KVxuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGE6IHJvb20sIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncm9vbXMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCdpZCcsIHJvb21JZClcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIGlmIChmZXRjaEVycm9yIHx8ICFyb29tKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUm9vbSBub3QgZm91bmQnKVxuICAgICAgfVxuXG4gICAgICBsZXQgdXBkYXRlRGF0YTogYW55ID0ge31cbiAgICAgIFxuICAgICAgaWYgKHJvb20ucGxheWVyX2FfaWQgPT09IHVzZXJJZCkge1xuICAgICAgICB1cGRhdGVEYXRhLnBsYXllcl9hX2lkID0gbnVsbFxuICAgICAgICB1cGRhdGVEYXRhLnBsYXllcl9hX3JlYWR5ID0gZmFsc2VcbiAgICAgICAgdXBkYXRlRGF0YS5wbGF5ZXJfYV9zaWRlX3ZvdGUgPSBudWxsXG4gICAgICAgIHVwZGF0ZURhdGEucGxheWVyX2Ffc2lkZSA9IG51bGxcbiAgICAgICAgY29uc29sZS5sb2coJ/CfhbDvuI8gUk9PTSBTRVJWSUNFIC0gUGxheWVyIEEgbGVhdmluZycpXG4gICAgICB9IGVsc2UgaWYgKHJvb20ucGxheWVyX2JfaWQgPT09IHVzZXJJZCkge1xuICAgICAgICB1cGRhdGVEYXRhLnBsYXllcl9iX2lkID0gbnVsbFxuICAgICAgICB1cGRhdGVEYXRhLnBsYXllcl9iX3JlYWR5ID0gZmFsc2VcbiAgICAgICAgdXBkYXRlRGF0YS5wbGF5ZXJfYl9zaWRlX3ZvdGUgPSBudWxsXG4gICAgICAgIHVwZGF0ZURhdGEucGxheWVyX2Jfc2lkZSA9IG51bGxcbiAgICAgICAgY29uc29sZS5sb2coJ/CfhbHvuI8gUk9PTSBTRVJWSUNFIC0gUGxheWVyIEIgbGVhdmluZycpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhcmUgbm90IGluIHRoaXMgcm9vbScpXG4gICAgICB9XG5cbiAgICAgIC8vIFJlc2V0IHJvb20gc3RhdHVzIHRvIHdhaXRpbmdcbiAgICAgIHVwZGF0ZURhdGEuc3RhdHVzID0gJ3dhaXRpbmcnXG4gICAgICB1cGRhdGVEYXRhLmN1cnJlbnRfcGhhc2UgPSBudWxsXG5cbiAgICAgIGNvbnN0IHsgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncm9vbXMnKVxuICAgICAgICAudXBkYXRlKHVwZGF0ZURhdGEpXG4gICAgICAgIC5lcSgnaWQnLCByb29tSWQpXG5cbiAgICAgIGlmICh1cGRhdGVFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgUk9PTSBTRVJWSUNFIC0gRXJyb3IgbGVhdmluZyByb29tOicsIHVwZGF0ZUVycm9yKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsZWF2ZSByb29tOiAke3VwZGF0ZUVycm9yLm1lc3NhZ2V9YClcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ+KchSBST09NIFNFUlZJQ0UgLSBTdWNjZXNzZnVsbHkgbGVmdCByb29tJylcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBST09NIFNFUlZJQ0UgLSBMZWF2ZSByb29tIGVycm9yOicsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH0sXG5cbiAgLy8gR2V0IHJvb20gZGV0YWlsc1xuICBhc3luYyBnZXRSb29tKHJvb21JZDogc3RyaW5nKTogUHJvbWlzZTxSb29tIHwgbnVsbD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncm9vbXMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCdpZCcsIHJvb21JZClcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ1BHUlNUMTE2Jykge1xuICAgICAgICAgIHJldHVybiBudWxsIC8vIFJvb20gbm90IGZvdW5kXG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFJPT00gU0VSVklDRSAtIEVycm9yIGZldGNoaW5nIHJvb206JywgZXJyb3IpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBST09NIFNFUlZJQ0UgLSBHZXQgcm9vbSBlcnJvcjonLCBlcnJvcilcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9LFxuXG4gIC8vIFN0YXJ0IG9wZW5pbmcgcHJlcCBwaGFzZVxuICBhc3luYyBzdGFydE9wZW5pbmdQcmVwKHJvb21JZDogc3RyaW5nKTogUHJvbWlzZTxSb29tIHwgbnVsbD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+TnSBST09NIFNFUlZJQ0UgLSBTdGFydGluZyBvcGVuaW5nIHByZXAgcGhhc2UgZm9yIHJvb206Jywgcm9vbUlkLnNsaWNlKC04KSlcbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Jvb21zJylcbiAgICAgICAgLnVwZGF0ZSh7IFxuICAgICAgICAgIGN1cnJlbnRfcGhhc2U6ICdvcGVuaW5nX3ByZXAnLFxuICAgICAgICAgIHBoYXNlX3N0YXJ0X3RpbWU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBwaGFzZV9kdXJhdGlvbjogMzAgLy8gMzAgc2Vjb25kcyBmb3IgcHJlcFxuICAgICAgICB9KVxuICAgICAgICAuZXEoJ2lkJywgcm9vbUlkKVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgUk9PTSBTRVJWSUNFIC0gRXJyb3Igc3RhcnRpbmcgb3BlbmluZyBwcmVwOicsIGVycm9yKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzdGFydCBvcGVuaW5nIHByZXA6ICR7ZXJyb3IubWVzc2FnZX1gKVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFJPT00gU0VSVklDRSAtIE9wZW5pbmcgcHJlcCBzdGFydGVkIHN1Y2Nlc3NmdWxseScpXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgUk9PTSBTRVJWSUNFIC0gU3RhcnQgb3BlbmluZyBwcmVwIGVycm9yOicsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH0sXG5cbiAgLy8gU3RhcnQgb3BlbmluZyBzdGF0ZW1lbnRzIHBoYXNlXG4gIGFzeW5jIHN0YXJ0T3BlbmluZ1N0YXRlbWVudHMocm9vbUlkOiBzdHJpbmcpOiBQcm9taXNlPFJvb20gfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn46kIFJPT00gU0VSVklDRSAtIFN0YXJ0aW5nIG9wZW5pbmcgc3RhdGVtZW50cyBmb3Igcm9vbTonLCByb29tSWQuc2xpY2UoLTgpKVxuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncm9vbXMnKVxuICAgICAgICAudXBkYXRlKHsgXG4gICAgICAgICAgY3VycmVudF9waGFzZTogJ29wZW5pbmcnLFxuICAgICAgICAgIHBoYXNlX3N0YXJ0X3RpbWU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBwaGFzZV9kdXJhdGlvbjogNzAgLy8gMzBzICsgMTBzIHRyYW5zaXRpb24gKyAzMHNcbiAgICAgICAgfSlcbiAgICAgICAgLmVxKCdpZCcsIHJvb21JZClcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFJPT00gU0VSVklDRSAtIEVycm9yIHN0YXJ0aW5nIG9wZW5pbmcgc3RhdGVtZW50czonLCBlcnJvcilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc3RhcnQgb3BlbmluZyBzdGF0ZW1lbnRzOiAke2Vycm9yLm1lc3NhZ2V9YClcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ+KchSBST09NIFNFUlZJQ0UgLSBPcGVuaW5nIHN0YXRlbWVudHMgc3RhcnRlZCBzdWNjZXNzZnVsbHknKVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIFJPT00gU0VSVklDRSAtIFN0YXJ0IG9wZW5pbmcgc3RhdGVtZW50cyBlcnJvcjonLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9LFxuXG4gIC8vIFN0YXJ0IGdhbWUgd2l0aCBzaWRlIHNlbGVjdGlvblxuICBhc3luYyBzdGFydEdhbWVXaXRoU2lkZVNlbGVjdGlvbihyb29tSWQ6IHN0cmluZyk6IFByb21pc2U8Um9vbSB8IG51bGw+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ/Cfjq4gUk9PTSBTRVJWSUNFIC0gU3RhcnRpbmcgZ2FtZSB3aXRoIHNpZGUgc2VsZWN0aW9uIGZvciByb29tOicsIHJvb21JZC5zbGljZSgtOCkpXG4gICAgICBcbiAgICAgIGNvbnN0IGRlYWRsaW5lID0gbmV3IERhdGUoRGF0ZS5ub3coKSArIDEwMDAwKSAvLyAxMCBzZWNvbmRzIGZyb20gbm93XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdyb29tcycpXG4gICAgICAgIC51cGRhdGUoeyBcbiAgICAgICAgICBzdGF0dXM6ICdkZWJhdGluZycsXG4gICAgICAgICAgY3VycmVudF9waGFzZTogJ3NpZGVfc2VsZWN0aW9uJywgLy8gU3RhcnQgd2l0aCBzaWRlIHNlbGVjdGlvblxuICAgICAgICAgIHNpZGVfc2VsZWN0aW9uX2RlYWRsaW5lOiBkZWFkbGluZS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIHBoYXNlX3N0YXJ0X3RpbWU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBwaGFzZV9kdXJhdGlvbjogMTAgLy8gMTAgc2Vjb25kcyBmb3Igc2lkZSBzZWxlY3Rpb25cbiAgICAgICAgfSlcbiAgICAgICAgLmVxKCdpZCcsIHJvb21JZClcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFJPT00gU0VSVklDRSAtIEVycm9yIHN0YXJ0aW5nIGdhbWUgd2l0aCBzaWRlIHNlbGVjdGlvbjonLCBlcnJvcilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc3RhcnQgZ2FtZTogJHtlcnJvci5tZXNzYWdlfWApXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCfinIUgUk9PTSBTRVJWSUNFIC0gR2FtZSBzdGFydGVkIHdpdGggc2lkZSBzZWxlY3Rpb24gc3VjY2Vzc2Z1bGx5JylcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBST09NIFNFUlZJQ0UgLSBTdGFydCBnYW1lIHdpdGggc2lkZSBzZWxlY3Rpb24gZXJyb3I6JywgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfSxcblxuICAvLyBFbmhhbmNlZCBzdWJzY3JpcHRpb24gd2l0aCBiZXR0ZXIgZXJyb3IgaGFuZGxpbmdcbiAgc3Vic2NyaWJlVG9Sb29tKHJvb21JZDogc3RyaW5nLCBjYWxsYmFjazogKHJvb206IFJvb20pID0+IHZvaWQpIHtcbiAgICBjb25zb2xlLmxvZygn8J+ToSBST09NIFNFUlZJQ0UgLSBTZXR0aW5nIHVwIHN1YnNjcmlwdGlvbiBmb3Igcm9vbTonLCByb29tSWQuc2xpY2UoLTgpKVxuICAgIFxuICAgIGNvbnN0IGNoYW5uZWwgPSBzdXBhYmFzZVxuICAgICAgLmNoYW5uZWwoYHJvb206JHtyb29tSWR9OiR7RGF0ZS5ub3coKX1gKVxuICAgICAgLm9uKFxuICAgICAgICAncG9zdGdyZXNfY2hhbmdlcycsXG4gICAgICAgIHtcbiAgICAgICAgICBldmVudDogJyonLFxuICAgICAgICAgIHNjaGVtYTogJ3B1YmxpYycsXG4gICAgICAgICAgdGFibGU6ICdyb29tcycsXG4gICAgICAgICAgZmlsdGVyOiBgaWQ9ZXEuJHtyb29tSWR9YCxcbiAgICAgICAgfSxcbiAgICAgICAgKHBheWxvYWQ6IGFueSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SEIFJPT00gU0VSVklDRSAtIFJlYWwtdGltZSB1cGRhdGUgcmVjZWl2ZWQ6Jywge1xuICAgICAgICAgICAgZXZlbnQ6IHBheWxvYWQuZXZlbnRUeXBlLFxuICAgICAgICAgICAgbmV3OiBwYXlsb2FkLm5ldyA/IHtcbiAgICAgICAgICAgICAgaWQ6IHBheWxvYWQubmV3LmlkLnNsaWNlKC04KSxcbiAgICAgICAgICAgICAgcGxheWVyX2FfaWQ6IHBheWxvYWQubmV3LnBsYXllcl9hX2lkID8gcGF5bG9hZC5uZXcucGxheWVyX2FfaWQuc2xpY2UoLTgpIDogbnVsbCxcbiAgICAgICAgICAgICAgcGxheWVyX2JfaWQ6IHBheWxvYWQubmV3LnBsYXllcl9iX2lkID8gcGF5bG9hZC5uZXcucGxheWVyX2JfaWQuc2xpY2UoLTgpIDogbnVsbCxcbiAgICAgICAgICAgICAgc3RhdHVzOiBwYXlsb2FkLm5ldy5zdGF0dXMsXG4gICAgICAgICAgICAgIGN1cnJlbnRfcGhhc2U6IHBheWxvYWQubmV3LmN1cnJlbnRfcGhhc2VcbiAgICAgICAgICAgIH0gOiBudWxsXG4gICAgICAgICAgfSlcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAocGF5bG9hZC5uZXcpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHBheWxvYWQubmV3IGFzIFJvb20pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKChzdGF0dXM6IHN0cmluZywgZXJyb3I/OiBFcnJvcikgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygn8J+ToSBST09NIFNFUlZJQ0UgLSBTdWJzY3JpcHRpb24gc3RhdHVzOicsIHN0YXR1cylcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFJPT00gU0VSVklDRSAtIFN1YnNjcmlwdGlvbiBlcnJvcjonLCBlcnJvcilcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ1NVQlNDUklCRUQnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ+KchSBST09NIFNFUlZJQ0UgLSBTdWNjZXNzZnVsbHkgc3Vic2NyaWJlZCB0byByb29tIHVwZGF0ZXMnKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgcmV0dXJuIGNoYW5uZWxcbiAgfVxufSJdLCJuYW1lcyI6WyJzdXBhYmFzZSIsInJvbGVNYW5hZ2VyIiwiREVCQVRFX1RPUElDUyIsImdlbmVyYXRlVVVJRCIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJyZXBsYWNlIiwiYyIsInIiLCJNYXRoIiwicmFuZG9tIiwidiIsInRvU3RyaW5nIiwicm9vbVNlcnZpY2UiLCJnZXRVc2VySWQiLCJkYXRhIiwiZXJyb3IiLCJhdXRoIiwiZ2V0VXNlciIsInVzZXIiLCJpZCIsImdldFNlc3Npb25JZCIsImNyZWF0ZVJvb20iLCJ1c2VySWQiLCJjb25zb2xlIiwibG9nIiwic2xpY2UiLCJyYW5kb21Ub3BpYyIsImZsb29yIiwibGVuZ3RoIiwicm9vbURhdGEiLCJ0b3BpYyIsInN0YXR1cyIsInBsYXllcl9hX2hlYWx0aCIsInBsYXllcl9iX2hlYWx0aCIsInBsYXllcl9hX3JlYWR5IiwicGxheWVyX2JfcmVhZHkiLCJwbGF5ZXJfYV9pZCIsImZyb20iLCJpbnNlcnQiLCJzZWxlY3QiLCJzaW5nbGUiLCJFcnJvciIsIm1lc3NhZ2UiLCJyb29tIiwicGxheWVyUm9sZSIsImpvaW5Sb29tIiwicm9vbUlkIiwiY3VycmVudFJvb20iLCJhY3R1YWxVc2VySWQiLCJ1dWlkUmVnZXgiLCJ0ZXN0IiwiZmV0Y2hFcnJvciIsImVxIiwiY29kZSIsInBsYXllcl9iX2lkIiwidXBkYXRlRGF0YSIsInVwZGF0ZWRSb29tIiwidXBkYXRlRXJyb3IiLCJ1cGRhdGUiLCJyZWFkeVVwIiwicm9vbVBsYXllckEiLCJyb29tUGxheWVyQiIsImJvdGhSZWFkeSIsImRlYWRsaW5lIiwiRGF0ZSIsIm5vdyIsImN1cnJlbnRfcGhhc2UiLCJzaWRlX3NlbGVjdGlvbl9kZWFkbGluZSIsInRvSVNPU3RyaW5nIiwicGhhc2Vfc3RhcnRfdGltZSIsInBoYXNlX2R1cmF0aW9uIiwic3VibWl0U2lkZVZvdGUiLCJzaWRlIiwicGxheWVyX2Ffc2lkZV92b3RlIiwicGxheWVyX2Jfc2lkZV92b3RlIiwiZmluYWxpemVTaWRlU2VsZWN0aW9uIiwicGxheWVyQVNpZGUiLCJwbGF5ZXJCU2lkZSIsInBsYXllckFWb3RlIiwicGxheWVyQlZvdGUiLCJwbGF5ZXJfYV9zaWRlIiwicGxheWVyX2Jfc2lkZSIsInVucmVhZHkiLCJsZWF2ZVJvb20iLCJnZXRSb29tIiwic3RhcnRPcGVuaW5nUHJlcCIsInN0YXJ0T3BlbmluZ1N0YXRlbWVudHMiLCJzdGFydEdhbWVXaXRoU2lkZVNlbGVjdGlvbiIsInN1YnNjcmliZVRvUm9vbSIsImNhbGxiYWNrIiwiY2hhbm5lbCIsIm9uIiwiZXZlbnQiLCJzY2hlbWEiLCJ0YWJsZSIsImZpbHRlciIsInBheWxvYWQiLCJldmVudFR5cGUiLCJuZXciLCJzdWJzY3JpYmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/roomService.ts\n"));

/***/ })

});