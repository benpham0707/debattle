"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/room/[id]/page",{

/***/ "(app-pages-browser)/./src/lib/roleManager.ts":
/*!********************************!*\
  !*** ./src/lib/roleManager.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getStablePlayerRole: function() { return /* binding */ getStablePlayerRole; },\n/* harmony export */   getStableSessionId: function() { return /* binding */ getStableSessionId; },\n/* harmony export */   roleManager: function() { return /* binding */ roleManager; },\n/* harmony export */   usePlayerRole: function() { return /* binding */ usePlayerRole; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n// src/lib/roleManager.ts\n// Role management system with unique session IDs per browser tab\n\n// Helper function to generate a proper UUID v4\nfunction generateUUID() {\n    // Use crypto.randomUUID if available (modern browsers)\n    if (typeof crypto !== \"undefined\" && crypto.randomUUID) {\n        return crypto.randomUUID();\n    }\n    // Fallback to manual generation (proper UUID v4 format)\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n        const r = Math.random() * 16 | 0;\n        const v = c === \"x\" ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n    });\n}\n// Single source of truth for role management\nclass RoleManager {\n    static getInstance() {\n        if (!RoleManager.instance) {\n            RoleManager.instance = new RoleManager();\n        }\n        return RoleManager.instance;\n    }\n    // Generate a unique session ID for this specific browser tab\n    generateTabSessionId() {\n        // Check if we already have a session ID for this tab\n        if (this.tabSessionId) {\n            return this.tabSessionId;\n        }\n        // Generate a new UUID for this tab session\n        this.tabSessionId = generateUUID();\n        console.log(\"\\uD83C\\uDD95 ROLE MANAGER - Generated new tab session UUID:\", this.tabSessionId.slice(-8));\n        return this.tabSessionId;\n    }\n    // Validate UUID format\n    isValidUUID(uuid) {\n        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n        return uuidRegex.test(uuid);\n    }\n    // Initialize or retrieve role for a specific room\n    async initializeRole(roomId, room) {\n        const sessionKey = \"debattle_role_\".concat(roomId);\n        // First, check if we already have a locked role for this room\n        const existingSession = localStorage.getItem(sessionKey);\n        if (existingSession) {\n            try {\n                const parsed = JSON.parse(existingSession);\n                // Validate that the session is still valid and has proper UUID\n                if (this.isValidUUID(parsed.sessionId) && this.validateSession(parsed, room)) {\n                    console.log(\"✅ ROLE MANAGER - Restored existing valid session:\", {\n                        role: parsed.playerRole,\n                        sessionId: parsed.sessionId.slice(-8),\n                        isLocked: parsed.isLocked\n                    });\n                    this.currentSession = parsed;\n                    this.tabSessionId = parsed.sessionId // Remember this tab's session ID\n                    ;\n                    return parsed;\n                } else {\n                    console.log(\"❌ ROLE MANAGER - Existing session invalid, will create new one\");\n                    localStorage.removeItem(sessionKey);\n                }\n            } catch (error) {\n                console.error(\"❌ ROLE MANAGER - Error parsing existing session:\", error);\n                localStorage.removeItem(sessionKey);\n            }\n        }\n        // Create new session if none exists or existing is invalid\n        const sessionId = this.generateTabSessionId();\n        const playerRole = await this.determineRoleFromRoom(room, sessionId);\n        const newSession = {\n            sessionId,\n            playerRole,\n            roomId,\n            assignedAt: Date.now(),\n            isLocked: room.status === \"debating\" // Lock role once game starts\n        };\n        // Save the session\n        localStorage.setItem(sessionKey, JSON.stringify(newSession));\n        this.currentSession = newSession;\n        console.log(\"\\uD83C\\uDFAD ROLE MANAGER - Created new session:\", {\n            role: newSession.playerRole,\n            sessionId: newSession.sessionId.slice(-8),\n            isLocked: newSession.isLocked,\n            roomStatus: room.status\n        });\n        return newSession;\n    }\n    // Validate that a session is still valid for the current room state\n    validateSession(session, room) {\n        // Check if room still exists and session ID matches expected player\n        if (session.playerRole === \"player_a\") {\n            return room.player_a_id === session.sessionId;\n        } else if (session.playerRole === \"player_b\") {\n            return room.player_b_id === session.sessionId;\n        } else {\n            return session.playerRole === \"spectator\" // Spectators are always valid\n            ;\n        }\n    }\n    // Determine role based on room state and session ID\n    async determineRoleFromRoom(room, sessionId) {\n        var _room_player_a_id, _room_player_b_id;\n        console.log(\"\\uD83D\\uDD0D ROLE MANAGER - Determining role from room:\", {\n            sessionId: sessionId.slice(-8),\n            roomPlayerA: (_room_player_a_id = room.player_a_id) === null || _room_player_a_id === void 0 ? void 0 : _room_player_a_id.slice(-8),\n            roomPlayerB: (_room_player_b_id = room.player_b_id) === null || _room_player_b_id === void 0 ? void 0 : _room_player_b_id.slice(-8)\n        });\n        // Check direct ID matches first\n        if (room.player_a_id === sessionId) {\n            console.log(\"✅ ROLE MANAGER - Matched as Player A by ID\");\n            return \"player_a\";\n        }\n        if (room.player_b_id === sessionId) {\n            console.log(\"✅ ROLE MANAGER - Matched as Player B by ID\");\n            return \"player_b\";\n        }\n        // If no match found, user is a spectator\n        console.log(\"\\uD83D\\uDC40 ROLE MANAGER - No match found, assigned as spectator\");\n        return \"spectator\";\n    }\n    // Get current session (used by components)\n    getCurrentSession() {\n        return this.currentSession;\n    }\n    // Lock the role once game starts (prevents changes during game)\n    lockRole(roomId) {\n        if (this.currentSession && this.currentSession.roomId === roomId) {\n            this.currentSession.isLocked = true;\n            const sessionKey = \"debattle_role_\".concat(roomId);\n            localStorage.setItem(sessionKey, JSON.stringify(this.currentSession));\n            console.log(\"\\uD83D\\uDD12 ROLE MANAGER - Role locked for game session\");\n        }\n    }\n    // Clear role when leaving room\n    clearRole(roomId) {\n        const sessionKey = \"debattle_role_\".concat(roomId);\n        localStorage.removeItem(sessionKey);\n        if (this.currentSession && this.currentSession.roomId === roomId) {\n            this.currentSession = null;\n        }\n        console.log(\"\\uD83E\\uDDF9 ROLE MANAGER - Cleared role for room:\", roomId.slice(-8));\n    }\n    // Get session ID for room service compatibility (ensures proper UUID format)\n    getSessionId() {\n        if (this.currentSession && this.isValidUUID(this.currentSession.sessionId)) {\n            return this.currentSession.sessionId;\n        }\n        // Generate new UUID for this tab if current session is invalid\n        const newId = this.generateTabSessionId();\n        console.log(\"\\uD83C\\uDD95 ROLE MANAGER - Using tab session ID:\", newId.slice(-8));\n        return newId;\n    }\n    // Debug helper\n    debugSession(roomId) {\n        var _this_tabSessionId;\n        const sessionKey = \"debattle_role_\".concat(roomId);\n        const stored = localStorage.getItem(sessionKey);\n        console.log(\"\\uD83D\\uDD0D ROLE MANAGER DEBUG:\", {\n            currentSession: this.currentSession,\n            storedSession: stored ? JSON.parse(stored) : null,\n            tabSessionId: (_this_tabSessionId = this.tabSessionId) === null || _this_tabSessionId === void 0 ? void 0 : _this_tabSessionId.slice(-8),\n            allDebattleKeys: Object.keys(localStorage).filter((k)=>k.includes(\"debattle\"))\n        });\n    }\n    // Clean up invalid session data\n    cleanupInvalidSessions() {\n        const keys = Object.keys(localStorage).filter((k)=>k.includes(\"debattle\"));\n        let cleaned = 0;\n        keys.forEach((key)=>{\n            try {\n                const value = localStorage.getItem(key);\n                if (value) {\n                    // For role sessions, check if they have valid UUIDs\n                    if (key.includes(\"debattle_role_\")) {\n                        const session = JSON.parse(value);\n                        if (!this.isValidUUID(session.sessionId)) {\n                            localStorage.removeItem(key);\n                            cleaned++;\n                            console.log(\"\\uD83E\\uDDF9 ROLE MANAGER - Cleaned invalid session:\", key);\n                        }\n                    }\n                // Skip global session cleanup since we're using per-tab sessions now\n                }\n            } catch (error) {\n                localStorage.removeItem(key);\n                cleaned++;\n                console.log(\"\\uD83E\\uDDF9 ROLE MANAGER - Cleaned corrupted session:\", key);\n            }\n        });\n        if (cleaned > 0) {\n            console.log(\"\\uD83E\\uDDF9 ROLE MANAGER - Cleaned \".concat(cleaned, \" invalid sessions\"));\n        }\n    }\n    // Force generate new session (useful for testing)\n    forceNewSession() {\n        this.tabSessionId = null;\n        return this.generateTabSessionId();\n    }\n    constructor(){\n        this.currentSession = null;\n        this.tabSessionId = null // Unique per tab\n        ;\n    }\n}\nconst roleManager = RoleManager.getInstance();\n// Initialize cleanup on module load\nif (true) {\n    roleManager.cleanupInvalidSessions();\n}\n// Helper hook for React components\nfunction usePlayerRole(roomId, room) {\n    const [session, setSession] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(null);\n    const [isLoading, setIsLoading] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(true);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(()=>{\n        if (!room) return;\n        const initRole = async ()=>{\n            try {\n                const playerSession = await roleManager.initializeRole(roomId, room);\n                setSession(playerSession);\n                // Lock role if game is in progress\n                if (room.status === \"debating\" && !playerSession.isLocked) {\n                    roleManager.lockRole(roomId);\n                }\n            } catch (error) {\n                console.error(\"Error initializing role:\", error);\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        initRole();\n    }, [\n        roomId,\n        room === null || room === void 0 ? void 0 : room.id\n    ]) // Only re-run if roomId or room.id changes\n    ;\n    return {\n        session,\n        isLoading\n    };\n}\n// Compatibility functions for existing code\nfunction getStablePlayerRole(roomId) {\n    const session = roleManager.getCurrentSession();\n    if (session && session.roomId === roomId) {\n        return session.playerRole;\n    }\n    return \"spectator\";\n}\nfunction getStableSessionId() {\n    return roleManager.getSessionId();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvcm9sZU1hbmFnZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEseUJBQXlCO0FBQ3pCLGlFQUFpRTtBQUV4QztBQVV6QiwrQ0FBK0M7QUFDL0MsU0FBU0M7SUFDUCx1REFBdUQ7SUFDdkQsSUFBSSxPQUFPQyxXQUFXLGVBQWVBLE9BQU9DLFVBQVUsRUFBRTtRQUN0RCxPQUFPRCxPQUFPQyxVQUFVO0lBQzFCO0lBRUEsd0RBQXdEO0lBQ3hELE9BQU8sdUNBQXVDQyxPQUFPLENBQUMsU0FBUyxTQUFTQyxDQUFDO1FBQ3ZFLE1BQU1DLElBQUksS0FBTUUsTUFBTSxLQUFLLEtBQU07UUFDakMsTUFBTUMsSUFBSUosTUFBTSxNQUFNQyxJQUFJLElBQUssTUFBTztRQUN0QyxPQUFPRyxFQUFFQyxRQUFRLENBQUM7SUFDcEI7QUFDRjtBQUVBLDZDQUE2QztBQUM3QyxNQUFNQztJQUtKLE9BQU9DLGNBQTJCO1FBQ2hDLElBQUksQ0FBQ0QsWUFBWUUsUUFBUSxFQUFFO1lBQ3pCRixZQUFZRSxRQUFRLEdBQUcsSUFBSUY7UUFDN0I7UUFDQSxPQUFPQSxZQUFZRSxRQUFRO0lBQzdCO0lBRUEsNkRBQTZEO0lBQ3JEQyx1QkFBK0I7UUFDckMscURBQXFEO1FBQ3JELElBQUksSUFBSSxDQUFDQyxZQUFZLEVBQUU7WUFDckIsT0FBTyxJQUFJLENBQUNBLFlBQVk7UUFDMUI7UUFFQSwyQ0FBMkM7UUFDM0MsSUFBSSxDQUFDQSxZQUFZLEdBQUdkO1FBQ3BCZSxRQUFRQyxHQUFHLENBQUMsK0RBQXFELElBQUksQ0FBQ0YsWUFBWSxDQUFDRyxLQUFLLENBQUMsQ0FBQztRQUMxRixPQUFPLElBQUksQ0FBQ0gsWUFBWTtJQUMxQjtJQUVBLHVCQUF1QjtJQUNmSSxZQUFZQyxJQUFZLEVBQVc7UUFDekMsTUFBTUMsWUFBWTtRQUNsQixPQUFPQSxVQUFVQyxJQUFJLENBQUNGO0lBQ3hCO0lBRUEsa0RBQWtEO0lBQ2xELE1BQU1HLGVB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QUU7SUFDRixHQUFHO1FBQUMxRDtRQUFRQyxpQkFBQUEsMkJBQUFBLEtBQU0yRCxFQUFFO0tBQUMsRUFBRSwyQ0FBMkM7O0lBRWxFLE9BQU87UUFBRWxDO1FBQVM2QjtJQUFVO0FBQzlCO0FBRUEsNENBQTRDO0FBQ3JDLFNBQVNNLG9CQUFvQjdELE1BQWM7SUFDaEQsTUFBTTBCLFVBQVV5QixZQUFZcEIsaUJBQWlCO0lBQzdDLElBQUlMLFdBQVdBLFFBQVExQixNQUFNLEtBQUtBLFFBQVE7UUFDeEMsT0FBTzBCLFFBQVFkLFVBQVU7SUFDM0I7SUFDQSxPQUFPO0FBQ1Q7QUFFTyxTQUFTa0Q7SUFDZCxPQUFPWCxZQUFZakIsWUFBWTtBQUNqQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL3JvbGVNYW5hZ2VyLnRzP2UzYmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2xpYi9yb2xlTWFuYWdlci50c1xuLy8gUm9sZSBtYW5hZ2VtZW50IHN5c3RlbSB3aXRoIHVuaXF1ZSBzZXNzaW9uIElEcyBwZXIgYnJvd3NlciB0YWJcblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5leHBvcnQgaW50ZXJmYWNlIFBsYXllclNlc3Npb24ge1xuICBzZXNzaW9uSWQ6IHN0cmluZ1xuICBwbGF5ZXJSb2xlOiAncGxheWVyX2EnIHwgJ3BsYXllcl9iJyB8ICdzcGVjdGF0b3InXG4gIHJvb21JZDogc3RyaW5nXG4gIGFzc2lnbmVkQXQ6IG51bWJlciAvLyB0aW1lc3RhbXAgd2hlbiByb2xlIHdhcyBhc3NpZ25lZFxuICBpc0xvY2tlZDogYm9vbGVhbiAvLyBwcmV2ZW50cyByb2xlIGNoYW5nZXMgb25jZSBnYW1lIHN0YXJ0c1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSBwcm9wZXIgVVVJRCB2NFxuZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKCk6IHN0cmluZyB7XG4gIC8vIFVzZSBjcnlwdG8ucmFuZG9tVVVJRCBpZiBhdmFpbGFibGUgKG1vZGVybiBicm93c2VycylcbiAgaWYgKHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5yYW5kb21VVUlEKSB7XG4gICAgcmV0dXJuIGNyeXB0by5yYW5kb21VVUlEKClcbiAgfVxuICBcbiAgLy8gRmFsbGJhY2sgdG8gbWFudWFsIGdlbmVyYXRpb24gKHByb3BlciBVVUlEIHY0IGZvcm1hdClcbiAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24oYykge1xuICAgIGNvbnN0IHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2KSB8IDBcbiAgICBjb25zdCB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4OFxuICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KVxuICB9KVxufVxuXG4vLyBTaW5nbGUgc291cmNlIG9mIHRydXRoIGZvciByb2xlIG1hbmFnZW1lbnRcbmNsYXNzIFJvbGVNYW5hZ2VyIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFJvbGVNYW5hZ2VyXG4gIHByaXZhdGUgY3VycmVudFNlc3Npb246IFBsYXllclNlc3Npb24gfCBudWxsID0gbnVsbFxuICBwcml2YXRlIHRhYlNlc3Npb25JZDogc3RyaW5nIHwgbnVsbCA9IG51bGwgLy8gVW5pcXVlIHBlciB0YWJcbiAgXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBSb2xlTWFuYWdlciB7XG4gICAgaWYgKCFSb2xlTWFuYWdlci5pbnN0YW5jZSkge1xuICAgICAgUm9sZU1hbmFnZXIuaW5zdGFuY2UgPSBuZXcgUm9sZU1hbmFnZXIoKVxuICAgIH1cbiAgICByZXR1cm4gUm9sZU1hbmFnZXIuaW5zdGFuY2VcbiAgfVxuXG4gIC8vIEdlbmVyYXRlIGEgdW5pcXVlIHNlc3Npb24gSUQgZm9yIHRoaXMgc3BlY2lmaWMgYnJvd3NlciB0YWJcbiAgcHJpdmF0ZSBnZW5lcmF0ZVRhYlNlc3Npb25JZCgpOiBzdHJpbmcge1xuICAgIC8vIENoZWNrIGlmIHdlIGFscmVhZHkgaGF2ZSBhIHNlc3Npb24gSUQgZm9yIHRoaXMgdGFiXG4gICAgaWYgKHRoaXMudGFiU2Vzc2lvbklkKSB7XG4gICAgICByZXR1cm4gdGhpcy50YWJTZXNzaW9uSWRcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBhIG5ldyBVVUlEIGZvciB0aGlzIHRhYiBzZXNzaW9uXG4gICAgdGhpcy50YWJTZXNzaW9uSWQgPSBnZW5lcmF0ZVVVSUQoKVxuICAgIGNvbnNvbGUubG9nKCfwn4aVIFJPTEUgTUFOQUdFUiAtIEdlbmVyYXRlZCBuZXcgdGFiIHNlc3Npb24gVVVJRDonLCB0aGlzLnRhYlNlc3Npb25JZC5zbGljZSgtOCkpXG4gICAgcmV0dXJuIHRoaXMudGFiU2Vzc2lvbklkXG4gIH1cblxuICAvLyBWYWxpZGF0ZSBVVUlEIGZvcm1hdFxuICBwcml2YXRlIGlzVmFsaWRVVUlEKHV1aWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHV1aWRSZWdleCA9IC9eWzAtOWEtZl17OH0tWzAtOWEtZl17NH0tNFswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfSQvaVxuICAgIHJldHVybiB1dWlkUmVnZXgudGVzdCh1dWlkKVxuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBvciByZXRyaWV2ZSByb2xlIGZvciBhIHNwZWNpZmljIHJvb21cbiAgYXN5bmMgaW5pdGlhbGl6ZVJvbGUocm9vbUlkOiBzdHJpbmcsIHJvb206IGFueSk6IFByb21pc2U8UGxheWVyU2Vzc2lvbj4ge1xuICAgIGNvbnN0IHNlc3Npb25LZXkgPSBgZGViYXR0bGVfcm9sZV8ke3Jvb21JZH1gXG4gICAgXG4gICAgLy8gRmlyc3QsIGNoZWNrIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGxvY2tlZCByb2xlIGZvciB0aGlzIHJvb21cbiAgICBjb25zdCBleGlzdGluZ1Nlc3Npb24gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShzZXNzaW9uS2V5KVxuICAgIGlmIChleGlzdGluZ1Nlc3Npb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZDogUGxheWVyU2Vzc2lvbiA9IEpTT04ucGFyc2UoZXhpc3RpbmdTZXNzaW9uKVxuICAgICAgICBcbiAgICAgICAgLy8gVmFsaWRhdGUgdGhhdCB0aGUgc2Vzc2lvbiBpcyBzdGlsbCB2YWxpZCBhbmQgaGFzIHByb3BlciBVVUlEXG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWRVVUlEKHBhcnNlZC5zZXNzaW9uSWQpICYmIHRoaXMudmFsaWRhdGVTZXNzaW9uKHBhcnNlZCwgcm9vbSkpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIFJPTEUgTUFOQUdFUiAtIFJlc3RvcmVkIGV4aXN0aW5nIHZhbGlkIHNlc3Npb246Jywge1xuICAgICAgICAgICAgcm9sZTogcGFyc2VkLnBsYXllclJvbGUsXG4gICAgICAgICAgICBzZXNzaW9uSWQ6IHBhcnNlZC5zZXNzaW9uSWQuc2xpY2UoLTgpLFxuICAgICAgICAgICAgaXNMb2NrZWQ6IHBhcnNlZC5pc0xvY2tlZFxuICAgICAgICAgIH0pXG4gICAgICAgICAgdGhpcy5jdXJyZW50U2Vzc2lvbiA9IHBhcnNlZFxuICAgICAgICAgIHRoaXMudGFiU2Vzc2lvbklkID0gcGFyc2VkLnNlc3Npb25JZCAvLyBSZW1lbWJlciB0aGlzIHRhYidzIHNlc3Npb24gSURcbiAgICAgICAgICByZXR1cm4gcGFyc2VkXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ+KdjCBST0xFIE1BTkFHRVIgLSBFeGlzdGluZyBzZXNzaW9uIGludmFsaWQsIHdpbGwgY3JlYXRlIG5ldyBvbmUnKVxuICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHNlc3Npb25LZXkpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBST0xFIE1BTkFHRVIgLSBFcnJvciBwYXJzaW5nIGV4aXN0aW5nIHNlc3Npb246JywgZXJyb3IpXG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHNlc3Npb25LZXkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIG5ldyBzZXNzaW9uIGlmIG5vbmUgZXhpc3RzIG9yIGV4aXN0aW5nIGlzIGludmFsaWRcbiAgICBjb25zdCBzZXNzaW9uSWQgPSB0aGlzLmdlbmVyYXRlVGFiU2Vzc2lvbklkKClcbiAgICBjb25zdCBwbGF5ZXJSb2xlID0gYXdhaXQgdGhpcy5kZXRlcm1pbmVSb2xlRnJvbVJvb20ocm9vbSwgc2Vzc2lvbklkKVxuICAgIFxuICAgIGNvbnN0IG5ld1Nlc3Npb246IFBsYXllclNlc3Npb24gPSB7XG4gICAgICBzZXNzaW9uSWQsXG4gICAgICBwbGF5ZXJSb2xlLFxuICAgICAgcm9vbUlkLFxuICAgICAgYXNzaWduZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgIGlzTG9ja2VkOiByb29tLnN0YXR1cyA9PT0gJ2RlYmF0aW5nJyAvLyBMb2NrIHJvbGUgb25jZSBnYW1lIHN0YXJ0c1xuICAgIH1cblxuICAgIC8vIFNhdmUgdGhlIHNlc3Npb25cbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShzZXNzaW9uS2V5LCBKU09OLnN0cmluZ2lmeShuZXdTZXNzaW9uKSlcbiAgICB0aGlzLmN1cnJlbnRTZXNzaW9uID0gbmV3U2Vzc2lvblxuXG4gICAgY29uc29sZS5sb2coJ/Cfjq0gUk9MRSBNQU5BR0VSIC0gQ3JlYXRlZCBuZXcgc2Vzc2lvbjonLCB7XG4gICAgICByb2xlOiBuZXdTZXNzaW9uLnBsYXllclJvbGUsXG4gICAgICBzZXNzaW9uSWQ6IG5ld1Nlc3Npb24uc2Vzc2lvbklkLnNsaWNlKC04KSxcbiAgICAgIGlzTG9ja2VkOiBuZXdTZXNzaW9uLmlzTG9ja2VkLFxuICAgICAgcm9vbVN0YXR1czogcm9vbS5zdGF0dXNcbiAgICB9KVxuXG4gICAgcmV0dXJuIG5ld1Nlc3Npb25cbiAgfVxuXG4gIC8vIFZhbGlkYXRlIHRoYXQgYSBzZXNzaW9uIGlzIHN0aWxsIHZhbGlkIGZvciB0aGUgY3VycmVudCByb29tIHN0YXRlXG4gIHByaXZhdGUgdmFsaWRhdGVTZXNzaW9uKHNlc3Npb246IFBsYXllclNlc3Npb24sIHJvb206IGFueSk6IGJvb2xlYW4ge1xuICAgIC8vIENoZWNrIGlmIHJvb20gc3RpbGwgZXhpc3RzIGFuZCBzZXNzaW9uIElEIG1hdGNoZXMgZXhwZWN0ZWQgcGxheWVyXG4gICAgaWYgKHNlc3Npb24ucGxheWVyUm9sZSA9PT0gJ3BsYXllcl9hJykge1xuICAgICAgcmV0dXJuIHJvb20ucGxheWVyX2FfaWQgPT09IHNlc3Npb24uc2Vzc2lvbklkXG4gICAgfSBlbHNlIGlmIChzZXNzaW9uLnBsYXllclJvbGUgPT09ICdwbGF5ZXJfYicpIHtcbiAgICAgIHJldHVybiByb29tLnBsYXllcl9iX2lkID09PSBzZXNzaW9uLnNlc3Npb25JZFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2Vzc2lvbi5wbGF5ZXJSb2xlID09PSAnc3BlY3RhdG9yJyAvLyBTcGVjdGF0b3JzIGFyZSBhbHdheXMgdmFsaWRcbiAgICB9XG4gIH1cblxuICAvLyBEZXRlcm1pbmUgcm9sZSBiYXNlZCBvbiByb29tIHN0YXRlIGFuZCBzZXNzaW9uIElEXG4gIHByaXZhdGUgYXN5bmMgZGV0ZXJtaW5lUm9sZUZyb21Sb29tKHJvb206IGFueSwgc2Vzc2lvbklkOiBzdHJpbmcpOiBQcm9taXNlPCdwbGF5ZXJfYScgfCAncGxheWVyX2InIHwgJ3NwZWN0YXRvcic+IHtcbiAgICBjb25zb2xlLmxvZygn8J+UjSBST0xFIE1BTkFHRVIgLSBEZXRlcm1pbmluZyByb2xlIGZyb20gcm9vbTonLCB7XG4gICAgICBzZXNzaW9uSWQ6IHNlc3Npb25JZC5zbGljZSgtOCksXG4gICAgICByb29tUGxheWVyQTogcm9vbS5wbGF5ZXJfYV9pZD8uc2xpY2UoLTgpLFxuICAgICAgcm9vbVBsYXllckI6IHJvb20ucGxheWVyX2JfaWQ/LnNsaWNlKC04KVxuICAgIH0pXG5cbiAgICAvLyBDaGVjayBkaXJlY3QgSUQgbWF0Y2hlcyBmaXJzdFxuICAgIGlmIChyb29tLnBsYXllcl9hX2lkID09PSBzZXNzaW9uSWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgUk9MRSBNQU5BR0VSIC0gTWF0Y2hlZCBhcyBQbGF5ZXIgQSBieSBJRCcpXG4gICAgICByZXR1cm4gJ3BsYXllcl9hJ1xuICAgIH1cbiAgICBcbiAgICBpZiAocm9vbS5wbGF5ZXJfYl9pZCA9PT0gc2Vzc2lvbklkKSB7XG4gICAgICBjb25zb2xlLmxvZygn4pyFIFJPTEUgTUFOQUdFUiAtIE1hdGNoZWQgYXMgUGxheWVyIEIgYnkgSUQnKVxuICAgICAgcmV0dXJuICdwbGF5ZXJfYidcbiAgICB9XG5cbiAgICAvLyBJZiBubyBtYXRjaCBmb3VuZCwgdXNlciBpcyBhIHNwZWN0YXRvclxuICAgIGNvbnNvbGUubG9nKCfwn5GAIFJPTEUgTUFOQUdFUiAtIE5vIG1hdGNoIGZvdW5kLCBhc3NpZ25lZCBhcyBzcGVjdGF0b3InKVxuICAgIHJldHVybiAnc3BlY3RhdG9yJ1xuICB9XG5cbiAgLy8gR2V0IGN1cnJlbnQgc2Vzc2lvbiAodXNlZCBieSBjb21wb25lbnRzKVxuICBnZXRDdXJyZW50U2Vzc2lvbigpOiBQbGF5ZXJTZXNzaW9uIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFNlc3Npb25cbiAgfVxuXG4gIC8vIExvY2sgdGhlIHJvbGUgb25jZSBnYW1lIHN0YXJ0cyAocHJldmVudHMgY2hhbmdlcyBkdXJpbmcgZ2FtZSlcbiAgbG9ja1JvbGUocm9vbUlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jdXJyZW50U2Vzc2lvbiAmJiB0aGlzLmN1cnJlbnRTZXNzaW9uLnJvb21JZCA9PT0gcm9vbUlkKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTZXNzaW9uLmlzTG9ja2VkID0gdHJ1ZVxuICAgICAgY29uc3Qgc2Vzc2lvbktleSA9IGBkZWJhdHRsZV9yb2xlXyR7cm9vbUlkfWBcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHNlc3Npb25LZXksIEpTT04uc3RyaW5naWZ5KHRoaXMuY3VycmVudFNlc3Npb24pKVxuICAgICAgY29uc29sZS5sb2coJ/CflJIgUk9MRSBNQU5BR0VSIC0gUm9sZSBsb2NrZWQgZm9yIGdhbWUgc2Vzc2lvbicpXG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYXIgcm9sZSB3aGVuIGxlYXZpbmcgcm9vbVxuICBjbGVhclJvbGUocm9vbUlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBzZXNzaW9uS2V5ID0gYGRlYmF0dGxlX3JvbGVfJHtyb29tSWR9YFxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHNlc3Npb25LZXkpXG4gICAgXG4gICAgaWYgKHRoaXMuY3VycmVudFNlc3Npb24gJiYgdGhpcy5jdXJyZW50U2Vzc2lvbi5yb29tSWQgPT09IHJvb21JZCkge1xuICAgICAgdGhpcy5jdXJyZW50U2Vzc2lvbiA9IG51bGxcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coJ/Cfp7kgUk9MRSBNQU5BR0VSIC0gQ2xlYXJlZCByb2xlIGZvciByb29tOicsIHJvb21JZC5zbGljZSgtOCkpXG4gIH1cblxuICAvLyBHZXQgc2Vzc2lvbiBJRCBmb3Igcm9vbSBzZXJ2aWNlIGNvbXBhdGliaWxpdHkgKGVuc3VyZXMgcHJvcGVyIFVVSUQgZm9ybWF0KVxuICBnZXRTZXNzaW9uSWQoKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy5jdXJyZW50U2Vzc2lvbiAmJiB0aGlzLmlzVmFsaWRVVUlEKHRoaXMuY3VycmVudFNlc3Npb24uc2Vzc2lvbklkKSkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFNlc3Npb24uc2Vzc2lvbklkXG4gICAgfVxuICAgIFxuICAgIC8vIEdlbmVyYXRlIG5ldyBVVUlEIGZvciB0aGlzIHRhYiBpZiBjdXJyZW50IHNlc3Npb24gaXMgaW52YWxpZFxuICAgIGNvbnN0IG5ld0lkID0gdGhpcy5nZW5lcmF0ZVRhYlNlc3Npb25JZCgpXG4gICAgY29uc29sZS5sb2coJ/CfhpUgUk9MRSBNQU5BR0VSIC0gVXNpbmcgdGFiIHNlc3Npb24gSUQ6JywgbmV3SWQuc2xpY2UoLTgpKVxuICAgIHJldHVybiBuZXdJZFxuICB9XG5cbiAgLy8gRGVidWcgaGVscGVyXG4gIGRlYnVnU2Vzc2lvbihyb29tSWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IHNlc3Npb25LZXkgPSBgZGViYXR0bGVfcm9sZV8ke3Jvb21JZH1gXG4gICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oc2Vzc2lvbktleSlcbiAgICBcbiAgICBjb25zb2xlLmxvZygn8J+UjSBST0xFIE1BTkFHRVIgREVCVUc6Jywge1xuICAgICAgY3VycmVudFNlc3Npb246IHRoaXMuY3VycmVudFNlc3Npb24sXG4gICAgICBzdG9yZWRTZXNzaW9uOiBzdG9yZWQgPyBKU09OLnBhcnNlKHN0b3JlZCkgOiBudWxsLFxuICAgICAgdGFiU2Vzc2lvbklkOiB0aGlzLnRhYlNlc3Npb25JZD8uc2xpY2UoLTgpLFxuICAgICAgYWxsRGViYXR0bGVLZXlzOiBPYmplY3Qua2V5cyhsb2NhbFN0b3JhZ2UpLmZpbHRlcihrID0+IGsuaW5jbHVkZXMoJ2RlYmF0dGxlJykpXG4gICAgfSlcbiAgfVxuXG4gIC8vIENsZWFuIHVwIGludmFsaWQgc2Vzc2lvbiBkYXRhXG4gIGNsZWFudXBJbnZhbGlkU2Vzc2lvbnMoKTogdm9pZCB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGxvY2FsU3RvcmFnZSkuZmlsdGVyKGsgPT4gay5pbmNsdWRlcygnZGViYXR0bGUnKSlcbiAgICBsZXQgY2xlYW5lZCA9IDBcbiAgICBcbiAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KVxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAvLyBGb3Igcm9sZSBzZXNzaW9ucywgY2hlY2sgaWYgdGhleSBoYXZlIHZhbGlkIFVVSURzXG4gICAgICAgICAgaWYgKGtleS5pbmNsdWRlcygnZGViYXR0bGVfcm9sZV8nKSkge1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IEpTT04ucGFyc2UodmFsdWUpXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZFVVSUQoc2Vzc2lvbi5zZXNzaW9uSWQpKSB7XG4gICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSlcbiAgICAgICAgICAgICAgY2xlYW5lZCsrXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn6e5IFJPTEUgTUFOQUdFUiAtIENsZWFuZWQgaW52YWxpZCBzZXNzaW9uOicsIGtleSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU2tpcCBnbG9iYWwgc2Vzc2lvbiBjbGVhbnVwIHNpbmNlIHdlJ3JlIHVzaW5nIHBlci10YWIgc2Vzc2lvbnMgbm93XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSlcbiAgICAgICAgY2xlYW5lZCsrXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn6e5IFJPTEUgTUFOQUdFUiAtIENsZWFuZWQgY29ycnVwdGVkIHNlc3Npb246Jywga2V5KVxuICAgICAgfVxuICAgIH0pXG4gICAgXG4gICAgaWYgKGNsZWFuZWQgPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+nuSBST0xFIE1BTkFHRVIgLSBDbGVhbmVkICR7Y2xlYW5lZH0gaW52YWxpZCBzZXNzaW9uc2ApXG4gICAgfVxuICB9XG5cbiAgLy8gRm9yY2UgZ2VuZXJhdGUgbmV3IHNlc3Npb24gKHVzZWZ1bCBmb3IgdGVzdGluZylcbiAgZm9yY2VOZXdTZXNzaW9uKCk6IHN0cmluZyB7XG4gICAgdGhpcy50YWJTZXNzaW9uSWQgPSBudWxsXG4gICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVUYWJTZXNzaW9uSWQoKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCByb2xlTWFuYWdlciA9IFJvbGVNYW5hZ2VyLmdldEluc3RhbmNlKClcblxuLy8gSW5pdGlhbGl6ZSBjbGVhbnVwIG9uIG1vZHVsZSBsb2FkXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9sZU1hbmFnZXIuY2xlYW51cEludmFsaWRTZXNzaW9ucygpXG59XG5cbi8vIEhlbHBlciBob29rIGZvciBSZWFjdCBjb21wb25lbnRzXG5leHBvcnQgZnVuY3Rpb24gdXNlUGxheWVyUm9sZShyb29tSWQ6IHN0cmluZywgcm9vbTogYW55KSB7XG4gIGNvbnN0IFtzZXNzaW9uLCBzZXRTZXNzaW9uXSA9IFJlYWN0LnVzZVN0YXRlPFBsYXllclNlc3Npb24gfCBudWxsPihudWxsKVxuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gUmVhY3QudXNlU3RhdGUodHJ1ZSlcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghcm9vbSkgcmV0dXJuXG5cbiAgICBjb25zdCBpbml0Um9sZSA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBsYXllclNlc3Npb24gPSBhd2FpdCByb2xlTWFuYWdlci5pbml0aWFsaXplUm9sZShyb29tSWQsIHJvb20pXG4gICAgICAgIHNldFNlc3Npb24ocGxheWVyU2Vzc2lvbilcbiAgICAgICAgXG4gICAgICAgIC8vIExvY2sgcm9sZSBpZiBnYW1lIGlzIGluIHByb2dyZXNzXG4gICAgICAgIGlmIChyb29tLnN0YXR1cyA9PT0gJ2RlYmF0aW5nJyAmJiAhcGxheWVyU2Vzc2lvbi5pc0xvY2tlZCkge1xuICAgICAgICAgIHJvbGVNYW5hZ2VyLmxvY2tSb2xlKHJvb21JZClcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5pdGlhbGl6aW5nIHJvbGU6JywgZXJyb3IpXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5pdFJvbGUoKVxuICB9LCBbcm9vbUlkLCByb29tPy5pZF0pIC8vIE9ubHkgcmUtcnVuIGlmIHJvb21JZCBvciByb29tLmlkIGNoYW5nZXNcblxuICByZXR1cm4geyBzZXNzaW9uLCBpc0xvYWRpbmcgfVxufVxuXG4vLyBDb21wYXRpYmlsaXR5IGZ1bmN0aW9ucyBmb3IgZXhpc3RpbmcgY29kZVxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0YWJsZVBsYXllclJvbGUocm9vbUlkOiBzdHJpbmcpOiAncGxheWVyX2EnIHwgJ3BsYXllcl9iJyB8ICdzcGVjdGF0b3InIHtcbiAgY29uc3Qgc2Vzc2lvbiA9IHJvbGVNYW5hZ2VyLmdldEN1cnJlbnRTZXNzaW9uKClcbiAgaWYgKHNlc3Npb24gJiYgc2Vzc2lvbi5yb29tSWQgPT09IHJvb21JZCkge1xuICAgIHJldHVybiBzZXNzaW9uLnBsYXllclJvbGVcbiAgfVxuICByZXR1cm4gJ3NwZWN0YXRvcidcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0YWJsZVNlc3Npb25JZCgpOiBzdHJpbmcge1xuICByZXR1cm4gcm9sZU1hbmFnZXIuZ2V0U2Vzc2lvbklkKClcbn0iXSwibmFtZXMiOlsiUmVhY3QiLCJnZW5lcmF0ZVVVSUQiLCJjcnlwdG8iLCJyYW5kb21VVUlEIiwicmVwbGFjZSIsImMiLCJyIiwiTWF0aCIsInJhbmRvbSIsInYiLCJ0b1N0cmluZyIsIlJvbGVNYW5hZ2VyIiwiZ2V0SW5zdGFuY2UiLCJpbnN0YW5jZSIsImdlbmVyYXRlVGFiU2Vzc2lvbklkIiwidGFiU2Vzc2lvbklkIiwiY29uc29sZSIsImxvZyIsInNsaWNlIiwiaXNWYWxpZFVVSUQiLCJ1dWlkIiwidXVpZFJlZ2V4IiwidGVzdCIsImluaXRpYWxpemVSb2xlIiwicm9vbUlkIiwicm9vbSIsInNlc3Npb25LZXkiLCJleGlzdGluZ1Nlc3Npb24iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwicGFyc2VkIiwiSlNPTiIsInBhcnNlIiwic2Vzc2lvbklkIiwidmFsaWRhdGVTZXNzaW9uIiwicm9sZSIsInBsYXllclJvbGUiLCJpc0xvY2tlZCIsImN1cnJlbnRTZXNzaW9uIiwicmVtb3ZlSXRlbSIsImVycm9yIiwiZGV0ZXJtaW5lUm9sZUZyb21Sb29tIiwibmV3U2Vzc2lvbiIsImFzc2lnbmVkQXQiLCJEYXRlIiwibm93Iiwic3RhdHVzIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsInJvb21TdGF0dXMiLCJzZXNzaW9uIiwicGxheWVyX2FfaWQiLCJwbGF5ZXJfYl9pZCIsInJvb21QbGF5ZXJBIiwicm9vbVBsYXllckIiLCJnZXRDdXJyZW50U2Vzc2lvbiIsImxvY2tSb2xlIiwiY2xlYXJSb2xlIiwiZ2V0U2Vzc2lvbklkIiwibmV3SWQiLCJkZWJ1Z1Nlc3Npb24iLCJzdG9yZWQiLCJzdG9yZWRTZXNzaW9uIiwiYWxsRGViYXR0bGVLZXlzIiwiT2JqZWN0Iiwia2V5cyIsImZpbHRlciIsImsiLCJpbmNsdWRlcyIsImNsZWFudXBJbnZhbGlkU2Vzc2lvbnMiLCJjbGVhbmVkIiwiZm9yRWFjaCIsImtleSIsInZhbHVlIiwiZm9yY2VOZXdTZXNzaW9uIiwicm9sZU1hbmFnZXIiLCJ1c2VQbGF5ZXJSb2xlIiwic2V0U2Vzc2lvbiIsInVzZVN0YXRlIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwidXNlRWZmZWN0IiwiaW5pdFJvbGUiLCJwbGF5ZXJTZXNzaW9uIiwiaWQiLCJnZXRTdGFibGVQbGF5ZXJSb2xlIiwiZ2V0U3RhYmxlU2Vzc2lvbklkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/roleManager.ts\n"));

/***/ })

});