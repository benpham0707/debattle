"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/room/[id]/page",{

/***/ "(app-pages-browser)/./src/lib/roomService.ts":
/*!********************************!*\
  !*** ./src/lib/roomService.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   roomService: function() { return /* binding */ roomService; }\n/* harmony export */ });\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n\n// List of debate topics for the MVP\nconst DEBATE_TOPICS = [\n    \"Should AI be regulated?\",\n    \"Is social media harmful to democracy?\",\n    \"Should college education be free?\",\n    \"Is remote work better than office work?\",\n    \"Should voting be mandatory?\"\n];\n// Helper function to generate a proper UUID v4\nfunction generateUUID() {\n    // Use crypto.randomUUID if available (modern browsers)\n    if (typeof crypto !== \"undefined\" && crypto.randomUUID) {\n        return crypto.randomUUID();\n    }\n    // Fallback to manual generation\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n        const r = Math.random() * 16 | 0;\n        const v = c === \"x\" ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n    });\n}\n// Store session ID globally for this browser session\nlet currentSessionId = null;\nconst roomService = {\n    // Helper to get current Supabase user ID\n    async getUserId () {\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (error || !(data === null || data === void 0 ? void 0 : data.user)) {\n            return null;\n        }\n        return data.user.id;\n    },\n    // Get or create session ID for this browser session\n    getSessionId () {\n        if (!currentSessionId) {\n            currentSessionId = generateUUID();\n            console.log(\"Generated new session ID:\", currentSessionId);\n        }\n        return currentSessionId;\n    },\n    // Create a new room\n    async createRoom () {\n        let userId = await this.getUserId();\n        console.log(\"Original user ID:\", userId);\n        // If no authenticated user, use session UUID for guests\n        if (!userId) {\n            userId = this.getSessionId();\n            console.log(\"Using session UUID for room creator:\", userId);\n        }\n        const randomTopic = DEBATE_TOPICS[Math.floor(Math.random() * DEBATE_TOPICS.length)];\n        console.log(\"Creating room with user ID:\", userId);\n        console.log(\"User ID type:\", typeof userId, \"Length:\", userId.length);\n        const roomData = {\n            topic: randomTopic,\n            status: \"waiting\",\n            player_a_health: 100,\n            player_b_health: 100,\n            player_a_ready: false,\n            player_b_ready: false,\n            player_a_id: userId\n        };\n        console.log(\"Room data to insert:\", roomData);\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").insert([\n            roomData\n        ]).select().single();\n        if (error) {\n            console.error(\"Error creating room:\", error);\n            throw new Error(\"Failed to create room: \".concat(error.message));\n        }\n        console.log(\"Successfully created room:\", data);\n        return {\n            room: data,\n            playerRole: \"player_a\"\n        };\n    },\n    // Join an existing room with proper error handling\n    async joinRoom (roomId, userId) {\n        try {\n            // Use provided userId or get current user ID or use session ID\n            let actualUserId = userId || await this.getUserId();\n            if (!actualUserId) {\n                actualUserId = this.getSessionId();\n                console.log(\"Using session UUID for room joiner:\", actualUserId);\n            }\n            console.log(\"Join room attempt with user ID:\", actualUserId);\n            console.log(\"User ID type:\", typeof actualUserId, \"Length:\", actualUserId.length);\n            // Validate UUID format\n            const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n            if (!uuidRegex.test(actualUserId)) {\n                console.error(\"Invalid UUID format:\", actualUserId);\n                // Generate a new proper UUID\n                actualUserId = generateUUID();\n                console.log(\"Generated new UUID:\", actualUserId);\n            }\n            // First, check if the room exists and get its current state\n            const { data: currentRoom, error: fetchError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").select(\"*\").eq(\"id\", roomId).single();\n            if (fetchError) {\n                console.error(\"Error fetching room:\", fetchError);\n                if (fetchError.code === \"PGRST116\") {\n                    throw new Error(\"Room not found\");\n                }\n                throw new Error(\"Database error: \".concat(fetchError.message));\n            }\n            if (!currentRoom) {\n                throw new Error(\"Room not found\");\n            }\n            console.log(\"Current room state:\", {\n                id: currentRoom.id,\n                player_a_id: currentRoom.player_a_id,\n                player_b_id: currentRoom.player_b_id,\n                status: currentRoom.status\n            });\n            // Check if user is already in the room\n            if (currentRoom.player_a_id === actualUserId) {\n                console.log(\"User already in room as Player A\");\n                return {\n                    room: currentRoom,\n                    playerRole: \"player_a\"\n                };\n            }\n            if (currentRoom.player_b_id === actualUserId) {\n                console.log(\"User already in room as Player B\");\n                return {\n                    room: currentRoom,\n                    playerRole: \"player_b\"\n                };\n            }\n            // Check if room is full\n            if (currentRoom.player_a_id && currentRoom.player_b_id) {\n                throw new Error(\"Room is full\");\n            }\n            // Determine which slot to fill\n            let updateData;\n            let playerRole;\n            if (!currentRoom.player_a_id) {\n                updateData = {\n                    player_a_id: actualUserId,\n                    player_a_ready: false\n                };\n                playerRole = \"player_a\";\n                console.log(\"Joining as Player A\");\n            } else {\n                updateData = {\n                    player_b_id: actualUserId,\n                    player_b_ready: false\n                };\n                playerRole = \"player_b\";\n                console.log(\"Joining as Player B\");\n            }\n            console.log(\"Update data:\", updateData);\n            // Update the room\n            const { data: updatedRoom, error: updateError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").update(updateData).eq(\"id\", roomId).select().single();\n            if (updateError) {\n                console.error(\"Error updating room:\", updateError);\n                throw new Error(\"Failed to join room: \".concat(updateError.message));\n            }\n            if (!updatedRoom) {\n                throw new Error(\"Failed to update room - no data returned\");\n            }\n            console.log(\"Successfully joined room as:\", playerRole);\n            console.log(\"Updated room:\", updatedRoom);\n            return {\n                room: updatedRoom,\n                playerRole\n            };\n        } catch (error) {\n            console.error(\"Join room error:\", error);\n            throw error;\n        }\n    },\n    // Ready up for the game\n    async readyUp (roomId) {\n        try {\n            let userId = await this.getUserId();\n            if (!userId) {\n                userId = this.getSessionId();\n            }\n            console.log(\"Ready up with user ID:\", userId);\n            // Get current room state\n            const { data: room, error: fetchError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").select(\"*\").eq(\"id\", roomId).single();\n            if (fetchError || !room) {\n                console.error(\"Error fetching room for ready up:\", fetchError);\n                throw new Error(\"Room not found\");\n            }\n            console.log(\"Current room for ready up:\", {\n                player_a_id: room.player_a_id,\n                player_b_id: room.player_b_id,\n                player_a_ready: room.player_a_ready,\n                player_b_ready: room.player_b_ready\n            });\n            // Determine which player is ready-ing up\n            let updateData = {};\n            if (room.player_a_id === userId) {\n                updateData.player_a_ready = true;\n                console.log(\"Player A readying up\");\n            } else if (room.player_b_id === userId) {\n                updateData.player_b_ready = true;\n                console.log(\"Player B readying up\");\n            } else {\n                console.error(\"User not found in room\");\n                console.error(\"Room player A ID:\", room.player_a_id);\n                console.error(\"Room player B ID:\", room.player_b_id);\n                console.error(\"Current user ID:\", userId);\n                throw new Error(\"You are not in this room\");\n            }\n            // Check if both players will be ready after this update\n            const bothReady = (room.player_a_id === userId ? true : room.player_a_ready) && (room.player_b_id === userId ? true : room.player_b_ready);\n            console.log(\"Both players ready after update:\", bothReady);\n            // If both players are ready and present, start the game\n            if (bothReady && room.player_a_id && room.player_b_id) {\n                updateData.status = \"debating\";\n                console.log(\"Setting status to debating\");\n            }\n            // Update the room\n            const { data, error: updateError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").update(updateData).eq(\"id\", roomId).select().single();\n            if (updateError) {\n                console.error(\"Error readying up:\", updateError);\n                throw new Error(\"Failed to ready up: \".concat(updateError.message));\n            }\n            console.log(\"Successfully readied up\");\n            return data;\n        } catch (error) {\n            console.error(\"Ready up error:\", error);\n            throw error;\n        }\n    },\n    // Unready\n    async unready (roomId) {\n        try {\n            let userId = await this.getUserId();\n            if (!userId) {\n                userId = this.getSessionId();\n            }\n            const { data: room, error: fetchError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").select(\"*\").eq(\"id\", roomId).single();\n            if (fetchError || !room) {\n                throw new Error(\"Room not found\");\n            }\n            let updateData = {};\n            if (room.player_a_id === userId) {\n                updateData.player_a_ready = false;\n            } else if (room.player_b_id === userId) {\n                updateData.player_b_ready = false;\n            } else {\n                throw new Error(\"You are not in this room\");\n            }\n            // If game was about to start, keep it in waiting status\n            if (room.status === \"debating\") {\n                updateData.status = \"waiting\";\n            }\n            const { data, error: updateError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").update(updateData).eq(\"id\", roomId).select().single();\n            if (updateError) {\n                console.error(\"Error unreadying:\", updateError);\n                throw new Error(\"Failed to unready: \".concat(updateError.message));\n            }\n            return data;\n        } catch (error) {\n            console.error(\"Unready error:\", error);\n            throw error;\n        }\n    },\n    // Leave room\n    async leaveRoom (roomId) {\n        try {\n            let userId = await this.getUserId();\n            if (!userId) {\n                userId = this.getSessionId();\n            }\n            const { data: room, error: fetchError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").select(\"*\").eq(\"id\", roomId).single();\n            if (fetchError || !room) {\n                throw new Error(\"Room not found\");\n            }\n            let updateData = {};\n            if (room.player_a_id === userId) {\n                updateData.player_a_id = null;\n                updateData.player_a_ready = false;\n            } else if (room.player_b_id === userId) {\n                updateData.player_b_id = null;\n                updateData.player_b_ready = false;\n            } else {\n                throw new Error(\"You are not in this room\");\n            }\n            // Reset room status to waiting\n            updateData.status = \"waiting\";\n            const { error: updateError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").update(updateData).eq(\"id\", roomId);\n            if (updateError) {\n                console.error(\"Error leaving room:\", updateError);\n                throw new Error(\"Failed to leave room: \".concat(updateError.message));\n            }\n            return true;\n        } catch (error) {\n            console.error(\"Leave room error:\", error);\n            throw error;\n        }\n    },\n    // Get room details\n    async getRoom (roomId) {\n        try {\n            const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").select(\"*\").eq(\"id\", roomId).single();\n            if (error) {\n                console.error(\"Error fetching room:\", error);\n                if (error.code === \"PGRST116\") {\n                    return null // Room not found\n                    ;\n                }\n                throw error;\n            }\n            return data;\n        } catch (error) {\n            console.error(\"Get room error:\", error);\n            return null;\n        }\n    },\n    // Enhanced subscription with better error handling\n    subscribeToRoom (roomId, callback) {\n        console.log(\"Setting up subscription for room:\", roomId);\n        const channel = _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.channel(\"room:\".concat(roomId, \":\").concat(Date.now())).on(\"postgres_changes\", {\n            event: \"*\",\n            schema: \"public\",\n            table: \"rooms\",\n            filter: \"id=eq.\".concat(roomId)\n        }, (payload)=>{\n            console.log(\"\\uD83D\\uDD04 Real-time update received:\", {\n                event: payload.eventType,\n                new: payload.new ? {\n                    id: payload.new.id,\n                    player_a_id: payload.new.player_a_id ? payload.new.player_a_id.slice(-8) : null,\n                    player_b_id: payload.new.player_b_id ? payload.new.player_b_id.slice(-8) : null,\n                    status: payload.new.status\n                } : null\n            });\n            if (payload.new) {\n                callback(payload.new);\n            }\n        }).subscribe((status, error)=>{\n            console.log(\"Subscription status:\", status);\n            if (error) {\n                console.error(\"Subscription error:\", error);\n            }\n            if (status === \"SUBSCRIBED\") {\n                console.log(\"✅ Successfully subscribed to room updates\");\n            }\n        });\n        return channel;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvcm9vbVNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUM7QUFHckMsb0NBQW9DO0FBQ3BDLE1BQU1DLGdCQUFnQjtJQUNwQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFRCwrQ0FBK0M7QUFDL0MsU0FBU0M7SUFDUCx1REFBdUQ7SUFDdkQsSUFBSSxPQUFPQyxXQUFXLGVBQWVBLE9BQU9DLFVBQVUsRUFBRTtRQUN0RCxPQUFPRCxPQUFPQyxVQUFVO0lBQzFCO0lBRUEsZ0NBQWdDO0lBQ2hDLE9BQU8sdUNBQXVDQyxPQUFPLENBQUMsU0FBUyxTQUFTQyxDQUFDO1FBQ3ZFLE1BQU1DLElBQUksS0FBTUUsTUFBTSxLQUFLLEtBQU07UUFDakMsTUFBTUMsSUFBSUosTUFBTSxNQUFNQyxJQUFJLElBQUssTUFBTztRQUN0QyxPQUFPRyxFQUFFQyxRQUFRLENBQUM7SUFDcEI7QUFDRjtBQUVBLHFEQUFxRDtBQUNyRCxJQUFJQyxtQkFBa0M7QUFFL0IsTUFBTUMsY0FBYztJQUN6Qix5Q0FBeUM7SUFDekMsTUFBTUM7UUFDSixNQUFNLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTWhCLCtDQUFRQSxDQUFDaUIsSUFBSSxDQUFDQyxPQUFPO1FBQ25ELElBQUlGLFNBQVMsRUFBQ0QsaUJBQUFBLDJCQUFBQSxLQUFNSSxJQUFJLEdBQUU7WUFDeEIsT0FBTztRQUNUO1FBQ0EsT0FBT0osS0FBS0ksSUFBSSxDQUFDQyxFQUFFO0lBQ3JCO0lBRUEsb0RBQW9EO0lBQ3BEQztRQUNFLElBQUksQ0FBQ1Qsa0JBQWtCO1lBQ3JCQSxtQkFBbUJWO1lBQ25Cb0IsUUFBUUMsR0FBRyxDQUFDLDZCQUE2Qlg7UUFDM0M7UUFDQSxPQUFPQTtJQUNUO0lBRUEsb0JBQW9CO0lBQ3BCLE1BQU1ZO1FBQ0osSUFBSUMsU0FBUyxNQUFNLElBQUksQ0FBQ1gsU0FBUztRQUVqQ1EsUUFBUUMsR0FBRyxDQUFDLHFCQUFx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S0FBSztvQkFDM0U5QyxRQUFRMkMsUUFBUUUsR0FBRyxDQUFDN0MsTUFBTTtnQkFDNUIsSUFBSTtZQUNOO1lBRUEsSUFBSTJDLFFBQVFFLEdBQUcsRUFBRTtnQkFDZlgsU0FBU1MsUUFBUUUsR0FBRztZQUN0QjtRQUNGLEdBRURFLFNBQVMsQ0FBQyxDQUFDL0MsUUFBZ0JmO1lBQzFCTSxRQUFRQyxHQUFHLENBQUMsd0JBQXdCUTtZQUNwQyxJQUFJZixPQUFPO2dCQUNUTSxRQUFRTixLQUFLLENBQUMsdUJBQXVCQTtZQUN2QztZQUVBLElBQUllLFdBQVcsY0FBYztnQkFDM0JULFFBQVFDLEdBQUcsQ0FBQztZQUNkO1FBQ0Y7UUFFRixPQUFPMkM7SUFDVDtBQUNGLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9yb29tU2VydmljZS50cz9iZTEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN1cGFiYXNlIH0gZnJvbSAnLi9zdXBhYmFzZSdcbmltcG9ydCB7IFJvb20gfSBmcm9tICcuL3N1cGFiYXNlJ1xuXG4vLyBMaXN0IG9mIGRlYmF0ZSB0b3BpY3MgZm9yIHRoZSBNVlBcbmNvbnN0IERFQkFURV9UT1BJQ1MgPSBbXG4gIFwiU2hvdWxkIEFJIGJlIHJlZ3VsYXRlZD9cIixcbiAgXCJJcyBzb2NpYWwgbWVkaWEgaGFybWZ1bCB0byBkZW1vY3JhY3k/XCIsXG4gIFwiU2hvdWxkIGNvbGxlZ2UgZWR1Y2F0aW9uIGJlIGZyZWU/XCIsXG4gIFwiSXMgcmVtb3RlIHdvcmsgYmV0dGVyIHRoYW4gb2ZmaWNlIHdvcms/XCIsXG4gIFwiU2hvdWxkIHZvdGluZyBiZSBtYW5kYXRvcnk/XCIsXG5dXG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSBhIHByb3BlciBVVUlEIHY0XG5mdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKTogc3RyaW5nIHtcbiAgLy8gVXNlIGNyeXB0by5yYW5kb21VVUlEIGlmIGF2YWlsYWJsZSAobW9kZXJuIGJyb3dzZXJzKVxuICBpZiAodHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLnJhbmRvbVVVSUQpIHtcbiAgICByZXR1cm4gY3J5cHRvLnJhbmRvbVVVSUQoKVxuICB9XG4gIFxuICAvLyBGYWxsYmFjayB0byBtYW51YWwgZ2VuZXJhdGlvblxuICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XG4gICAgY29uc3QgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMFxuICAgIGNvbnN0IHYgPSBjID09PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4XG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpXG4gIH0pXG59XG5cbi8vIFN0b3JlIHNlc3Npb24gSUQgZ2xvYmFsbHkgZm9yIHRoaXMgYnJvd3NlciBzZXNzaW9uXG5sZXQgY3VycmVudFNlc3Npb25JZDogc3RyaW5nIHwgbnVsbCA9IG51bGxcblxuZXhwb3J0IGNvbnN0IHJvb21TZXJ2aWNlID0ge1xuICAvLyBIZWxwZXIgdG8gZ2V0IGN1cnJlbnQgU3VwYWJhc2UgdXNlciBJRFxuICBhc3luYyBnZXRVc2VySWQoKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKClcbiAgICBpZiAoZXJyb3IgfHwgIWRhdGE/LnVzZXIpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHJldHVybiBkYXRhLnVzZXIuaWRcbiAgfSxcblxuICAvLyBHZXQgb3IgY3JlYXRlIHNlc3Npb24gSUQgZm9yIHRoaXMgYnJvd3NlciBzZXNzaW9uXG4gIGdldFNlc3Npb25JZCgpOiBzdHJpbmcge1xuICAgIGlmICghY3VycmVudFNlc3Npb25JZCkge1xuICAgICAgY3VycmVudFNlc3Npb25JZCA9IGdlbmVyYXRlVVVJRCgpXG4gICAgICBjb25zb2xlLmxvZygnR2VuZXJhdGVkIG5ldyBzZXNzaW9uIElEOicsIGN1cnJlbnRTZXNzaW9uSWQpXG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50U2Vzc2lvbklkXG4gIH0sXG5cbiAgLy8gQ3JlYXRlIGEgbmV3IHJvb21cbiAgYXN5bmMgY3JlYXRlUm9vbSgpOiBQcm9taXNlPHsgcm9vbTogUm9vbTsgcGxheWVyUm9sZTogJ3BsYXllcl9hJyB8ICdwbGF5ZXJfYicgfT4ge1xuICAgIGxldCB1c2VySWQgPSBhd2FpdCB0aGlzLmdldFVzZXJJZCgpXG4gICAgXG4gICAgY29uc29sZS5sb2coJ09yaWdpbmFsIHVzZXIgSUQ6JywgdXNlcklkKVxuICAgIFxuICAgIC8vIElmIG5vIGF1dGhlbnRpY2F0ZWQgdXNlciwgdXNlIHNlc3Npb24gVVVJRCBmb3IgZ3Vlc3RzXG4gICAgaWYgKCF1c2VySWQpIHtcbiAgICAgIHVzZXJJZCA9IHRoaXMuZ2V0U2Vzc2lvbklkKClcbiAgICAgIGNvbnNvbGUubG9nKCdVc2luZyBzZXNzaW9uIFVVSUQgZm9yIHJvb20gY3JlYXRvcjonLCB1c2VySWQpXG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHJhbmRvbVRvcGljID0gREVCQVRFX1RPUElDU1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBERUJBVEVfVE9QSUNTLmxlbmd0aCldXG5cbiAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgcm9vbSB3aXRoIHVzZXIgSUQ6JywgdXNlcklkKVxuICAgIGNvbnNvbGUubG9nKCdVc2VyIElEIHR5cGU6JywgdHlwZW9mIHVzZXJJZCwgJ0xlbmd0aDonLCB1c2VySWQubGVuZ3RoKVxuXG4gICAgY29uc3Qgcm9vbURhdGEgPSB7XG4gICAgICB0b3BpYzogcmFuZG9tVG9waWMsXG4gICAgICBzdGF0dXM6ICd3YWl0aW5nJyBhcyBjb25zdCxcbiAgICAgIHBsYXllcl9hX2hlYWx0aDogMTAwLFxuICAgICAgcGxheWVyX2JfaGVhbHRoOiAxMDAsXG4gICAgICBwbGF5ZXJfYV9yZWFkeTogZmFsc2UsXG4gICAgICBwbGF5ZXJfYl9yZWFkeTogZmFsc2UsXG4gICAgICBwbGF5ZXJfYV9pZDogdXNlcklkLFxuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZygnUm9vbSBkYXRhIHRvIGluc2VydDonLCByb29tRGF0YSlcblxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgncm9vbXMnKVxuICAgICAgLmluc2VydChbcm9vbURhdGFdKVxuICAgICAgLnNlbGVjdCgpXG4gICAgICAuc2luZ2xlKClcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgcm9vbTonLCBlcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSByb29tOiAke2Vycm9yLm1lc3NhZ2V9YClcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IGNyZWF0ZWQgcm9vbTonLCBkYXRhKVxuICAgIHJldHVybiB7IHJvb206IGRhdGEsIHBsYXllclJvbGU6ICdwbGF5ZXJfYScgfVxuICB9LFxuXG4gIC8vIEpvaW4gYW4gZXhpc3Rpbmcgcm9vbSB3aXRoIHByb3BlciBlcnJvciBoYW5kbGluZ1xuICBhc3luYyBqb2luUm9vbShyb29tSWQ6IHN0cmluZywgdXNlcklkPzogc3RyaW5nKTogUHJvbWlzZTx7IHJvb206IFJvb207IHBsYXllclJvbGU6ICdwbGF5ZXJfYScgfCAncGxheWVyX2InIH0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gVXNlIHByb3ZpZGVkIHVzZXJJZCBvciBnZXQgY3VycmVudCB1c2VyIElEIG9yIHVzZSBzZXNzaW9uIElEXG4gICAgICBsZXQgYWN0dWFsVXNlcklkID0gdXNlcklkIHx8IGF3YWl0IHRoaXMuZ2V0VXNlcklkKClcbiAgICAgIGlmICghYWN0dWFsVXNlcklkKSB7XG4gICAgICAgIGFjdHVhbFVzZXJJZCA9IHRoaXMuZ2V0U2Vzc2lvbklkKClcbiAgICAgICAgY29uc29sZS5sb2coJ1VzaW5nIHNlc3Npb24gVVVJRCBmb3Igcm9vbSBqb2luZXI6JywgYWN0dWFsVXNlcklkKVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnSm9pbiByb29tIGF0dGVtcHQgd2l0aCB1c2VyIElEOicsIGFjdHVhbFVzZXJJZClcbiAgICAgIGNvbnNvbGUubG9nKCdVc2VyIElEIHR5cGU6JywgdHlwZW9mIGFjdHVhbFVzZXJJZCwgJ0xlbmd0aDonLCBhY3R1YWxVc2VySWQubGVuZ3RoKVxuXG4gICAgICAvLyBWYWxpZGF0ZSBVVUlEIGZvcm1hdFxuICAgICAgY29uc3QgdXVpZFJlZ2V4ID0gL15bMC05YS1mXXs4fS1bMC05YS1mXXs0fS00WzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9JC9pXG4gICAgICBpZiAoIXV1aWRSZWdleC50ZXN0KGFjdHVhbFVzZXJJZCkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBVVUlEIGZvcm1hdDonLCBhY3R1YWxVc2VySWQpXG4gICAgICAgIC8vIEdlbmVyYXRlIGEgbmV3IHByb3BlciBVVUlEXG4gICAgICAgIGFjdHVhbFVzZXJJZCA9IGdlbmVyYXRlVVVJRCgpXG4gICAgICAgIGNvbnNvbGUubG9nKCdHZW5lcmF0ZWQgbmV3IFVVSUQ6JywgYWN0dWFsVXNlcklkKVxuICAgICAgfVxuXG4gICAgICAvLyBGaXJzdCwgY2hlY2sgaWYgdGhlIHJvb20gZXhpc3RzIGFuZCBnZXQgaXRzIGN1cnJlbnQgc3RhdGVcbiAgICAgIGNvbnN0IHsgZGF0YTogY3VycmVudFJvb20sIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncm9vbXMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCdpZCcsIHJvb21JZClcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIGlmIChmZXRjaEVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHJvb206JywgZmV0Y2hFcnJvcilcbiAgICAgICAgaWYgKGZldGNoRXJyb3IuY29kZSA9PT0gJ1BHUlNUMTE2Jykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUm9vbSBub3QgZm91bmQnKVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRGF0YWJhc2UgZXJyb3I6ICR7ZmV0Y2hFcnJvci5tZXNzYWdlfWApXG4gICAgICB9XG5cbiAgICAgIGlmICghY3VycmVudFJvb20pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSb29tIG5vdCBmb3VuZCcpXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdDdXJyZW50IHJvb20gc3RhdGU6Jywge1xuICAgICAgICBpZDogY3VycmVudFJvb20uaWQsXG4gICAgICAgIHBsYXllcl9hX2lkOiBjdXJyZW50Um9vbS5wbGF5ZXJfYV9pZCxcbiAgICAgICAgcGxheWVyX2JfaWQ6IGN1cnJlbnRSb29tLnBsYXllcl9iX2lkLFxuICAgICAgICBzdGF0dXM6IGN1cnJlbnRSb29tLnN0YXR1c1xuICAgICAgfSlcblxuICAgICAgLy8gQ2hlY2sgaWYgdXNlciBpcyBhbHJlYWR5IGluIHRoZSByb29tXG4gICAgICBpZiAoY3VycmVudFJvb20ucGxheWVyX2FfaWQgPT09IGFjdHVhbFVzZXJJZCkge1xuICAgICAgICBjb25zb2xlLmxvZygnVXNlciBhbHJlYWR5IGluIHJvb20gYXMgUGxheWVyIEEnKVxuICAgICAgICByZXR1cm4geyByb29tOiBjdXJyZW50Um9vbSwgcGxheWVyUm9sZTogJ3BsYXllcl9hJyB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChjdXJyZW50Um9vbS5wbGF5ZXJfYl9pZCA9PT0gYWN0dWFsVXNlcklkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdVc2VyIGFscmVhZHkgaW4gcm9vbSBhcyBQbGF5ZXIgQicpXG4gICAgICAgIHJldHVybiB7IHJvb206IGN1cnJlbnRSb29tLCBwbGF5ZXJSb2xlOiAncGxheWVyX2InIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgcm9vbSBpcyBmdWxsXG4gICAgICBpZiAoY3VycmVudFJvb20ucGxheWVyX2FfaWQgJiYgY3VycmVudFJvb20ucGxheWVyX2JfaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSb29tIGlzIGZ1bGwnKVxuICAgICAgfVxuXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggc2xvdCB0byBmaWxsXG4gICAgICBsZXQgdXBkYXRlRGF0YTogYW55XG4gICAgICBsZXQgcGxheWVyUm9sZTogJ3BsYXllcl9hJyB8ICdwbGF5ZXJfYidcblxuICAgICAgaWYgKCFjdXJyZW50Um9vbS5wbGF5ZXJfYV9pZCkge1xuICAgICAgICB1cGRhdGVEYXRhID0geyBcbiAgICAgICAgICBwbGF5ZXJfYV9pZDogYWN0dWFsVXNlcklkLFxuICAgICAgICAgIHBsYXllcl9hX3JlYWR5OiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIHBsYXllclJvbGUgPSAncGxheWVyX2EnXG4gICAgICAgIGNvbnNvbGUubG9nKCdKb2luaW5nIGFzIFBsYXllciBBJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZURhdGEgPSB7IFxuICAgICAgICAgIHBsYXllcl9iX2lkOiBhY3R1YWxVc2VySWQsXG4gICAgICAgICAgcGxheWVyX2JfcmVhZHk6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgcGxheWVyUm9sZSA9ICdwbGF5ZXJfYidcbiAgICAgICAgY29uc29sZS5sb2coJ0pvaW5pbmcgYXMgUGxheWVyIEInKVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnVXBkYXRlIGRhdGE6JywgdXBkYXRlRGF0YSlcblxuICAgICAgLy8gVXBkYXRlIHRoZSByb29tXG4gICAgICBjb25zdCB7IGRhdGE6IHVwZGF0ZWRSb29tLCBlcnJvcjogdXBkYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdyb29tcycpXG4gICAgICAgIC51cGRhdGUodXBkYXRlRGF0YSlcbiAgICAgICAgLmVxKCdpZCcsIHJvb21JZClcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBpZiAodXBkYXRlRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgcm9vbTonLCB1cGRhdGVFcnJvcilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gam9pbiByb29tOiAke3VwZGF0ZUVycm9yLm1lc3NhZ2V9YClcbiAgICAgIH1cblxuICAgICAgaWYgKCF1cGRhdGVkUm9vbSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byB1cGRhdGUgcm9vbSAtIG5vIGRhdGEgcmV0dXJuZWQnKVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IGpvaW5lZCByb29tIGFzOicsIHBsYXllclJvbGUpXG4gICAgICBjb25zb2xlLmxvZygnVXBkYXRlZCByb29tOicsIHVwZGF0ZWRSb29tKVxuXG4gICAgICByZXR1cm4geyByb29tOiB1cGRhdGVkUm9vbSwgcGxheWVyUm9sZSB9XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignSm9pbiByb29tIGVycm9yOicsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH0sXG5cbiAgLy8gUmVhZHkgdXAgZm9yIHRoZSBnYW1lXG4gIGFzeW5jIHJlYWR5VXAocm9vbUlkOiBzdHJpbmcpOiBQcm9taXNlPFJvb20gfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCB1c2VySWQgPSBhd2FpdCB0aGlzLmdldFVzZXJJZCgpXG4gICAgICBpZiAoIXVzZXJJZCkge1xuICAgICAgICB1c2VySWQgPSB0aGlzLmdldFNlc3Npb25JZCgpXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdSZWFkeSB1cCB3aXRoIHVzZXIgSUQ6JywgdXNlcklkKVxuICAgICAgXG4gICAgICAvLyBHZXQgY3VycmVudCByb29tIHN0YXRlXG4gICAgICBjb25zdCB7IGRhdGE6IHJvb20sIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncm9vbXMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCdpZCcsIHJvb21JZClcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIGlmIChmZXRjaEVycm9yIHx8ICFyb29tKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHJvb20gZm9yIHJlYWR5IHVwOicsIGZldGNoRXJyb3IpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUm9vbSBub3QgZm91bmQnKVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnQ3VycmVudCByb29tIGZvciByZWFkeSB1cDonLCB7XG4gICAgICAgIHBsYXllcl9hX2lkOiByb29tLnBsYXllcl9hX2lkLFxuICAgICAgICBwbGF5ZXJfYl9pZDogcm9vbS5wbGF5ZXJfYl9pZCxcbiAgICAgICAgcGxheWVyX2FfcmVhZHk6IHJvb20ucGxheWVyX2FfcmVhZHksXG4gICAgICAgIHBsYXllcl9iX3JlYWR5OiByb29tLnBsYXllcl9iX3JlYWR5XG4gICAgICB9KVxuXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggcGxheWVyIGlzIHJlYWR5LWluZyB1cFxuICAgICAgbGV0IHVwZGF0ZURhdGE6IGFueSA9IHt9XG4gICAgICBcbiAgICAgIGlmIChyb29tLnBsYXllcl9hX2lkID09PSB1c2VySWQpIHtcbiAgICAgICAgdXBkYXRlRGF0YS5wbGF5ZXJfYV9yZWFkeSA9IHRydWVcbiAgICAgICAgY29uc29sZS5sb2coJ1BsYXllciBBIHJlYWR5aW5nIHVwJylcbiAgICAgIH0gZWxzZSBpZiAocm9vbS5wbGF5ZXJfYl9pZCA9PT0gdXNlcklkKSB7XG4gICAgICAgIHVwZGF0ZURhdGEucGxheWVyX2JfcmVhZHkgPSB0cnVlXG4gICAgICAgIGNvbnNvbGUubG9nKCdQbGF5ZXIgQiByZWFkeWluZyB1cCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdVc2VyIG5vdCBmb3VuZCBpbiByb29tJylcbiAgICAgICAgY29uc29sZS5lcnJvcignUm9vbSBwbGF5ZXIgQSBJRDonLCByb29tLnBsYXllcl9hX2lkKVxuICAgICAgICBjb25zb2xlLmVycm9yKCdSb29tIHBsYXllciBCIElEOicsIHJvb20ucGxheWVyX2JfaWQpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0N1cnJlbnQgdXNlciBJRDonLCB1c2VySWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGFyZSBub3QgaW4gdGhpcyByb29tJylcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgYm90aCBwbGF5ZXJzIHdpbGwgYmUgcmVhZHkgYWZ0ZXIgdGhpcyB1cGRhdGVcbiAgICAgIGNvbnN0IGJvdGhSZWFkeSA9IChyb29tLnBsYXllcl9hX2lkID09PSB1c2VySWQgPyB0cnVlIDogcm9vbS5wbGF5ZXJfYV9yZWFkeSkgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgIChyb29tLnBsYXllcl9iX2lkID09PSB1c2VySWQgPyB0cnVlIDogcm9vbS5wbGF5ZXJfYl9yZWFkeSlcblxuICAgICAgY29uc29sZS5sb2coJ0JvdGggcGxheWVycyByZWFkeSBhZnRlciB1cGRhdGU6JywgYm90aFJlYWR5KVxuXG4gICAgICAvLyBJZiBib3RoIHBsYXllcnMgYXJlIHJlYWR5IGFuZCBwcmVzZW50LCBzdGFydCB0aGUgZ2FtZVxuICAgICAgaWYgKGJvdGhSZWFkeSAmJiByb29tLnBsYXllcl9hX2lkICYmIHJvb20ucGxheWVyX2JfaWQpIHtcbiAgICAgICAgdXBkYXRlRGF0YS5zdGF0dXMgPSAnZGViYXRpbmcnXG4gICAgICAgIGNvbnNvbGUubG9nKCdTZXR0aW5nIHN0YXR1cyB0byBkZWJhdGluZycpXG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgcm9vbVxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvcjogdXBkYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdyb29tcycpXG4gICAgICAgIC51cGRhdGUodXBkYXRlRGF0YSlcbiAgICAgICAgLmVxKCdpZCcsIHJvb21JZClcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBpZiAodXBkYXRlRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVhZHlpbmcgdXA6JywgdXBkYXRlRXJyb3IpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHJlYWR5IHVwOiAke3VwZGF0ZUVycm9yLm1lc3NhZ2V9YClcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ1N1Y2Nlc3NmdWxseSByZWFkaWVkIHVwJylcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1JlYWR5IHVwIGVycm9yOicsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH0sXG5cbiAgLy8gVW5yZWFkeVxuICBhc3luYyB1bnJlYWR5KHJvb21JZDogc3RyaW5nKTogUHJvbWlzZTxSb29tIHwgbnVsbD4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgdXNlcklkID0gYXdhaXQgdGhpcy5nZXRVc2VySWQoKVxuICAgICAgaWYgKCF1c2VySWQpIHtcbiAgICAgICAgdXNlcklkID0gdGhpcy5nZXRTZXNzaW9uSWQoKVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGE6IHJvb20sIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncm9vbXMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCdpZCcsIHJvb21JZClcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIGlmIChmZXRjaEVycm9yIHx8ICFyb29tKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUm9vbSBub3QgZm91bmQnKVxuICAgICAgfVxuXG4gICAgICBsZXQgdXBkYXRlRGF0YTogYW55ID0ge31cbiAgICAgIFxuICAgICAgaWYgKHJvb20ucGxheWVyX2FfaWQgPT09IHVzZXJJZCkge1xuICAgICAgICB1cGRhdGVEYXRhLnBsYXllcl9hX3JlYWR5ID0gZmFsc2VcbiAgICAgIH0gZWxzZSBpZiAocm9vbS5wbGF5ZXJfYl9pZCA9PT0gdXNlcklkKSB7XG4gICAgICAgIHVwZGF0ZURhdGEucGxheWVyX2JfcmVhZHkgPSBmYWxzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgYXJlIG5vdCBpbiB0aGlzIHJvb20nKVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBnYW1lIHdhcyBhYm91dCB0byBzdGFydCwga2VlcCBpdCBpbiB3YWl0aW5nIHN0YXR1c1xuICAgICAgaWYgKHJvb20uc3RhdHVzID09PSAnZGViYXRpbmcnKSB7XG4gICAgICAgIHVwZGF0ZURhdGEuc3RhdHVzID0gJ3dhaXRpbmcnXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncm9vbXMnKVxuICAgICAgICAudXBkYXRlKHVwZGF0ZURhdGEpXG4gICAgICAgIC5lcSgnaWQnLCByb29tSWQpXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgaWYgKHVwZGF0ZUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVucmVhZHlpbmc6JywgdXBkYXRlRXJyb3IpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHVucmVhZHk6ICR7dXBkYXRlRXJyb3IubWVzc2FnZX1gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdVbnJlYWR5IGVycm9yOicsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH0sXG5cbiAgLy8gTGVhdmUgcm9vbVxuICBhc3luYyBsZWF2ZVJvb20ocm9vbUlkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IHVzZXJJZCA9IGF3YWl0IHRoaXMuZ2V0VXNlcklkKClcbiAgICAgIGlmICghdXNlcklkKSB7XG4gICAgICAgIHVzZXJJZCA9IHRoaXMuZ2V0U2Vzc2lvbklkKClcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhOiByb29tLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Jvb21zJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5lcSgnaWQnLCByb29tSWQpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBpZiAoZmV0Y2hFcnJvciB8fCAhcm9vbSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jvb20gbm90IGZvdW5kJylcbiAgICAgIH1cblxuICAgICAgbGV0IHVwZGF0ZURhdGE6IGFueSA9IHt9XG4gICAgICBcbiAgICAgIGlmIChyb29tLnBsYXllcl9hX2lkID09PSB1c2VySWQpIHtcbiAgICAgICAgdXBkYXRlRGF0YS5wbGF5ZXJfYV9pZCA9IG51bGxcbiAgICAgICAgdXBkYXRlRGF0YS5wbGF5ZXJfYV9yZWFkeSA9IGZhbHNlXG4gICAgICB9IGVsc2UgaWYgKHJvb20ucGxheWVyX2JfaWQgPT09IHVzZXJJZCkge1xuICAgICAgICB1cGRhdGVEYXRhLnBsYXllcl9iX2lkID0gbnVsbFxuICAgICAgICB1cGRhdGVEYXRhLnBsYXllcl9iX3JlYWR5ID0gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGFyZSBub3QgaW4gdGhpcyByb29tJylcbiAgICAgIH1cblxuICAgICAgLy8gUmVzZXQgcm9vbSBzdGF0dXMgdG8gd2FpdGluZ1xuICAgICAgdXBkYXRlRGF0YS5zdGF0dXMgPSAnd2FpdGluZydcblxuICAgICAgY29uc3QgeyBlcnJvcjogdXBkYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdyb29tcycpXG4gICAgICAgIC51cGRhdGUodXBkYXRlRGF0YSlcbiAgICAgICAgLmVxKCdpZCcsIHJvb21JZClcblxuICAgICAgaWYgKHVwZGF0ZUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxlYXZpbmcgcm9vbTonLCB1cGRhdGVFcnJvcilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbGVhdmUgcm9vbTogJHt1cGRhdGVFcnJvci5tZXNzYWdlfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0xlYXZlIHJvb20gZXJyb3I6JywgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfSxcblxuICAvLyBHZXQgcm9vbSBkZXRhaWxzXG4gIGFzeW5jIGdldFJvb20ocm9vbUlkOiBzdHJpbmcpOiBQcm9taXNlPFJvb20gfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdyb29tcycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAuZXEoJ2lkJywgcm9vbUlkKVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHJvb206JywgZXJyb3IpXG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSAnUEdSU1QxMTYnKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGwgLy8gUm9vbSBub3QgZm91bmRcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdHZXQgcm9vbSBlcnJvcjonLCBlcnJvcilcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9LFxuXG4gIC8vIEVuaGFuY2VkIHN1YnNjcmlwdGlvbiB3aXRoIGJldHRlciBlcnJvciBoYW5kbGluZ1xuICBzdWJzY3JpYmVUb1Jvb20ocm9vbUlkOiBzdHJpbmcsIGNhbGxiYWNrOiAocm9vbTogUm9vbSkgPT4gdm9pZCkge1xuICAgIGNvbnNvbGUubG9nKCdTZXR0aW5nIHVwIHN1YnNjcmlwdGlvbiBmb3Igcm9vbTonLCByb29tSWQpXG4gICAgXG4gICAgY29uc3QgY2hhbm5lbCA9IHN1cGFiYXNlXG4gICAgICAuY2hhbm5lbChgcm9vbToke3Jvb21JZH06JHtEYXRlLm5vdygpfWApXG4gICAgICAub24oXG4gICAgICAgICdwb3N0Z3Jlc19jaGFuZ2VzJyxcbiAgICAgICAge1xuICAgICAgICAgIGV2ZW50OiAnKicsXG4gICAgICAgICAgc2NoZW1hOiAncHVibGljJyxcbiAgICAgICAgICB0YWJsZTogJ3Jvb21zJyxcbiAgICAgICAgICBmaWx0ZXI6IGBpZD1lcS4ke3Jvb21JZH1gLFxuICAgICAgICB9LFxuICAgICAgICAocGF5bG9hZDogYW55KSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ/CflIQgUmVhbC10aW1lIHVwZGF0ZSByZWNlaXZlZDonLCB7XG4gICAgICAgICAgICBldmVudDogcGF5bG9hZC5ldmVudFR5cGUsXG4gICAgICAgICAgICBuZXc6IHBheWxvYWQubmV3ID8ge1xuICAgICAgICAgICAgICBpZDogcGF5bG9hZC5uZXcuaWQsXG4gICAgICAgICAgICAgIHBsYXllcl9hX2lkOiBwYXlsb2FkLm5ldy5wbGF5ZXJfYV9pZCA/IHBheWxvYWQubmV3LnBsYXllcl9hX2lkLnNsaWNlKC04KSA6IG51bGwsXG4gICAgICAgICAgICAgIHBsYXllcl9iX2lkOiBwYXlsb2FkLm5ldy5wbGF5ZXJfYl9pZCA/IHBheWxvYWQubmV3LnBsYXllcl9iX2lkLnNsaWNlKC04KSA6IG51bGwsXG4gICAgICAgICAgICAgIHN0YXR1czogcGF5bG9hZC5uZXcuc3RhdHVzXG4gICAgICAgICAgICB9IDogbnVsbFxuICAgICAgICAgIH0pXG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHBheWxvYWQubmV3KSB7XG4gICAgICAgICAgICBjYWxsYmFjayhwYXlsb2FkLm5ldyBhcyBSb29tKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgoc3RhdHVzOiBzdHJpbmcsIGVycm9yPzogRXJyb3IpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ1N1YnNjcmlwdGlvbiBzdGF0dXM6Jywgc3RhdHVzKVxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdTdWJzY3JpcHRpb24gZXJyb3I6JywgZXJyb3IpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChzdGF0dXMgPT09ICdTVUJTQ1JJQkVEJykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgU3VjY2Vzc2Z1bGx5IHN1YnNjcmliZWQgdG8gcm9vbSB1cGRhdGVzJylcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgIHJldHVybiBjaGFubmVsXG4gIH1cbn0iXSwibmFtZXMiOlsic3VwYWJhc2UiLCJERUJBVEVfVE9QSUNTIiwiZ2VuZXJhdGVVVUlEIiwiY3J5cHRvIiwicmFuZG9tVVVJRCIsInJlcGxhY2UiLCJjIiwiciIsIk1hdGgiLCJyYW5kb20iLCJ2IiwidG9TdHJpbmciLCJjdXJyZW50U2Vzc2lvbklkIiwicm9vbVNlcnZpY2UiLCJnZXRVc2VySWQiLCJkYXRhIiwiZXJyb3IiLCJhdXRoIiwiZ2V0VXNlciIsInVzZXIiLCJpZCIsImdldFNlc3Npb25JZCIsImNvbnNvbGUiLCJsb2ciLCJjcmVhdGVSb29tIiwidXNlcklkIiwicmFuZG9tVG9waWMiLCJmbG9vciIsImxlbmd0aCIsInJvb21EYXRhIiwidG9waWMiLCJzdGF0dXMiLCJwbGF5ZXJfYV9oZWFsdGgiLCJwbGF5ZXJfYl9oZWFsdGgiLCJwbGF5ZXJfYV9yZWFkeSIsInBsYXllcl9iX3JlYWR5IiwicGxheWVyX2FfaWQiLCJmcm9tIiwiaW5zZXJ0Iiwic2VsZWN0Iiwic2luZ2xlIiwiRXJyb3IiLCJtZXNzYWdlIiwicm9vbSIsInBsYXllclJvbGUiLCJqb2luUm9vbSIsInJvb21JZCIsImFjdHVhbFVzZXJJZCIsInV1aWRSZWdleCIsInRlc3QiLCJjdXJyZW50Um9vbSIsImZldGNoRXJyb3IiLCJlcSIsImNvZGUiLCJwbGF5ZXJfYl9pZCIsInVwZGF0ZURhdGEiLCJ1cGRhdGVkUm9vbSIsInVwZGF0ZUVycm9yIiwidXBkYXRlIiwicmVhZHlVcCIsImJvdGhSZWFkeSIsInVucmVhZHkiLCJsZWF2ZVJvb20iLCJnZXRSb29tIiwic3Vic2NyaWJlVG9Sb29tIiwiY2FsbGJhY2siLCJjaGFubmVsIiwiRGF0ZSIsIm5vdyIsIm9uIiwiZXZlbnQiLCJzY2hlbWEiLCJ0YWJsZSIsImZpbHRlciIsInBheWxvYWQiLCJldmVudFR5cGUiLCJuZXciLCJzbGljZSIsInN1YnNjcmliZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/roomService.ts\n"));

/***/ })

});