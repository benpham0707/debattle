"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/room/[id]/page",{

/***/ "(app-pages-browser)/./src/lib/roomService.ts":
/*!********************************!*\
  !*** ./src/lib/roomService.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   roomService: function() { return /* binding */ roomService; }\n/* harmony export */ });\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n\n// List of debate topics for the MVP\nconst DEBATE_TOPICS = [\n    \"Should AI be regulated?\",\n    \"Is social media harmful to democracy?\",\n    \"Should college education be free?\",\n    \"Is remote work better than office work?\",\n    \"Should voting be mandatory?\"\n];\n// Helper function to generate a UUID v4\nfunction generateUUID() {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n        const r = Math.random() * 16 | 0;\n        const v = c == \"x\" ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n    });\n}\nconst roomService = {\n    // Helper to get current Supabase user ID or generate guest ID\n    async getUserId () {\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (error || !(data === null || data === void 0 ? void 0 : data.user)) {\n            // Generate a consistent guest ID for this session\n            let guestId = sessionStorage.getItem(\"guestId\");\n            if (!guestId) {\n                guestId = generateUUID();\n                sessionStorage.setItem(\"guestId\", guestId);\n                console.log(\"Generated new guest ID:\", guestId);\n            }\n            return guestId;\n        }\n        return data.user.id;\n    },\n    // Create a new room\n    async createRoom () {\n        const userId = await this.getUserId();\n        const randomTopic = DEBATE_TOPICS[Math.floor(Math.random() * DEBATE_TOPICS.length)];\n        console.log(\"Creating room with user ID:\", userId);\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").insert([\n            {\n                topic: randomTopic,\n                status: \"waiting\",\n                player_a_health: 100,\n                player_b_health: 100,\n                player_a_id: userId\n            }\n        ]).select().single();\n        if (error) {\n            console.error(\"Error creating room:\", error);\n            return null;\n        }\n        console.log(\"Room created successfully:\", data);\n        return data;\n    },\n    // Join an existing room\n    async joinRoom (roomId) {\n        try {\n            console.log(\"\\uD83D\\uDD04 Attempting to join room:\", roomId);\n            // First, get the room to check its status\n            const { data: room, error: fetchError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").select(\"*\").eq(\"id\", roomId).single();\n            if (fetchError || !room) {\n                console.error(\"❌ Error fetching room:\", fetchError);\n                throw new Error(\"Room not found\");\n            }\n            console.log(\"\\uD83D\\uDCCB Current room state:\", {\n                id: room.id,\n                player_a_id: room.player_a_id,\n                player_b_id: room.player_b_id,\n                status: room.status\n            });\n            // Check if room is full\n            if (room.player_a_id && room.player_b_id) {\n                console.log(\"\\uD83D\\uDEAB Room is full\");\n                throw new Error(\"Room is full\");\n            }\n            // Get user ID for the person joining\n            const joiningUserId = await this.getUserId();\n            console.log(\"\\uD83D\\uDC64 Joining user ID:\", joiningUserId);\n            // Check if this user is already in the room\n            if (room.player_a_id === joiningUserId) {\n                console.log(\"✅ User is already Player A in this room\");\n                return room;\n            }\n            if (room.player_b_id === joiningUserId) {\n                console.log(\"✅ User is already Player B in this room\");\n                return room;\n            }\n            // Determine which player slot to fill\n            let updateData;\n            if (!room.player_a_id) {\n                // If somehow Player A slot is empty, fill it\n                updateData = {\n                    player_a_id: joiningUserId\n                };\n                console.log(\"\\uD83D\\uDC51 Assigning as Player A\");\n            } else {\n                // Normal case: assign as Player B\n                updateData = {\n                    player_b_id: joiningUserId,\n                    status: \"ready_to_start\" // Change status to indicate both players present\n                };\n                console.log(\"\\uD83C\\uDFAF Assigning as Player B\");\n            }\n            console.log(\"\\uD83D\\uDCBE Update data:\", updateData);\n            // Update the room with optimistic locking\n            const { data: updatedRoom, error: updateError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").update(updateData).eq(\"id\", roomId).select().single();\n            if (updateError) {\n                console.error(\"❌ Error joining room:\", updateError);\n                throw new Error(\"Failed to join room\");\n            }\n            console.log(\"✅ Successfully joined room:\", {\n                id: updatedRoom.id,\n                player_a_id: updatedRoom.player_a_id,\n                player_b_id: updatedRoom.player_b_id,\n                status: updatedRoom.status\n            });\n            return updatedRoom;\n        } catch (error) {\n            console.error(\"\\uD83D\\uDCA5 Join room error:\", error);\n            throw error;\n        }\n    },\n    // Get room details\n    async getRoom (roomId) {\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").select(\"*\").eq(\"id\", roomId).single();\n        if (error) {\n            console.error(\"Error fetching room:\", error);\n            return null;\n        }\n        return data;\n    },\n    // Get current user's role in room\n    async getUserRole (roomId) {\n        const userId = await this.getUserId();\n        const room = await this.getRoom(roomId);\n        if (!room) return \"spectator\";\n        if (room.player_a_id === userId) return \"player_a\";\n        if (room.player_b_id === userId) return \"player_b\";\n        return \"spectator\";\n    },\n    // Ready up player\n    async readyUp (roomId) {\n        try {\n            const userId = await this.getUserId();\n            const room = await this.getRoom(roomId);\n            if (!room) throw new Error(\"Room not found\");\n            let updateData = {};\n            if (room.player_a_id === userId) {\n                updateData.player_a_ready = true;\n            } else if (room.player_b_id === userId) {\n                updateData.player_b_ready = true;\n            } else {\n                throw new Error(\"User not in this room\");\n            }\n            // If both players will be ready after this update, start the debate\n            const bothReady = (room.player_a_id === userId || room.player_a_ready) && (room.player_b_id === userId || room.player_b_ready) && room.player_a_id && room.player_b_id;\n            if (bothReady) {\n                updateData.status = \"debating\";\n                updateData.current_phase = \"opening\";\n            }\n            const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").update(updateData).eq(\"id\", roomId).select().single();\n            if (error) throw error;\n            return data;\n        } catch (error) {\n            console.error(\"Error readying up:\", error);\n            throw error;\n        }\n    },\n    // Subscribe to room changes with enhanced debugging\n    subscribeToRoom (roomId, callback) {\n        console.log(\"\\uD83D\\uDD14 Setting up subscription for room:\", roomId);\n        // Create a unique channel name to avoid conflicts\n        const channelName = \"room-updates-\".concat(roomId, \"-\").concat(Date.now());\n        const channel = _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.channel(channelName).on(\"postgres_changes\", {\n            event: \"*\",\n            schema: \"public\",\n            table: \"rooms\",\n            filter: \"id=eq.\".concat(roomId)\n        }, (payload)=>{\n            console.log(\"\\uD83D\\uDD04 Real-time update received:\", {\n                event: payload.eventType,\n                old: payload.old,\n                new: payload.new,\n                timestamp: new Date().toISOString()\n            });\n            if (payload.new) {\n                callback(payload.new);\n            }\n        }).subscribe((status, err)=>{\n            console.log(\"\\uD83D\\uDCE1 Subscription status:\", status);\n            if (err) {\n                console.error(\"❌ Subscription error:\", err);\n            }\n            if (status === \"SUBSCRIBED\") {\n                console.log(\"✅ Successfully subscribed to room updates\");\n            }\n        });\n        // Return unsubscribe function\n        return {\n            unsubscribe: ()=>{\n                console.log(\"\\uD83D\\uDD07 Unsubscribing from room updates\");\n                _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.removeChannel(channel);\n            }\n        };\n    },\n    // Force refresh room data (fallback for real-time issues)\n    async refreshRoom (roomId) {\n        console.log(\"\\uD83D\\uDD04 Force refreshing room data...\");\n        return await this.getRoom(roomId);\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvcm9vbVNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUM7QUFHckMsb0NBQW9DO0FBQ3BDLE1BQU1DLGdCQUFnQjtJQUNwQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFRCx3Q0FBd0M7QUFDeEMsU0FBU0M7SUFDUCxPQUFPLHVDQUF1Q0MsT0FBTyxDQUFDLFNBQVMsU0FBU0MsQ0FBQztRQUN2RSxNQUFNQyxJQUFJQyxLQUFLQyxNQUFNLEtBQUssS0FBSztRQUMvQixNQUFNQyxJQUFJSixLQUFLLE1BQU1DLElBQUtBLElBQUksTUFBTTtRQUNwQyxPQUFPRyxFQUFFQyxRQUFRLENBQUM7SUFDcEI7QUFDRjtBQUVPLE1BQU1DLGNBQWM7SUFDekIsOERBQThEO0lBQzlELE1BQU1DO1FBQ0osTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1iLCtDQUFRQSxDQUFDYyxJQUFJLENBQUNDLE9BQU87UUFDbkQsSUFBSUYsU0FBUyxFQUFDRCxpQkFBQUEsMkJBQUFBLEtBQU1JLElBQUksR0FBRTtZQUN4QixrREFBa0Q7WUFDbEQsSUFBSUMsVUFBVUMsZUFBZUMsT0FBTyxDQUFDO1lBQ3JDLElBQUksQ0FBQ0YsU0FBUztnQkFDWkEsVUFBVWY7Z0JBQ1ZnQixlQUFlRSxPQUFPLENBQUMsV0FBV0g7Z0JBQ2xDSSxRQUFRQyxHQUFHLENBQUMsMkJBQTJCTDtZQUN6QztZQUNBLE9BQU9BO1FBQ1Q7UUFDQSxPQUFPTCxLQUFLSSxJQUFJLENBQUNPLEVBQUU7SUFDckI7SUFFQSxvQkFBb0I7SUFDcEIsTUFBTUM7UUFDSixNQUFNQyxTQUFTLE1BQU0sSUFBSSxDQUFDZCxTQUFTO1FBQ25DLE1BQU1lLGNBQWN6QixhQUFhLENBQUNLLEtBQUtxQixLQUFLLENBQUNyQixLQUFLQyxNQUFNLEtBQUtOLGNBQWMyQixNQUFNLEVBQUU7UUFFbkZQLFFBQVFDLEdBQUcsQ0FBQywrQkFBK0JHO1FBRTND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QUlMLFFBQVFHLEdBQUcsRUFBRTtnQkFDZmIsU0FBU1UsUUFBUUcsR0FBRztZQUN0QjtRQUNGLEdBRURHLFNBQVMsQ0FBQyxDQUFDMUMsUUFBUTJDO1lBQ2xCdEQsUUFBUUMsR0FBRyxDQUFDLHFDQUEyQlU7WUFDdkMsSUFBSTJDLEtBQUs7Z0JBQ1B0RCxRQUFRUixLQUFLLENBQUMseUJBQXlCOEQ7WUFDekM7WUFDQSxJQUFJM0MsV0FBVyxjQUFjO2dCQUMzQlgsUUFBUUMsR0FBRyxDQUFDO1lBQ2Q7UUFDRjtRQUVGLDhCQUE4QjtRQUM5QixPQUFPO1lBQ0xzRCxhQUFhO2dCQUNYdkQsUUFBUUMsR0FBRyxDQUFDO2dCQUNadEIsK0NBQVFBLENBQUM2RSxhQUFhLENBQUNmO1lBQ3pCO1FBQ0Y7SUFDRjtJQUVBLDBEQUEwRDtJQUMxRCxNQUFNZ0IsYUFBWXZDLE1BQWM7UUFDOUJsQixRQUFRQyxHQUFHLENBQUM7UUFDWixPQUFPLE1BQU0sSUFBSSxDQUFDNEIsT0FBTyxDQUFDWDtJQUM1QjtBQUNGLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9yb29tU2VydmljZS50cz9iZTEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN1cGFiYXNlIH0gZnJvbSAnLi9zdXBhYmFzZSdcbmltcG9ydCB7IFJvb20gfSBmcm9tICcuL3N1cGFiYXNlJ1xuXG4vLyBMaXN0IG9mIGRlYmF0ZSB0b3BpY3MgZm9yIHRoZSBNVlBcbmNvbnN0IERFQkFURV9UT1BJQ1MgPSBbXG4gIFwiU2hvdWxkIEFJIGJlIHJlZ3VsYXRlZD9cIixcbiAgXCJJcyBzb2NpYWwgbWVkaWEgaGFybWZ1bCB0byBkZW1vY3JhY3k/XCIsXG4gIFwiU2hvdWxkIGNvbGxlZ2UgZWR1Y2F0aW9uIGJlIGZyZWU/XCIsXG4gIFwiSXMgcmVtb3RlIHdvcmsgYmV0dGVyIHRoYW4gb2ZmaWNlIHdvcms/XCIsXG4gIFwiU2hvdWxkIHZvdGluZyBiZSBtYW5kYXRvcnk/XCIsXG5dXG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSBhIFVVSUQgdjRcbmZ1bmN0aW9uIGdlbmVyYXRlVVVJRCgpOiBzdHJpbmcge1xuICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XG4gICAgY29uc3QgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDBcbiAgICBjb25zdCB2ID0gYyA9PSAneCcgPyByIDogKHIgJiAweDMgfCAweDgpXG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpXG4gIH0pXG59XG5cbmV4cG9ydCBjb25zdCByb29tU2VydmljZSA9IHtcbiAgLy8gSGVscGVyIHRvIGdldCBjdXJyZW50IFN1cGFiYXNlIHVzZXIgSUQgb3IgZ2VuZXJhdGUgZ3Vlc3QgSURcbiAgYXN5bmMgZ2V0VXNlcklkKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKClcbiAgICBpZiAoZXJyb3IgfHwgIWRhdGE/LnVzZXIpIHtcbiAgICAgIC8vIEdlbmVyYXRlIGEgY29uc2lzdGVudCBndWVzdCBJRCBmb3IgdGhpcyBzZXNzaW9uXG4gICAgICBsZXQgZ3Vlc3RJZCA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ2d1ZXN0SWQnKVxuICAgICAgaWYgKCFndWVzdElkKSB7XG4gICAgICAgIGd1ZXN0SWQgPSBnZW5lcmF0ZVVVSUQoKVxuICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdndWVzdElkJywgZ3Vlc3RJZClcbiAgICAgICAgY29uc29sZS5sb2coJ0dlbmVyYXRlZCBuZXcgZ3Vlc3QgSUQ6JywgZ3Vlc3RJZClcbiAgICAgIH1cbiAgICAgIHJldHVybiBndWVzdElkXG4gICAgfVxuICAgIHJldHVybiBkYXRhLnVzZXIuaWRcbiAgfSxcblxuICAvLyBDcmVhdGUgYSBuZXcgcm9vbVxuICBhc3luYyBjcmVhdGVSb29tKCk6IFByb21pc2U8Um9vbSB8IG51bGw+IHtcbiAgICBjb25zdCB1c2VySWQgPSBhd2FpdCB0aGlzLmdldFVzZXJJZCgpXG4gICAgY29uc3QgcmFuZG9tVG9waWMgPSBERUJBVEVfVE9QSUNTW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIERFQkFURV9UT1BJQ1MubGVuZ3RoKV1cblxuICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyByb29tIHdpdGggdXNlciBJRDonLCB1c2VySWQpXG5cbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3Jvb21zJylcbiAgICAgIC5pbnNlcnQoW1xuICAgICAgICB7XG4gICAgICAgICAgdG9waWM6IHJhbmRvbVRvcGljLFxuICAgICAgICAgIHN0YXR1czogJ3dhaXRpbmcnLFxuICAgICAgICAgIHBsYXllcl9hX2hlYWx0aDogMTAwLFxuICAgICAgICAgIHBsYXllcl9iX2hlYWx0aDogMTAwLFxuICAgICAgICAgIHBsYXllcl9hX2lkOiB1c2VySWQsIC8vIENyZWF0b3IgaXMgYWx3YXlzIFBsYXllciBBXG4gICAgICAgIH1cbiAgICAgIF0pXG4gICAgICAuc2VsZWN0KClcbiAgICAgIC5zaW5nbGUoKVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyByb29tOicsIGVycm9yKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnUm9vbSBjcmVhdGVkIHN1Y2Nlc3NmdWxseTonLCBkYXRhKVxuICAgIHJldHVybiBkYXRhXG4gIH0sXG5cbiAgLy8gSm9pbiBhbiBleGlzdGluZyByb29tXG4gIGFzeW5jIGpvaW5Sb29tKHJvb21JZDogc3RyaW5nKTogUHJvbWlzZTxSb29tIHwgbnVsbD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+UhCBBdHRlbXB0aW5nIHRvIGpvaW4gcm9vbTonLCByb29tSWQpXG4gICAgICBcbiAgICAgIC8vIEZpcnN0LCBnZXQgdGhlIHJvb20gdG8gY2hlY2sgaXRzIHN0YXR1c1xuICAgICAgY29uc3QgeyBkYXRhOiByb29tLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Jvb21zJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5lcSgnaWQnLCByb29tSWQpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBpZiAoZmV0Y2hFcnJvciB8fCAhcm9vbSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZmV0Y2hpbmcgcm9vbTonLCBmZXRjaEVycm9yKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jvb20gbm90IGZvdW5kJylcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ/Cfk4sgQ3VycmVudCByb29tIHN0YXRlOicsIHtcbiAgICAgICAgaWQ6IHJvb20uaWQsXG4gICAgICAgIHBsYXllcl9hX2lkOiByb29tLnBsYXllcl9hX2lkLFxuICAgICAgICBwbGF5ZXJfYl9pZDogcm9vbS5wbGF5ZXJfYl9pZCxcbiAgICAgICAgc3RhdHVzOiByb29tLnN0YXR1c1xuICAgICAgfSlcblxuICAgICAgLy8gQ2hlY2sgaWYgcm9vbSBpcyBmdWxsXG4gICAgICBpZiAocm9vbS5wbGF5ZXJfYV9pZCAmJiByb29tLnBsYXllcl9iX2lkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5qrIFJvb20gaXMgZnVsbCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUm9vbSBpcyBmdWxsJylcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHVzZXIgSUQgZm9yIHRoZSBwZXJzb24gam9pbmluZ1xuICAgICAgY29uc3Qgam9pbmluZ1VzZXJJZCA9IGF3YWl0IHRoaXMuZ2V0VXNlcklkKClcbiAgICAgIGNvbnNvbGUubG9nKCfwn5GkIEpvaW5pbmcgdXNlciBJRDonLCBqb2luaW5nVXNlcklkKVxuXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIHVzZXIgaXMgYWxyZWFkeSBpbiB0aGUgcm9vbVxuICAgICAgaWYgKHJvb20ucGxheWVyX2FfaWQgPT09IGpvaW5pbmdVc2VySWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBVc2VyIGlzIGFscmVhZHkgUGxheWVyIEEgaW4gdGhpcyByb29tJylcbiAgICAgICAgcmV0dXJuIHJvb21cbiAgICAgIH1cbiAgICAgIGlmIChyb29tLnBsYXllcl9iX2lkID09PSBqb2luaW5nVXNlcklkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgVXNlciBpcyBhbHJlYWR5IFBsYXllciBCIGluIHRoaXMgcm9vbScpXG4gICAgICAgIHJldHVybiByb29tXG4gICAgICB9XG5cbiAgICAgIC8vIERldGVybWluZSB3aGljaCBwbGF5ZXIgc2xvdCB0byBmaWxsXG4gICAgICBsZXQgdXBkYXRlRGF0YTogYW55XG4gICAgICBcbiAgICAgIGlmICghcm9vbS5wbGF5ZXJfYV9pZCkge1xuICAgICAgICAvLyBJZiBzb21laG93IFBsYXllciBBIHNsb3QgaXMgZW1wdHksIGZpbGwgaXRcbiAgICAgICAgdXBkYXRlRGF0YSA9IHsgXG4gICAgICAgICAgcGxheWVyX2FfaWQ6IGpvaW5pbmdVc2VySWRcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZygn8J+RkSBBc3NpZ25pbmcgYXMgUGxheWVyIEEnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9ybWFsIGNhc2U6IGFzc2lnbiBhcyBQbGF5ZXIgQlxuICAgICAgICB1cGRhdGVEYXRhID0geyBcbiAgICAgICAgICBwbGF5ZXJfYl9pZDogam9pbmluZ1VzZXJJZCxcbiAgICAgICAgICBzdGF0dXM6ICdyZWFkeV90b19zdGFydCcgLy8gQ2hhbmdlIHN0YXR1cyB0byBpbmRpY2F0ZSBib3RoIHBsYXllcnMgcHJlc2VudFxuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn46vIEFzc2lnbmluZyBhcyBQbGF5ZXIgQicpXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn5K+IFVwZGF0ZSBkYXRhOicsIHVwZGF0ZURhdGEpXG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgcm9vbSB3aXRoIG9wdGltaXN0aWMgbG9ja2luZ1xuICAgICAgY29uc3QgeyBkYXRhOiB1cGRhdGVkUm9vbSwgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncm9vbXMnKVxuICAgICAgICAudXBkYXRlKHVwZGF0ZURhdGEpXG4gICAgICAgIC5lcSgnaWQnLCByb29tSWQpXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgaWYgKHVwZGF0ZUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBqb2luaW5nIHJvb206JywgdXBkYXRlRXJyb3IpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGpvaW4gcm9vbScpXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCfinIUgU3VjY2Vzc2Z1bGx5IGpvaW5lZCByb29tOicsIHtcbiAgICAgICAgaWQ6IHVwZGF0ZWRSb29tLmlkLFxuICAgICAgICBwbGF5ZXJfYV9pZDogdXBkYXRlZFJvb20ucGxheWVyX2FfaWQsXG4gICAgICAgIHBsYXllcl9iX2lkOiB1cGRhdGVkUm9vbS5wbGF5ZXJfYl9pZCxcbiAgICAgICAgc3RhdHVzOiB1cGRhdGVkUm9vbS5zdGF0dXNcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIHJldHVybiB1cGRhdGVkUm9vbVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfwn5KlIEpvaW4gcm9vbSBlcnJvcjonLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9LFxuXG4gIC8vIEdldCByb29tIGRldGFpbHNcbiAgYXN5bmMgZ2V0Um9vbShyb29tSWQ6IHN0cmluZyk6IFByb21pc2U8Um9vbSB8IG51bGw+IHtcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3Jvb21zJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdpZCcsIHJvb21JZClcbiAgICAgIC5zaW5nbGUoKVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyByb29tOicsIGVycm9yKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YVxuICB9LFxuXG4gIC8vIEdldCBjdXJyZW50IHVzZXIncyByb2xlIGluIHJvb21cbiAgYXN5bmMgZ2V0VXNlclJvbGUocm9vbUlkOiBzdHJpbmcpOiBQcm9taXNlPCdwbGF5ZXJfYScgfCAncGxheWVyX2InIHwgJ3NwZWN0YXRvcic+IHtcbiAgICBjb25zdCB1c2VySWQgPSBhd2FpdCB0aGlzLmdldFVzZXJJZCgpXG4gICAgY29uc3Qgcm9vbSA9IGF3YWl0IHRoaXMuZ2V0Um9vbShyb29tSWQpXG4gICAgXG4gICAgaWYgKCFyb29tKSByZXR1cm4gJ3NwZWN0YXRvcidcbiAgICBcbiAgICBpZiAocm9vbS5wbGF5ZXJfYV9pZCA9PT0gdXNlcklkKSByZXR1cm4gJ3BsYXllcl9hJ1xuICAgIGlmIChyb29tLnBsYXllcl9iX2lkID09PSB1c2VySWQpIHJldHVybiAncGxheWVyX2InXG4gICAgXG4gICAgcmV0dXJuICdzcGVjdGF0b3InXG4gIH0sXG5cbiAgLy8gUmVhZHkgdXAgcGxheWVyXG4gIGFzeW5jIHJlYWR5VXAocm9vbUlkOiBzdHJpbmcpOiBQcm9taXNlPFJvb20gfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IGF3YWl0IHRoaXMuZ2V0VXNlcklkKClcbiAgICAgIGNvbnN0IHJvb20gPSBhd2FpdCB0aGlzLmdldFJvb20ocm9vbUlkKVxuICAgICAgXG4gICAgICBpZiAoIXJvb20pIHRocm93IG5ldyBFcnJvcignUm9vbSBub3QgZm91bmQnKVxuICAgICAgXG4gICAgICBsZXQgdXBkYXRlRGF0YTogYW55ID0ge31cbiAgICAgIFxuICAgICAgaWYgKHJvb20ucGxheWVyX2FfaWQgPT09IHVzZXJJZCkge1xuICAgICAgICB1cGRhdGVEYXRhLnBsYXllcl9hX3JlYWR5ID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChyb29tLnBsYXllcl9iX2lkID09PSB1c2VySWQpIHtcbiAgICAgICAgdXBkYXRlRGF0YS5wbGF5ZXJfYl9yZWFkeSA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVXNlciBub3QgaW4gdGhpcyByb29tJylcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgYm90aCBwbGF5ZXJzIHdpbGwgYmUgcmVhZHkgYWZ0ZXIgdGhpcyB1cGRhdGUsIHN0YXJ0IHRoZSBkZWJhdGVcbiAgICAgIGNvbnN0IGJvdGhSZWFkeSA9IChcbiAgICAgICAgKHJvb20ucGxheWVyX2FfaWQgPT09IHVzZXJJZCB8fCByb29tLnBsYXllcl9hX3JlYWR5KSAmJlxuICAgICAgICAocm9vbS5wbGF5ZXJfYl9pZCA9PT0gdXNlcklkIHx8IHJvb20ucGxheWVyX2JfcmVhZHkpICYmXG4gICAgICAgIHJvb20ucGxheWVyX2FfaWQgJiYgcm9vbS5wbGF5ZXJfYl9pZFxuICAgICAgKVxuICAgICAgXG4gICAgICBpZiAoYm90aFJlYWR5KSB7XG4gICAgICAgIHVwZGF0ZURhdGEuc3RhdHVzID0gJ2RlYmF0aW5nJ1xuICAgICAgICB1cGRhdGVEYXRhLmN1cnJlbnRfcGhhc2UgPSAnb3BlbmluZydcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Jvb21zJylcbiAgICAgICAgLnVwZGF0ZSh1cGRhdGVEYXRhKVxuICAgICAgICAuZXEoJ2lkJywgcm9vbUlkKVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpXG4gICAgICAgIFxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVhZHlpbmcgdXA6JywgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfSxcblxuICAvLyBTdWJzY3JpYmUgdG8gcm9vbSBjaGFuZ2VzIHdpdGggZW5oYW5jZWQgZGVidWdnaW5nXG4gIHN1YnNjcmliZVRvUm9vbShyb29tSWQ6IHN0cmluZywgY2FsbGJhY2s6IChyb29tOiBSb29tKSA9PiB2b2lkKSB7XG4gICAgY29uc29sZS5sb2coJ/CflJQgU2V0dGluZyB1cCBzdWJzY3JpcHRpb24gZm9yIHJvb206Jywgcm9vbUlkKVxuICAgIFxuICAgIC8vIENyZWF0ZSBhIHVuaXF1ZSBjaGFubmVsIG5hbWUgdG8gYXZvaWQgY29uZmxpY3RzXG4gICAgY29uc3QgY2hhbm5lbE5hbWUgPSBgcm9vbS11cGRhdGVzLSR7cm9vbUlkfS0ke0RhdGUubm93KCl9YFxuICAgIFxuICAgIGNvbnN0IGNoYW5uZWwgPSBzdXBhYmFzZVxuICAgICAgLmNoYW5uZWwoY2hhbm5lbE5hbWUpXG4gICAgICAub24oXG4gICAgICAgICdwb3N0Z3Jlc19jaGFuZ2VzJyxcbiAgICAgICAge1xuICAgICAgICAgIGV2ZW50OiAnKicsIC8vIExpc3RlbiB0byBhbGwgZXZlbnRzIChJTlNFUlQsIFVQREFURSwgREVMRVRFKVxuICAgICAgICAgIHNjaGVtYTogJ3B1YmxpYycsXG4gICAgICAgICAgdGFibGU6ICdyb29tcycsXG4gICAgICAgICAgZmlsdGVyOiBgaWQ9ZXEuJHtyb29tSWR9YCxcbiAgICAgICAgfSxcbiAgICAgICAgKHBheWxvYWQpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+UhCBSZWFsLXRpbWUgdXBkYXRlIHJlY2VpdmVkOicsIHtcbiAgICAgICAgICAgIGV2ZW50OiBwYXlsb2FkLmV2ZW50VHlwZSxcbiAgICAgICAgICAgIG9sZDogcGF5bG9hZC5vbGQsXG4gICAgICAgICAgICBuZXc6IHBheWxvYWQubmV3LFxuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICB9KVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChwYXlsb2FkLm5ldykge1xuICAgICAgICAgICAgY2FsbGJhY2socGF5bG9hZC5uZXcgYXMgUm9vbSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoKHN0YXR1cywgZXJyKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OhIFN1YnNjcmlwdGlvbiBzdGF0dXM6Jywgc3RhdHVzKVxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFN1YnNjcmlwdGlvbiBlcnJvcjonLCBlcnIpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ1NVQlNDUklCRUQnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ+KchSBTdWNjZXNzZnVsbHkgc3Vic2NyaWJlZCB0byByb29tIHVwZGF0ZXMnKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgLy8gUmV0dXJuIHVuc3Vic2NyaWJlIGZ1bmN0aW9uXG4gICAgcmV0dXJuIHtcbiAgICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5SHIFVuc3Vic2NyaWJpbmcgZnJvbSByb29tIHVwZGF0ZXMnKVxuICAgICAgICBzdXBhYmFzZS5yZW1vdmVDaGFubmVsKGNoYW5uZWwpXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8vIEZvcmNlIHJlZnJlc2ggcm9vbSBkYXRhIChmYWxsYmFjayBmb3IgcmVhbC10aW1lIGlzc3VlcylcbiAgYXN5bmMgcmVmcmVzaFJvb20ocm9vbUlkOiBzdHJpbmcpOiBQcm9taXNlPFJvb20gfCBudWxsPiB7XG4gICAgY29uc29sZS5sb2coJ/CflIQgRm9yY2UgcmVmcmVzaGluZyByb29tIGRhdGEuLi4nKVxuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFJvb20ocm9vbUlkKVxuICB9XG59Il0sIm5hbWVzIjpbInN1cGFiYXNlIiwiREVCQVRFX1RPUElDUyIsImdlbmVyYXRlVVVJRCIsInJlcGxhY2UiLCJjIiwiciIsIk1hdGgiLCJyYW5kb20iLCJ2IiwidG9TdHJpbmciLCJyb29tU2VydmljZSIsImdldFVzZXJJZCIsImRhdGEiLCJlcnJvciIsImF1dGgiLCJnZXRVc2VyIiwidXNlciIsImd1ZXN0SWQiLCJzZXNzaW9uU3RvcmFnZSIsImdldEl0ZW0iLCJzZXRJdGVtIiwiY29uc29sZSIsImxvZyIsImlkIiwiY3JlYXRlUm9vbSIsInVzZXJJZCIsInJhbmRvbVRvcGljIiwiZmxvb3IiLCJsZW5ndGgiLCJmcm9tIiwiaW5zZXJ0IiwidG9waWMiLCJzdGF0dXMiLCJwbGF5ZXJfYV9oZWFsdGgiLCJwbGF5ZXJfYl9oZWFsdGgiLCJwbGF5ZXJfYV9pZCIsInNlbGVjdCIsInNpbmdsZSIsImpvaW5Sb29tIiwicm9vbUlkIiwicm9vbSIsImZldGNoRXJyb3IiLCJlcSIsIkVycm9yIiwicGxheWVyX2JfaWQiLCJqb2luaW5nVXNlcklkIiwidXBkYXRlRGF0YSIsInVwZGF0ZWRSb29tIiwidXBkYXRlRXJyb3IiLCJ1cGRhdGUiLCJnZXRSb29tIiwiZ2V0VXNlclJvbGUiLCJyZWFkeVVwIiwicGxheWVyX2FfcmVhZHkiLCJwbGF5ZXJfYl9yZWFkeSIsImJvdGhSZWFkeSIsImN1cnJlbnRfcGhhc2UiLCJzdWJzY3JpYmVUb1Jvb20iLCJjYWxsYmFjayIsImNoYW5uZWxOYW1lIiwiRGF0ZSIsIm5vdyIsImNoYW5uZWwiLCJvbiIsImV2ZW50Iiwic2NoZW1hIiwidGFibGUiLCJmaWx0ZXIiLCJwYXlsb2FkIiwiZXZlbnRUeXBlIiwib2xkIiwibmV3IiwidGltZXN0YW1wIiwidG9JU09TdHJpbmciLCJzdWJzY3JpYmUiLCJlcnIiLCJ1bnN1YnNjcmliZSIsInJlbW92ZUNoYW5uZWwiLCJyZWZyZXNoUm9vbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/roomService.ts\n"));

/***/ })

});