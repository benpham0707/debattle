"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/roomService.ts":
/*!********************************!*\
  !*** ./src/lib/roomService.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   roomService: function() { return /* binding */ roomService; }\n/* harmony export */ });\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n\n// List of debate topics for the MVP\nconst DEBATE_TOPICS = [\n    \"Should AI be regulated?\",\n    \"Is social media harmful to democracy?\",\n    \"Should college education be free?\",\n    \"Is remote work better than office work?\",\n    \"Should voting be mandatory?\"\n];\n// Helper function to generate a UUID v4\nfunction generateUUID() {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n        const r = Math.random() * 16 | 0;\n        const v = c == \"x\" ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n    });\n}\nconst roomService = {\n    // Helper to get current Supabase user ID\n    async getUserId () {\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (error || !(data === null || data === void 0 ? void 0 : data.user)) {\n            return null;\n        }\n        return data.user.id;\n    },\n    // Create a new room\n    async createRoom () {\n        let userId = await this.getUserId();\n        console.log(\"Original user ID:\", userId);\n        // If no authenticated user, generate a session UUID for guests\n        if (!userId) {\n            userId = generateUUID();\n            console.log(\"Generated guest UUID for room creator:\", userId);\n        }\n        // Double check the UUID is valid\n        if (!userId || userId === \"null\" || userId === null) {\n            userId = \"guest-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 9));\n            console.log(\"Fallback UUID generated:\", userId);\n        }\n        const randomTopic = DEBATE_TOPICS[Math.floor(Math.random() * DEBATE_TOPICS.length)];\n        console.log(\"About to create room with user ID:\", userId);\n        console.log(\"User ID type:\", typeof userId);\n        const roomData = {\n            topic: randomTopic,\n            status: \"waiting\",\n            player_a_health: 100,\n            player_b_health: 100,\n            player_a_ready: false,\n            player_b_ready: false,\n            player_a_id: userId\n        };\n        console.log(\"Room data to insert:\", roomData);\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").insert([\n            roomData\n        ]).select().single();\n        if (error) {\n            console.error(\"Error creating room:\", error);\n            throw new Error(\"Failed to create room\");\n        }\n        console.log(\"Successfully created room:\", data);\n        console.log(\"Final player_a_id in database:\", data.player_a_id);\n        return {\n            room: data,\n            playerRole: \"player_a\"\n        };\n    },\n    // Join an existing room\n    async joinRoom (roomId, userId) {\n        try {\n            // First, get the room to check its status\n            const { data: room, error: fetchError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").select(\"*\").eq(\"id\", roomId).single();\n            if (fetchError || !room) {\n                console.error(\"Error fetching room:\", fetchError);\n                throw new Error(\"Room not found\");\n            }\n            // Check if room is full\n            if (room.player_a_id && room.player_b_id) {\n                throw new Error(\"Room is full\");\n            }\n            // Use actual user ID or generate UUID for guests\n            let actualUserId = await this.getUserId();\n            if (!actualUserId) {\n                actualUserId = generateUUID();\n                console.log(\"Generated guest UUID for room joiner:\", actualUserId);\n            }\n            console.log(\"Current room state:\", {\n                player_a_id: room.player_a_id,\n                player_b_id: room.player_b_id\n            });\n            console.log(\"Joining with user ID:\", actualUserId);\n            // Determine which player slot to fill and role\n            let updateData;\n            let playerRole;\n            if (room.player_a_id === null || room.player_a_id === undefined) {\n                // Player A slot is empty\n                updateData = {\n                    player_a_id: actualUserId,\n                    player_a_ready: false\n                };\n                playerRole = \"player_a\";\n                console.log(\"Joining as Player A\");\n            } else if (room.player_b_id === null || room.player_b_id === undefined) {\n                // Player B slot is empty\n                updateData = {\n                    player_b_id: actualUserId,\n                    player_b_ready: false\n                };\n                playerRole = \"player_b\";\n                console.log(\"Joining as Player B\");\n            } else {\n                throw new Error(\"Room is full\");\n            }\n            console.log(\"Update data:\", updateData);\n            // Update the room\n            const { data, error: updateError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").update(updateData).eq(\"id\", roomId).select().single();\n            if (updateError) {\n                console.error(\"Error joining room:\", updateError);\n                throw new Error(\"Failed to join room\");\n            }\n            console.log(\"Successfully joined room as:\", playerRole, data);\n            // Force a small delay to ensure database consistency\n            setTimeout(()=>{\n                console.log(\"Room join completed, real-time updates should trigger\");\n            }, 100);\n            return {\n                room: data,\n                playerRole\n            };\n        } catch (error) {\n            console.error(\"Join room error:\", error);\n            throw error;\n        }\n    },\n    // Ready up for the game\n    async readyUp (roomId) {\n        try {\n            const userId = await this.getUserId();\n            // Get current room state\n            const { data: room, error: fetchError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").select(\"*\").eq(\"id\", roomId).single();\n            if (fetchError || !room) {\n                throw new Error(\"Room not found\");\n            }\n            // Determine which player is ready-ing up\n            let updateData = {};\n            if (room.player_a_id === userId) {\n                updateData.player_a_ready = true;\n            } else if (room.player_b_id === userId) {\n                updateData.player_b_ready = true;\n            } else {\n                throw new Error(\"You are not in this room\");\n            }\n            // Check if both players will be ready after this update\n            const bothReady = (room.player_a_id === userId ? true : room.player_a_ready) && (room.player_b_id === userId ? true : room.player_b_ready);\n            // If both players are ready, start the game\n            if (bothReady && room.player_a_id && room.player_b_id) {\n                updateData.status = \"debating\";\n            }\n            // Update the room\n            const { data, error: updateError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").update(updateData).eq(\"id\", roomId).select().single();\n            if (updateError) {\n                console.error(\"Error readying up:\", updateError);\n                throw new Error(\"Failed to ready up\");\n            }\n            return data;\n        } catch (error) {\n            console.error(\"Ready up error:\", error);\n            throw error;\n        }\n    },\n    // Unready (cancel ready status)\n    async unready (roomId) {\n        try {\n            const userId = await this.getUserId();\n            // Get current room state\n            const { data: room, error: fetchError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").select(\"*\").eq(\"id\", roomId).single();\n            if (fetchError || !room) {\n                throw new Error(\"Room not found\");\n            }\n            // Determine which player is un-readying\n            let updateData = {};\n            if (room.player_a_id === userId) {\n                updateData.player_a_ready = false;\n            } else if (room.player_b_id === userId) {\n                updateData.player_b_ready = false;\n            } else {\n                throw new Error(\"You are not in this room\");\n            }\n            // If game was about to start, keep it in waiting status\n            if (room.status === \"debating\") {\n                updateData.status = \"waiting\";\n            }\n            // Update the room\n            const { data, error: updateError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").update(updateData).eq(\"id\", roomId).select().single();\n            if (updateError) {\n                console.error(\"Error unreadying:\", updateError);\n                throw new Error(\"Failed to unready\");\n            }\n            return data;\n        } catch (error) {\n            console.error(\"Unready error:\", error);\n            throw error;\n        }\n    },\n    // Leave room\n    async leaveRoom (roomId) {\n        try {\n            const userId = await this.getUserId();\n            // Get current room state\n            const { data: room, error: fetchError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").select(\"*\").eq(\"id\", roomId).single();\n            if (fetchError || !room) {\n                throw new Error(\"Room not found\");\n            }\n            // Determine which player is leaving\n            let updateData = {};\n            if (room.player_a_id === userId) {\n                updateData.player_a_id = null;\n                updateData.player_a_ready = false;\n            } else if (room.player_b_id === userId) {\n                updateData.player_b_id = null;\n                updateData.player_b_ready = false;\n            } else {\n                throw new Error(\"You are not in this room\");\n            }\n            // Reset room status to waiting\n            updateData.status = \"waiting\";\n            // Update the room\n            const { error: updateError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").update(updateData).eq(\"id\", roomId);\n            if (updateError) {\n                console.error(\"Error leaving room:\", updateError);\n                throw new Error(\"Failed to leave room\");\n            }\n            return true;\n        } catch (error) {\n            console.error(\"Leave room error:\", error);\n            throw error;\n        }\n    },\n    // Get room details\n    async getRoom (roomId) {\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"rooms\").select(\"*\").eq(\"id\", roomId).single();\n        if (error) {\n            console.error(\"Error fetching room:\", error);\n            return null;\n        }\n        return data;\n    },\n    // Subscribe to room changes\n    subscribeToRoom (roomId, callback) {\n        console.log(\"Setting up subscription for room:\", roomId);\n        const channel = _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.channel(\"room:\".concat(roomId)).on(\"postgres_changes\", {\n            event: \"*\",\n            schema: \"public\",\n            table: \"rooms\",\n            filter: \"id=eq.\".concat(roomId)\n        }, (payload)=>{\n            console.log(\"Database change detected:\", payload);\n            if (payload.new) {\n                console.log(\"Calling callback with updated room:\", payload.new);\n                callback(payload.new);\n            }\n        }).subscribe((status)=>{\n            console.log(\"Subscription status:\", status);\n        });\n        return channel;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvcm9vbVNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUM7QUFHckMsb0NBQW9DO0FBQ3BDLE1BQU1DLGdCQUFnQjtJQUNwQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFRCx3Q0FBd0M7QUFDeEMsU0FBU0M7SUFDUCxPQUFPLHVDQUF1Q0MsT0FBTyxDQUFDLFNBQVMsU0FBU0MsQ0FBQztRQUN2RSxNQUFNQyxJQUFJQyxLQUFLQyxNQUFNLEtBQUssS0FBSztRQUMvQixNQUFNQyxJQUFJSixLQUFLLE1BQU1DLElBQUtBLElBQUksTUFBTTtRQUNwQyxPQUFPRyxFQUFFQyxRQUFRLENBQUM7SUFDcEI7QUFDRjtBQUVPLE1BQU1DLGNBQWM7SUFDekIseUNBQXlDO0lBQ3pDLE1BQU1DO1FBQ0osTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1iLCtDQUFRQSxDQUFDYyxJQUFJLENBQUNDLE9BQU87UUFDbkQsSUFBSUYsU0FBUyxFQUFDRCxpQkFBQUEsMkJBQUFBLEtBQU1JLElBQUksR0FBRTtZQUN4QixPQUFPO1FBQ1Q7UUFDQSxPQUFPSixLQUFLSSxJQUFJLENBQUNDLEVBQUU7SUFDckI7SUFFQSxvQkFBb0I7SUFDcEIsTUFBTUM7UUFDSixJQUFJQyxTQUFTLE1BQU0sSUFBSSxDQUFDUixTQUFTO1FBRWpDUyxRQUFRQyxHQUFHLENBQUMscUJBQXFCRjtRQUVqQywrREFBK0Q7UUFDL0QsSUFBSSxDQUFDQSxRQUFRO1lBQ1hBLFNBQVNqQjtZQUNUa0IsUUFBUUMsR0FBRyxDQUFDLDBDQUEwQ0Y7UUFDeEQ7UUFFQSxpQ0FBaUM7UUFDakMsSUFBSSxDQUFDQSxVQUFVQSxXQUFXLFVBQVVBLFdBQVcsTUFBTTtZQUNuREEsU0FBUyxTQUF1QmIsT0FBZGdCLEtBQUtDLEdBQUcsSUFBRyxLQUEyQyxPQUF4Q2pCLEtBQUtDLE1BQU0sR0FBR0UsUUFBUSxDQUFDLElBQUllLE1BQU0sQ0FB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QUNuQixHQUNBLENBQUN1QjtZQUNDL0MsUUFBUUMsR0FBRyxDQUFDLDZCQUE2QjhDO1lBQ3pDLElBQUlBLFFBQVFDLEdBQUcsRUFBRTtnQkFDZmhELFFBQVFDLEdBQUcsQ0FBQyx1Q0FBdUM4QyxRQUFRQyxHQUFHO2dCQUM5RFIsU0FBU08sUUFBUUMsR0FBRztZQUN0QjtRQUNGLEdBRURDLFNBQVMsQ0FBQyxDQUFDdkM7WUFDVlYsUUFBUUMsR0FBRyxDQUFDLHdCQUF3QlM7UUFDdEM7UUFFRixPQUFPK0I7SUFDVDtBQUNGLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9yb29tU2VydmljZS50cz9iZTEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN1cGFiYXNlIH0gZnJvbSAnLi9zdXBhYmFzZSdcbmltcG9ydCB7IFJvb20gfSBmcm9tICcuL3N1cGFiYXNlJ1xuXG4vLyBMaXN0IG9mIGRlYmF0ZSB0b3BpY3MgZm9yIHRoZSBNVlBcbmNvbnN0IERFQkFURV9UT1BJQ1MgPSBbXG4gIFwiU2hvdWxkIEFJIGJlIHJlZ3VsYXRlZD9cIixcbiAgXCJJcyBzb2NpYWwgbWVkaWEgaGFybWZ1bCB0byBkZW1vY3JhY3k/XCIsXG4gIFwiU2hvdWxkIGNvbGxlZ2UgZWR1Y2F0aW9uIGJlIGZyZWU/XCIsXG4gIFwiSXMgcmVtb3RlIHdvcmsgYmV0dGVyIHRoYW4gb2ZmaWNlIHdvcms/XCIsXG4gIFwiU2hvdWxkIHZvdGluZyBiZSBtYW5kYXRvcnk/XCIsXG5dXG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSBhIFVVSUQgdjRcbmZ1bmN0aW9uIGdlbmVyYXRlVVVJRCgpOiBzdHJpbmcge1xuICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XG4gICAgY29uc3QgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDBcbiAgICBjb25zdCB2ID0gYyA9PSAneCcgPyByIDogKHIgJiAweDMgfCAweDgpXG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpXG4gIH0pXG59XG5cbmV4cG9ydCBjb25zdCByb29tU2VydmljZSA9IHtcbiAgLy8gSGVscGVyIHRvIGdldCBjdXJyZW50IFN1cGFiYXNlIHVzZXIgSURcbiAgYXN5bmMgZ2V0VXNlcklkKCk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpXG4gICAgaWYgKGVycm9yIHx8ICFkYXRhPy51c2VyKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICByZXR1cm4gZGF0YS51c2VyLmlkXG4gIH0sXG5cbiAgLy8gQ3JlYXRlIGEgbmV3IHJvb21cbiAgYXN5bmMgY3JlYXRlUm9vbSgpOiBQcm9taXNlPHsgcm9vbTogUm9vbTsgcGxheWVyUm9sZTogJ3BsYXllcl9hJyB8ICdwbGF5ZXJfYicgfT4ge1xuICAgIGxldCB1c2VySWQgPSBhd2FpdCB0aGlzLmdldFVzZXJJZCgpXG4gICAgXG4gICAgY29uc29sZS5sb2coJ09yaWdpbmFsIHVzZXIgSUQ6JywgdXNlcklkKVxuICAgIFxuICAgIC8vIElmIG5vIGF1dGhlbnRpY2F0ZWQgdXNlciwgZ2VuZXJhdGUgYSBzZXNzaW9uIFVVSUQgZm9yIGd1ZXN0c1xuICAgIGlmICghdXNlcklkKSB7XG4gICAgICB1c2VySWQgPSBnZW5lcmF0ZVVVSUQoKVxuICAgICAgY29uc29sZS5sb2coJ0dlbmVyYXRlZCBndWVzdCBVVUlEIGZvciByb29tIGNyZWF0b3I6JywgdXNlcklkKVxuICAgIH1cbiAgICBcbiAgICAvLyBEb3VibGUgY2hlY2sgdGhlIFVVSUQgaXMgdmFsaWRcbiAgICBpZiAoIXVzZXJJZCB8fCB1c2VySWQgPT09ICdudWxsJyB8fCB1c2VySWQgPT09IG51bGwpIHtcbiAgICAgIHVzZXJJZCA9IGBndWVzdC0ke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWBcbiAgICAgIGNvbnNvbGUubG9nKCdGYWxsYmFjayBVVUlEIGdlbmVyYXRlZDonLCB1c2VySWQpXG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHJhbmRvbVRvcGljID0gREVCQVRFX1RPUElDU1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBERUJBVEVfVE9QSUNTLmxlbmd0aCldXG5cbiAgICBjb25zb2xlLmxvZygnQWJvdXQgdG8gY3JlYXRlIHJvb20gd2l0aCB1c2VyIElEOicsIHVzZXJJZClcbiAgICBjb25zb2xlLmxvZygnVXNlciBJRCB0eXBlOicsIHR5cGVvZiB1c2VySWQpXG5cbiAgICBjb25zdCByb29tRGF0YSA9IHtcbiAgICAgIHRvcGljOiByYW5kb21Ub3BpYyxcbiAgICAgIHN0YXR1czogJ3dhaXRpbmcnLFxuICAgICAgcGxheWVyX2FfaGVhbHRoOiAxMDAsXG4gICAgICBwbGF5ZXJfYl9oZWFsdGg6IDEwMCxcbiAgICAgIHBsYXllcl9hX3JlYWR5OiBmYWxzZSxcbiAgICAgIHBsYXllcl9iX3JlYWR5OiBmYWxzZSxcbiAgICAgIHBsYXllcl9hX2lkOiB1c2VySWQsIC8vIENyZWF0b3IgaXMgYWx3YXlzIFBsYXllciBBIHdpdGggYWN0dWFsIFVVSURcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coJ1Jvb20gZGF0YSB0byBpbnNlcnQ6Jywgcm9vbURhdGEpXG5cbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3Jvb21zJylcbiAgICAgIC5pbnNlcnQoW3Jvb21EYXRhXSlcbiAgICAgIC5zZWxlY3QoKVxuICAgICAgLnNpbmdsZSgpXG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHJvb206JywgZXJyb3IpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgcm9vbScpXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1N1Y2Nlc3NmdWxseSBjcmVhdGVkIHJvb206JywgZGF0YSlcbiAgICBjb25zb2xlLmxvZygnRmluYWwgcGxheWVyX2FfaWQgaW4gZGF0YWJhc2U6JywgZGF0YS5wbGF5ZXJfYV9pZClcblxuICAgIHJldHVybiB7IHJvb206IGRhdGEsIHBsYXllclJvbGU6ICdwbGF5ZXJfYScgfVxuICB9LFxuXG4gIC8vIEpvaW4gYW4gZXhpc3Rpbmcgcm9vbVxuICBhc3luYyBqb2luUm9vbShyb29tSWQ6IHN0cmluZywgdXNlcklkPzogc3RyaW5nKTogUHJvbWlzZTx7IHJvb206IFJvb207IHBsYXllclJvbGU6ICdwbGF5ZXJfYScgfCAncGxheWVyX2InIH0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gRmlyc3QsIGdldCB0aGUgcm9vbSB0byBjaGVjayBpdHMgc3RhdHVzXG4gICAgICBjb25zdCB7IGRhdGE6IHJvb20sIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncm9vbXMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCdpZCcsIHJvb21JZClcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIGlmIChmZXRjaEVycm9yIHx8ICFyb29tKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHJvb206JywgZmV0Y2hFcnJvcilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSb29tIG5vdCBmb3VuZCcpXG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHJvb20gaXMgZnVsbFxuICAgICAgaWYgKHJvb20ucGxheWVyX2FfaWQgJiYgcm9vbS5wbGF5ZXJfYl9pZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jvb20gaXMgZnVsbCcpXG4gICAgICB9XG5cbiAgICAgIC8vIFVzZSBhY3R1YWwgdXNlciBJRCBvciBnZW5lcmF0ZSBVVUlEIGZvciBndWVzdHNcbiAgICAgIGxldCBhY3R1YWxVc2VySWQgPSBhd2FpdCB0aGlzLmdldFVzZXJJZCgpXG4gICAgICBpZiAoIWFjdHVhbFVzZXJJZCkge1xuICAgICAgICBhY3R1YWxVc2VySWQgPSBnZW5lcmF0ZVVVSUQoKVxuICAgICAgICBjb25zb2xlLmxvZygnR2VuZXJhdGVkIGd1ZXN0IFVVSUQgZm9yIHJvb20gam9pbmVyOicsIGFjdHVhbFVzZXJJZClcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ0N1cnJlbnQgcm9vbSBzdGF0ZTonLCB7IHBsYXllcl9hX2lkOiByb29tLnBsYXllcl9hX2lkLCBwbGF5ZXJfYl9pZDogcm9vbS5wbGF5ZXJfYl9pZCB9KVxuICAgICAgY29uc29sZS5sb2coJ0pvaW5pbmcgd2l0aCB1c2VyIElEOicsIGFjdHVhbFVzZXJJZClcblxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIHBsYXllciBzbG90IHRvIGZpbGwgYW5kIHJvbGVcbiAgICAgIGxldCB1cGRhdGVEYXRhOiBhbnlcbiAgICAgIGxldCBwbGF5ZXJSb2xlOiAncGxheWVyX2EnIHwgJ3BsYXllcl9iJ1xuXG4gICAgICBpZiAocm9vbS5wbGF5ZXJfYV9pZCA9PT0gbnVsbCB8fCByb29tLnBsYXllcl9hX2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gUGxheWVyIEEgc2xvdCBpcyBlbXB0eVxuICAgICAgICB1cGRhdGVEYXRhID0geyBcbiAgICAgICAgICBwbGF5ZXJfYV9pZDogYWN0dWFsVXNlcklkLFxuICAgICAgICAgIHBsYXllcl9hX3JlYWR5OiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIHBsYXllclJvbGUgPSAncGxheWVyX2EnXG4gICAgICAgIGNvbnNvbGUubG9nKCdKb2luaW5nIGFzIFBsYXllciBBJylcbiAgICAgIH0gZWxzZSBpZiAocm9vbS5wbGF5ZXJfYl9pZCA9PT0gbnVsbCB8fCByb29tLnBsYXllcl9iX2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gUGxheWVyIEIgc2xvdCBpcyBlbXB0eVxuICAgICAgICB1cGRhdGVEYXRhID0geyBcbiAgICAgICAgICBwbGF5ZXJfYl9pZDogYWN0dWFsVXNlcklkLFxuICAgICAgICAgIHBsYXllcl9iX3JlYWR5OiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIHBsYXllclJvbGUgPSAncGxheWVyX2InXG4gICAgICAgIGNvbnNvbGUubG9nKCdKb2luaW5nIGFzIFBsYXllciBCJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUm9vbSBpcyBmdWxsJylcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ1VwZGF0ZSBkYXRhOicsIHVwZGF0ZURhdGEpXG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgcm9vbVxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvcjogdXBkYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdyb29tcycpXG4gICAgICAgIC51cGRhdGUodXBkYXRlRGF0YSlcbiAgICAgICAgLmVxKCdpZCcsIHJvb21JZClcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBpZiAodXBkYXRlRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igam9pbmluZyByb29tOicsIHVwZGF0ZUVycm9yKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBqb2luIHJvb20nKVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IGpvaW5lZCByb29tIGFzOicsIHBsYXllclJvbGUsIGRhdGEpXG4gICAgICBcbiAgICAgIC8vIEZvcmNlIGEgc21hbGwgZGVsYXkgdG8gZW5zdXJlIGRhdGFiYXNlIGNvbnNpc3RlbmN5XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ1Jvb20gam9pbiBjb21wbGV0ZWQsIHJlYWwtdGltZSB1cGRhdGVzIHNob3VsZCB0cmlnZ2VyJylcbiAgICAgIH0sIDEwMClcbiAgICAgIFxuICAgICAgcmV0dXJuIHsgcm9vbTogZGF0YSwgcGxheWVyUm9sZSB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0pvaW4gcm9vbSBlcnJvcjonLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9LFxuXG4gIC8vIFJlYWR5IHVwIGZvciB0aGUgZ2FtZVxuICBhc3luYyByZWFkeVVwKHJvb21JZDogc3RyaW5nKTogUHJvbWlzZTxSb29tIHwgbnVsbD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1c2VySWQgPSBhd2FpdCB0aGlzLmdldFVzZXJJZCgpXG4gICAgICBcbiAgICAgIC8vIEdldCBjdXJyZW50IHJvb20gc3RhdGVcbiAgICAgIGNvbnN0IHsgZGF0YTogcm9vbSwgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdyb29tcycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAuZXEoJ2lkJywgcm9vbUlkKVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgaWYgKGZldGNoRXJyb3IgfHwgIXJvb20pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSb29tIG5vdCBmb3VuZCcpXG4gICAgICB9XG5cbiAgICAgIC8vIERldGVybWluZSB3aGljaCBwbGF5ZXIgaXMgcmVhZHktaW5nIHVwXG4gICAgICBsZXQgdXBkYXRlRGF0YTogYW55ID0ge31cbiAgICAgIFxuICAgICAgaWYgKHJvb20ucGxheWVyX2FfaWQgPT09IHVzZXJJZCkge1xuICAgICAgICB1cGRhdGVEYXRhLnBsYXllcl9hX3JlYWR5ID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChyb29tLnBsYXllcl9iX2lkID09PSB1c2VySWQpIHtcbiAgICAgICAgdXBkYXRlRGF0YS5wbGF5ZXJfYl9yZWFkeSA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGFyZSBub3QgaW4gdGhpcyByb29tJylcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgYm90aCBwbGF5ZXJzIHdpbGwgYmUgcmVhZHkgYWZ0ZXIgdGhpcyB1cGRhdGVcbiAgICAgIGNvbnN0IGJvdGhSZWFkeSA9IChyb29tLnBsYXllcl9hX2lkID09PSB1c2VySWQgPyB0cnVlIDogcm9vbS5wbGF5ZXJfYV9yZWFkeSkgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgIChyb29tLnBsYXllcl9iX2lkID09PSB1c2VySWQgPyB0cnVlIDogcm9vbS5wbGF5ZXJfYl9yZWFkeSlcblxuICAgICAgLy8gSWYgYm90aCBwbGF5ZXJzIGFyZSByZWFkeSwgc3RhcnQgdGhlIGdhbWVcbiAgICAgIGlmIChib3RoUmVhZHkgJiYgcm9vbS5wbGF5ZXJfYV9pZCAmJiByb29tLnBsYXllcl9iX2lkKSB7XG4gICAgICAgIHVwZGF0ZURhdGEuc3RhdHVzID0gJ2RlYmF0aW5nJ1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgdGhlIHJvb21cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncm9vbXMnKVxuICAgICAgICAudXBkYXRlKHVwZGF0ZURhdGEpXG4gICAgICAgIC5lcSgnaWQnLCByb29tSWQpXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgaWYgKHVwZGF0ZUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlYWR5aW5nIHVwOicsIHVwZGF0ZUVycm9yKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZWFkeSB1cCcpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1JlYWR5IHVwIGVycm9yOicsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH0sXG5cbiAgLy8gVW5yZWFkeSAoY2FuY2VsIHJlYWR5IHN0YXR1cylcbiAgYXN5bmMgdW5yZWFkeShyb29tSWQ6IHN0cmluZyk6IFByb21pc2U8Um9vbSB8IG51bGw+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXNlcklkID0gYXdhaXQgdGhpcy5nZXRVc2VySWQoKVxuICAgICAgXG4gICAgICAvLyBHZXQgY3VycmVudCByb29tIHN0YXRlXG4gICAgICBjb25zdCB7IGRhdGE6IHJvb20sIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncm9vbXMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCdpZCcsIHJvb21JZClcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIGlmIChmZXRjaEVycm9yIHx8ICFyb29tKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUm9vbSBub3QgZm91bmQnKVxuICAgICAgfVxuXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggcGxheWVyIGlzIHVuLXJlYWR5aW5nXG4gICAgICBsZXQgdXBkYXRlRGF0YTogYW55ID0ge31cbiAgICAgIFxuICAgICAgaWYgKHJvb20ucGxheWVyX2FfaWQgPT09IHVzZXJJZCkge1xuICAgICAgICB1cGRhdGVEYXRhLnBsYXllcl9hX3JlYWR5ID0gZmFsc2VcbiAgICAgIH0gZWxzZSBpZiAocm9vbS5wbGF5ZXJfYl9pZCA9PT0gdXNlcklkKSB7XG4gICAgICAgIHVwZGF0ZURhdGEucGxheWVyX2JfcmVhZHkgPSBmYWxzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgYXJlIG5vdCBpbiB0aGlzIHJvb20nKVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBnYW1lIHdhcyBhYm91dCB0byBzdGFydCwga2VlcCBpdCBpbiB3YWl0aW5nIHN0YXR1c1xuICAgICAgaWYgKHJvb20uc3RhdHVzID09PSAnZGViYXRpbmcnKSB7XG4gICAgICAgIHVwZGF0ZURhdGEuc3RhdHVzID0gJ3dhaXRpbmcnXG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgcm9vbVxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvcjogdXBkYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdyb29tcycpXG4gICAgICAgIC51cGRhdGUodXBkYXRlRGF0YSlcbiAgICAgICAgLmVxKCdpZCcsIHJvb21JZClcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBpZiAodXBkYXRlRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdW5yZWFkeWluZzonLCB1cGRhdGVFcnJvcilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gdW5yZWFkeScpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1VucmVhZHkgZXJyb3I6JywgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfSxcblxuICAvLyBMZWF2ZSByb29tXG4gIGFzeW5jIGxlYXZlUm9vbShyb29tSWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1c2VySWQgPSBhd2FpdCB0aGlzLmdldFVzZXJJZCgpXG4gICAgICBcbiAgICAgIC8vIEdldCBjdXJyZW50IHJvb20gc3RhdGVcbiAgICAgIGNvbnN0IHsgZGF0YTogcm9vbSwgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdyb29tcycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAuZXEoJ2lkJywgcm9vbUlkKVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgaWYgKGZldGNoRXJyb3IgfHwgIXJvb20pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSb29tIG5vdCBmb3VuZCcpXG4gICAgICB9XG5cbiAgICAgIC8vIERldGVybWluZSB3aGljaCBwbGF5ZXIgaXMgbGVhdmluZ1xuICAgICAgbGV0IHVwZGF0ZURhdGE6IGFueSA9IHt9XG4gICAgICBcbiAgICAgIGlmIChyb29tLnBsYXllcl9hX2lkID09PSB1c2VySWQpIHtcbiAgICAgICAgdXBkYXRlRGF0YS5wbGF5ZXJfYV9pZCA9IG51bGxcbiAgICAgICAgdXBkYXRlRGF0YS5wbGF5ZXJfYV9yZWFkeSA9IGZhbHNlXG4gICAgICB9IGVsc2UgaWYgKHJvb20ucGxheWVyX2JfaWQgPT09IHVzZXJJZCkge1xuICAgICAgICB1cGRhdGVEYXRhLnBsYXllcl9iX2lkID0gbnVsbFxuICAgICAgICB1cGRhdGVEYXRhLnBsYXllcl9iX3JlYWR5ID0gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGFyZSBub3QgaW4gdGhpcyByb29tJylcbiAgICAgIH1cblxuICAgICAgLy8gUmVzZXQgcm9vbSBzdGF0dXMgdG8gd2FpdGluZ1xuICAgICAgdXBkYXRlRGF0YS5zdGF0dXMgPSAnd2FpdGluZydcblxuICAgICAgLy8gVXBkYXRlIHRoZSByb29tXG4gICAgICBjb25zdCB7IGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Jvb21zJylcbiAgICAgICAgLnVwZGF0ZSh1cGRhdGVEYXRhKVxuICAgICAgICAuZXEoJ2lkJywgcm9vbUlkKVxuXG4gICAgICBpZiAodXBkYXRlRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbGVhdmluZyByb29tOicsIHVwZGF0ZUVycm9yKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsZWF2ZSByb29tJylcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignTGVhdmUgcm9vbSBlcnJvcjonLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9LFxuXG4gIC8vIEdldCByb29tIGRldGFpbHNcbiAgYXN5bmMgZ2V0Um9vbShyb29tSWQ6IHN0cmluZyk6IFByb21pc2U8Um9vbSB8IG51bGw+IHtcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3Jvb21zJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdpZCcsIHJvb21JZClcbiAgICAgIC5zaW5nbGUoKVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyByb29tOicsIGVycm9yKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YVxuICB9LFxuXG4gIC8vIFN1YnNjcmliZSB0byByb29tIGNoYW5nZXNcbiAgc3Vic2NyaWJlVG9Sb29tKHJvb21JZDogc3RyaW5nLCBjYWxsYmFjazogKHJvb206IFJvb20pID0+IHZvaWQpIHtcbiAgICBjb25zb2xlLmxvZygnU2V0dGluZyB1cCBzdWJzY3JpcHRpb24gZm9yIHJvb206Jywgcm9vbUlkKVxuICAgIFxuICAgIGNvbnN0IGNoYW5uZWwgPSBzdXBhYmFzZVxuICAgICAgLmNoYW5uZWwoYHJvb206JHtyb29tSWR9YClcbiAgICAgIC5vbihcbiAgICAgICAgJ3Bvc3RncmVzX2NoYW5nZXMnLFxuICAgICAgICB7XG4gICAgICAgICAgZXZlbnQ6ICcqJyxcbiAgICAgICAgICBzY2hlbWE6ICdwdWJsaWMnLFxuICAgICAgICAgIHRhYmxlOiAncm9vbXMnLFxuICAgICAgICAgIGZpbHRlcjogYGlkPWVxLiR7cm9vbUlkfWAsXG4gICAgICAgIH0sXG4gICAgICAgIChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0RhdGFiYXNlIGNoYW5nZSBkZXRlY3RlZDonLCBwYXlsb2FkKVxuICAgICAgICAgIGlmIChwYXlsb2FkLm5ldykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0NhbGxpbmcgY2FsbGJhY2sgd2l0aCB1cGRhdGVkIHJvb206JywgcGF5bG9hZC5uZXcpXG4gICAgICAgICAgICBjYWxsYmFjayhwYXlsb2FkLm5ldyBhcyBSb29tKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgoc3RhdHVzKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdTdWJzY3JpcHRpb24gc3RhdHVzOicsIHN0YXR1cylcbiAgICAgIH0pXG5cbiAgICByZXR1cm4gY2hhbm5lbFxuICB9XG59Il0sIm5hbWVzIjpbInN1cGFiYXNlIiwiREVCQVRFX1RPUElDUyIsImdlbmVyYXRlVVVJRCIsInJlcGxhY2UiLCJjIiwiciIsIk1hdGgiLCJyYW5kb20iLCJ2IiwidG9TdHJpbmciLCJyb29tU2VydmljZSIsImdldFVzZXJJZCIsImRhdGEiLCJlcnJvciIsImF1dGgiLCJnZXRVc2VyIiwidXNlciIsImlkIiwiY3JlYXRlUm9vbSIsInVzZXJJZCIsImNvbnNvbGUiLCJsb2ciLCJEYXRlIiwibm93Iiwic3Vic3RyIiwicmFuZG9tVG9waWMiLCJmbG9vciIsImxlbmd0aCIsInJvb21EYXRhIiwidG9waWMiLCJzdGF0dXMiLCJwbGF5ZXJfYV9oZWFsdGgiLCJwbGF5ZXJfYl9oZWFsdGgiLCJwbGF5ZXJfYV9yZWFkeSIsInBsYXllcl9iX3JlYWR5IiwicGxheWVyX2FfaWQiLCJmcm9tIiwiaW5zZXJ0Iiwic2VsZWN0Iiwic2luZ2xlIiwiRXJyb3IiLCJyb29tIiwicGxheWVyUm9sZSIsImpvaW5Sb29tIiwicm9vbUlkIiwiZmV0Y2hFcnJvciIsImVxIiwicGxheWVyX2JfaWQiLCJhY3R1YWxVc2VySWQiLCJ1cGRhdGVEYXRhIiwidW5kZWZpbmVkIiwidXBkYXRlRXJyb3IiLCJ1cGRhdGUiLCJzZXRUaW1lb3V0IiwicmVhZHlVcCIsImJvdGhSZWFkeSIsInVucmVhZHkiLCJsZWF2ZVJvb20iLCJnZXRSb29tIiwic3Vic2NyaWJlVG9Sb29tIiwiY2FsbGJhY2siLCJjaGFubmVsIiwib24iLCJldmVudCIsInNjaGVtYSIsInRhYmxlIiwiZmlsdGVyIiwicGF5bG9hZCIsIm5ldyIsInN1YnNjcmliZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/roomService.ts\n"));

/***/ })

});