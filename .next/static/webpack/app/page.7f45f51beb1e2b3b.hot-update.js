"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/roleManager.ts":
/*!********************************!*\
  !*** ./src/lib/roleManager.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   roleManager: function() { return /* binding */ roleManager; },\n/* harmony export */   usePlayerRole: function() { return /* binding */ usePlayerRole; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n// src/lib/roleManager.ts - FIXED VERSION\n\n// Helper function to generate a proper UUID v4\nfunction generateUUID() {\n    if (typeof crypto !== \"undefined\" && crypto.randomUUID) {\n        return crypto.randomUUID();\n    }\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n        const r = Math.random() * 16 | 0;\n        const v = c === \"x\" ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n    });\n}\nclass RoleManager {\n    static getInstance() {\n        if (!RoleManager.instance) {\n            RoleManager.instance = new RoleManager();\n        }\n        return RoleManager.instance;\n    }\n    // FIXED: Consistent session ID generation/retrieval\n    getSessionId() {\n        // If we already have a global session ID, use it\n        if (this.globalSessionId) {\n            console.log(\"\\uD83D\\uDD11 Using existing global session ID:\", this.globalSessionId.slice(-8));\n            return this.globalSessionId;\n        }\n        // Check if we have one stored in localStorage\n        const stored = localStorage.getItem(\"debattle_global_session_id\");\n        if (stored) {\n            console.log(\"\\uD83D\\uDD11 Retrieved session ID from localStorage:\", stored.slice(-8));\n            this.globalSessionId = stored;\n            return stored;\n        }\n        // Generate a new one and store it\n        const newId = generateUUID();\n        console.log(\"\\uD83D\\uDD11 Generated new global session ID:\", newId.slice(-8));\n        this.globalSessionId = newId;\n        localStorage.setItem(\"debattle_global_session_id\", newId);\n        return newId;\n    }\n    // Set role directly when we know what it should be\n    setRole(roomId, room, playerRole) {\n        const sessionId = this.getSessionId() // Use consistent session ID\n        ;\n        console.log(\"\\uD83C\\uDFAD ROLE MANAGER - Setting role directly:\", {\n            role: playerRole,\n            sessionId: sessionId.slice(-8),\n            roomId: roomId.slice(-8)\n        });\n        const session = {\n            sessionId,\n            playerRole,\n            roomId,\n            assignedAt: Date.now(),\n            isLocked: room.status === \"debating\"\n        };\n        // Save it\n        const sessionKey = \"debattle_role_\".concat(roomId);\n        localStorage.setItem(sessionKey, JSON.stringify(session));\n        this.currentSession = session;\n        return session;\n    }\n    // Get role for a room\n    getRole(roomId) {\n        // First check memory\n        if (this.currentSession && this.currentSession.roomId === roomId) {\n            return this.currentSession;\n        }\n        // Then check localStorage\n        const sessionKey = \"debattle_role_\".concat(roomId);\n        const stored = localStorage.getItem(sessionKey);\n        if (stored) {\n            try {\n                const session = JSON.parse(stored);\n                this.currentSession = session;\n                return session;\n            } catch (error) {\n                console.error(\"Error parsing stored session:\", error);\n                localStorage.removeItem(sessionKey);\n            }\n        }\n        return null;\n    }\n    // Clear role\n    clearRole(roomId) {\n        const sessionKey = \"debattle_role_\".concat(roomId);\n        localStorage.removeItem(sessionKey);\n        if (this.currentSession && this.currentSession.roomId === roomId) {\n            this.currentSession = null;\n        }\n    }\n    // Lock role\n    lockRole(roomId) {\n        if (this.currentSession && this.currentSession.roomId === roomId) {\n            this.currentSession.isLocked = true;\n            const sessionKey = \"debattle_role_\".concat(roomId);\n            localStorage.setItem(sessionKey, JSON.stringify(this.currentSession));\n        }\n    }\n    getCurrentSession() {\n        return this.currentSession;\n    }\n    debugSession(roomId) {\n        var _this_globalSessionId;\n        console.log(\"\\uD83D\\uDD0D ROLE MANAGER DEBUG:\", {\n            globalSessionId: (_this_globalSessionId = this.globalSessionId) === null || _this_globalSessionId === void 0 ? void 0 : _this_globalSessionId.slice(-8),\n            currentSession: this.currentSession,\n            roomId: roomId.slice(-8),\n            storedSessions: Object.keys(localStorage).filter((k)=>k.includes(\"debattle\"))\n        });\n    }\n    // Clear all stored data (for testing)\n    clearAll() {\n        this.globalSessionId = null;\n        this.currentSession = null;\n        localStorage.removeItem(\"debattle_global_session_id\");\n        Object.keys(localStorage).forEach((key)=>{\n            if (key.startsWith(\"debattle_\")) {\n                localStorage.removeItem(key);\n            }\n        });\n        console.log(\"\\uD83E\\uDDF9 Cleared all role manager data\");\n    }\n    constructor(){\n        this.currentSession = null;\n        this.globalSessionId = null // Store globally\n        ;\n    }\n}\nconst roleManager = RoleManager.getInstance();\n// Simple hook - FIXED to use consistent session matching\nfunction usePlayerRole(roomId, room) {\n    const [session, setSession] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(null);\n    const [isLoading, setIsLoading] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(true);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(()=>{\n        if (!room) return;\n        // Check if we already have a role for this room\n        let playerSession = roleManager.getRole(roomId);\n        if (!playerSession) {\n            var _room_player_a_id, _room_player_b_id;\n            // Determine role based on room data using the SAME session ID\n            let role = \"spectator\";\n            const sessionId = roleManager.getSessionId() // This will be consistent now\n            ;\n            console.log(\"\\uD83C\\uDFAD Role determination:\", {\n                sessionId: sessionId.slice(-8),\n                roomPlayerA: (_room_player_a_id = room.player_a_id) === null || _room_player_a_id === void 0 ? void 0 : _room_player_a_id.slice(-8),\n                roomPlayerB: (_room_player_b_id = room.player_b_id) === null || _room_player_b_id === void 0 ? void 0 : _room_player_b_id.slice(-8)\n            });\n            if (room.player_a_id === sessionId) {\n                role = \"player_a\";\n                console.log(\"✅ Matched as Player A\");\n            } else if (room.player_b_id === sessionId) {\n                role = \"player_b\";\n                console.log(\"✅ Matched as Player B\");\n            } else {\n                console.log(\"\\uD83D\\uDC40 No match - spectator role\");\n            }\n            playerSession = roleManager.setRole(roomId, room, role);\n        }\n        setSession(playerSession);\n        setIsLoading(false);\n    }, [\n        roomId,\n        room === null || room === void 0 ? void 0 : room.id,\n        room === null || room === void 0 ? void 0 : room.status\n    ]);\n    return {\n        session,\n        isLoading\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvcm9sZU1hbmFnZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLHlDQUF5QztBQUVoQjtBQVV6QiwrQ0FBK0M7QUFDL0MsU0FBU0M7SUFDUCxJQUFJLE9BQU9DLFdBQVcsZUFBZUEsT0FBT0MsVUFBVSxFQUFFO1FBQ3RELE9BQU9ELE9BQU9DLFVBQVU7SUFDMUI7SUFFQSxPQUFPLHVDQUF1Q0MsT0FBTyxDQUFDLFNBQVMsU0FBU0MsQ0FBQztRQUN2RSxNQUFNQyxJQUFJLEtBQU1FLE1BQU0sS0FBSyxLQUFNO1FBQ2pDLE1BQU1DLElBQUlKLE1BQU0sTUFBTUMsSUFBSSxJQUFLLE1BQU87UUFDdEMsT0FBT0csRUFBRUMsUUFBUSxDQUFDO0lBQ3BCO0FBQ0Y7QUFFQSxNQUFNQztJQUtKLE9BQU9DLGNBQTJCO1FBQ2hDLElBQUksQ0FBQ0QsWUFBWUUsUUFBUSxFQUFFO1lBQ3pCRixZQUFZRSxRQUFRLEdBQUcsSUFBSUY7UUFDN0I7UUFDQSxPQUFPQSxZQUFZRSxRQUFRO0lBQzdCO0lBRUEsb0RBQW9EO0lBQ3BEQyxlQUF1QjtRQUNyQixpREFBaUQ7UUFDakQsSUFBSSxJQUFJLENBQUNDLGVBQWUsRUFBRTtZQUN4QkMsUUFBUUMsR0FBRyxDQUFDLGtEQUF3QyxJQUFJLENBQUNGLGVBQWUsQ0FBQ0csS0FBSyxDQUFDLENBQUM7WUFDaEYsT0FBTyxJQUFJLENBQUNILGVBQWU7UUFDN0I7UUFFQSw4Q0FBOEM7UUFDOUMsTUFBTUksU0FBU0MsYUFBYUMsT0FBTyxDQUFDO1FBQ3BDLElBQUlGLFFBQVE7WUFDVkgsUUFBUUMsR0FBRyxDQUFDLHdEQUE4Q0UsT0FBT0QsS0FBSyxDQUFDLENBQUM7WUFDeEUsSUFBSSxDQUFDSCxlQUFlLEdBQUdJO1lBQ3ZCLE9BQU9BO1FBQ1Q7UUFFQSxrQ0FBa0M7UUFDbEMsTUFBTUcsUUFBUXJCO1FBQ2RlLFFBQVFDLEdBQUcsQ0FBQyxpREFBdUNLLE1BQU1KLEtBQUssQ0FBQyxDQUFD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QVFDLEdBQUcsQ0FBQztZQUNkLE9BQU8sSUFBSVMsS0FBSzJDLFdBQVcsS0FBS3pDLFdBQVc7Z0JBQ3pDQyxPQUFPO2dCQUNQYixRQUFRQyxHQUFHLENBQUM7WUFDZCxPQUFPO2dCQUNMRCxRQUFRQyxHQUFHLENBQUM7WUFDZDtZQUVBZ0QsZ0JBQWdCUCxZQUFZbEMsT0FBTyxDQUFDQyxRQUFRQyxNQUFNRztRQUNwRDtRQUVBK0IsV0FBV0s7UUFDWEYsYUFBYTtJQUNmLEdBQUc7UUFBQ3RDO1FBQVFDLGlCQUFBQSwyQkFBQUEsS0FBTTRDLEVBQUU7UUFBRTVDLGlCQUFBQSwyQkFBQUEsS0FBTVMsTUFBTTtLQUFDO0lBRW5DLE9BQU87UUFBRUw7UUFBU2dDO0lBQVU7QUFDOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9yb2xlTWFuYWdlci50cz9lM2JkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9saWIvcm9sZU1hbmFnZXIudHMgLSBGSVhFRCBWRVJTSU9OXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuZXhwb3J0IGludGVyZmFjZSBQbGF5ZXJTZXNzaW9uIHtcbiAgc2Vzc2lvbklkOiBzdHJpbmdcbiAgcGxheWVyUm9sZTogJ3BsYXllcl9hJyB8ICdwbGF5ZXJfYicgfCAnc3BlY3RhdG9yJ1xuICByb29tSWQ6IHN0cmluZ1xuICBhc3NpZ25lZEF0OiBudW1iZXJcbiAgaXNMb2NrZWQ6IGJvb2xlYW5cbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGEgcHJvcGVyIFVVSUQgdjRcbmZ1bmN0aW9uIGdlbmVyYXRlVVVJRCgpOiBzdHJpbmcge1xuICBpZiAodHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLnJhbmRvbVVVSUQpIHtcbiAgICByZXR1cm4gY3J5cHRvLnJhbmRvbVVVSUQoKVxuICB9XG4gIFxuICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XG4gICAgY29uc3QgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMFxuICAgIGNvbnN0IHYgPSBjID09PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4XG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpXG4gIH0pXG59XG5cbmNsYXNzIFJvbGVNYW5hZ2VyIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFJvbGVNYW5hZ2VyXG4gIHByaXZhdGUgY3VycmVudFNlc3Npb246IFBsYXllclNlc3Npb24gfCBudWxsID0gbnVsbFxuICBwcml2YXRlIGdsb2JhbFNlc3Npb25JZDogc3RyaW5nIHwgbnVsbCA9IG51bGwgLy8gU3RvcmUgZ2xvYmFsbHlcbiAgXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBSb2xlTWFuYWdlciB7XG4gICAgaWYgKCFSb2xlTWFuYWdlci5pbnN0YW5jZSkge1xuICAgICAgUm9sZU1hbmFnZXIuaW5zdGFuY2UgPSBuZXcgUm9sZU1hbmFnZXIoKVxuICAgIH1cbiAgICByZXR1cm4gUm9sZU1hbmFnZXIuaW5zdGFuY2VcbiAgfVxuXG4gIC8vIEZJWEVEOiBDb25zaXN0ZW50IHNlc3Npb24gSUQgZ2VuZXJhdGlvbi9yZXRyaWV2YWxcbiAgZ2V0U2Vzc2lvbklkKCk6IHN0cmluZyB7XG4gICAgLy8gSWYgd2UgYWxyZWFkeSBoYXZlIGEgZ2xvYmFsIHNlc3Npb24gSUQsIHVzZSBpdFxuICAgIGlmICh0aGlzLmdsb2JhbFNlc3Npb25JZCkge1xuICAgICAgY29uc29sZS5sb2coJ/CflJEgVXNpbmcgZXhpc3RpbmcgZ2xvYmFsIHNlc3Npb24gSUQ6JywgdGhpcy5nbG9iYWxTZXNzaW9uSWQuc2xpY2UoLTgpKVxuICAgICAgcmV0dXJuIHRoaXMuZ2xvYmFsU2Vzc2lvbklkXG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgb25lIHN0b3JlZCBpbiBsb2NhbFN0b3JhZ2VcbiAgICBjb25zdCBzdG9yZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZGViYXR0bGVfZ2xvYmFsX3Nlc3Npb25faWQnKVxuICAgIGlmIChzdG9yZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SRIFJldHJpZXZlZCBzZXNzaW9uIElEIGZyb20gbG9jYWxTdG9yYWdlOicsIHN0b3JlZC5zbGljZSgtOCkpXG4gICAgICB0aGlzLmdsb2JhbFNlc3Npb25JZCA9IHN0b3JlZFxuICAgICAgcmV0dXJuIHN0b3JlZFxuICAgIH1cbiAgICBcbiAgICAvLyBHZW5lcmF0ZSBhIG5ldyBvbmUgYW5kIHN0b3JlIGl0XG4gICAgY29uc3QgbmV3SWQgPSBnZW5lcmF0ZVVVSUQoKVxuICAgIGNvbnNvbGUubG9nKCfwn5SRIEdlbmVyYXRlZCBuZXcgZ2xvYmFsIHNlc3Npb24gSUQ6JywgbmV3SWQuc2xpY2UoLTgpKVxuICAgIHRoaXMuZ2xvYmFsU2Vzc2lvbklkID0gbmV3SWRcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnZGViYXR0bGVfZ2xvYmFsX3Nlc3Npb25faWQnLCBuZXdJZClcbiAgICBcbiAgICByZXR1cm4gbmV3SWRcbiAgfVxuXG4gIC8vIFNldCByb2xlIGRpcmVjdGx5IHdoZW4gd2Uga25vdyB3aGF0IGl0IHNob3VsZCBiZVxuICBzZXRSb2xlKHJvb21JZDogc3RyaW5nLCByb29tOiBhbnksIHBsYXllclJvbGU6ICdwbGF5ZXJfYScgfCAncGxheWVyX2InIHwgJ3NwZWN0YXRvcicpOiBQbGF5ZXJTZXNzaW9uIHtcbiAgICBjb25zdCBzZXNzaW9uSWQgPSB0aGlzLmdldFNlc3Npb25JZCgpIC8vIFVzZSBjb25zaXN0ZW50IHNlc3Npb24gSURcbiAgICBcbiAgICBjb25zb2xlLmxvZygn8J+OrSBST0xFIE1BTkFHRVIgLSBTZXR0aW5nIHJvbGUgZGlyZWN0bHk6Jywge1xuICAgICAgcm9sZTogcGxheWVyUm9sZSxcbiAgICAgIHNlc3Npb25JZDogc2Vzc2lvbklkLnNsaWNlKC04KSxcbiAgICAgIHJvb21JZDogcm9vbUlkLnNsaWNlKC04KVxuICAgIH0pXG5cbiAgICBjb25zdCBzZXNzaW9uOiBQbGF5ZXJTZXNzaW9uID0ge1xuICAgICAgc2Vzc2lvbklkLFxuICAgICAgcGxheWVyUm9sZSxcbiAgICAgIHJvb21JZCxcbiAgICAgIGFzc2lnbmVkQXQ6IERhdGUubm93KCksXG4gICAgICBpc0xvY2tlZDogcm9vbS5zdGF0dXMgPT09ICdkZWJhdGluZydcbiAgICB9XG5cbiAgICAvLyBTYXZlIGl0XG4gICAgY29uc3Qgc2Vzc2lvbktleSA9IGBkZWJhdHRsZV9yb2xlXyR7cm9vbUlkfWBcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShzZXNzaW9uS2V5LCBKU09OLnN0cmluZ2lmeShzZXNzaW9uKSlcbiAgICB0aGlzLmN1cnJlbnRTZXNzaW9uID0gc2Vzc2lvblxuXG4gICAgcmV0dXJuIHNlc3Npb25cbiAgfVxuXG4gIC8vIEdldCByb2xlIGZvciBhIHJvb21cbiAgZ2V0Um9sZShyb29tSWQ6IHN0cmluZyk6IFBsYXllclNlc3Npb24gfCBudWxsIHtcbiAgICAvLyBGaXJzdCBjaGVjayBtZW1vcnlcbiAgICBpZiAodGhpcy5jdXJyZW50U2Vzc2lvbiAmJiB0aGlzLmN1cnJlbnRTZXNzaW9uLnJvb21JZCA9PT0gcm9vbUlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50U2Vzc2lvblxuICAgIH1cblxuICAgIC8vIFRoZW4gY2hlY2sgbG9jYWxTdG9yYWdlXG4gICAgY29uc3Qgc2Vzc2lvbktleSA9IGBkZWJhdHRsZV9yb2xlXyR7cm9vbUlkfWBcbiAgICBjb25zdCBzdG9yZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShzZXNzaW9uS2V5KVxuICAgIGlmIChzdG9yZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNlc3Npb24gPSBKU09OLnBhcnNlKHN0b3JlZClcbiAgICAgICAgdGhpcy5jdXJyZW50U2Vzc2lvbiA9IHNlc3Npb25cbiAgICAgICAgcmV0dXJuIHNlc3Npb25cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBhcnNpbmcgc3RvcmVkIHNlc3Npb246JywgZXJyb3IpXG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHNlc3Npb25LZXkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIENsZWFyIHJvbGVcbiAgY2xlYXJSb2xlKHJvb21JZDogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3Qgc2Vzc2lvbktleSA9IGBkZWJhdHRsZV9yb2xlXyR7cm9vbUlkfWBcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShzZXNzaW9uS2V5KVxuICAgIFxuICAgIGlmICh0aGlzLmN1cnJlbnRTZXNzaW9uICYmIHRoaXMuY3VycmVudFNlc3Npb24ucm9vbUlkID09PSByb29tSWQpIHtcbiAgICAgIHRoaXMuY3VycmVudFNlc3Npb24gPSBudWxsXG4gICAgfVxuICB9XG5cbiAgLy8gTG9jayByb2xlXG4gIGxvY2tSb2xlKHJvb21JZDogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY3VycmVudFNlc3Npb24gJiYgdGhpcy5jdXJyZW50U2Vzc2lvbi5yb29tSWQgPT09IHJvb21JZCkge1xuICAgICAgdGhpcy5jdXJyZW50U2Vzc2lvbi5pc0xvY2tlZCA9IHRydWVcbiAgICAgIGNvbnN0IHNlc3Npb25LZXkgPSBgZGViYXR0bGVfcm9sZV8ke3Jvb21JZH1gXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShzZXNzaW9uS2V5LCBKU09OLnN0cmluZ2lmeSh0aGlzLmN1cnJlbnRTZXNzaW9uKSlcbiAgICB9XG4gIH1cblxuICBnZXRDdXJyZW50U2Vzc2lvbigpOiBQbGF5ZXJTZXNzaW9uIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFNlc3Npb25cbiAgfVxuXG4gIGRlYnVnU2Vzc2lvbihyb29tSWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnNvbGUubG9nKCfwn5SNIFJPTEUgTUFOQUdFUiBERUJVRzonLCB7XG4gICAgICBnbG9iYWxTZXNzaW9uSWQ6IHRoaXMuZ2xvYmFsU2Vzc2lvbklkPy5zbGljZSgtOCksXG4gICAgICBjdXJyZW50U2Vzc2lvbjogdGhpcy5jdXJyZW50U2Vzc2lvbixcbiAgICAgIHJvb21JZDogcm9vbUlkLnNsaWNlKC04KSxcbiAgICAgIHN0b3JlZFNlc3Npb25zOiBPYmplY3Qua2V5cyhsb2NhbFN0b3JhZ2UpLmZpbHRlcihrID0+IGsuaW5jbHVkZXMoJ2RlYmF0dGxlJykpXG4gICAgfSlcbiAgfVxuXG4gIC8vIENsZWFyIGFsbCBzdG9yZWQgZGF0YSAoZm9yIHRlc3RpbmcpXG4gIGNsZWFyQWxsKCk6IHZvaWQge1xuICAgIHRoaXMuZ2xvYmFsU2Vzc2lvbklkID0gbnVsbFxuICAgIHRoaXMuY3VycmVudFNlc3Npb24gPSBudWxsXG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYmF0dGxlX2dsb2JhbF9zZXNzaW9uX2lkJylcbiAgICBPYmplY3Qua2V5cyhsb2NhbFN0b3JhZ2UpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChrZXkuc3RhcnRzV2l0aCgnZGViYXR0bGVfJykpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KVxuICAgICAgfVxuICAgIH0pXG4gICAgY29uc29sZS5sb2coJ/Cfp7kgQ2xlYXJlZCBhbGwgcm9sZSBtYW5hZ2VyIGRhdGEnKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCByb2xlTWFuYWdlciA9IFJvbGVNYW5hZ2VyLmdldEluc3RhbmNlKClcblxuLy8gU2ltcGxlIGhvb2sgLSBGSVhFRCB0byB1c2UgY29uc2lzdGVudCBzZXNzaW9uIG1hdGNoaW5nXG5leHBvcnQgZnVuY3Rpb24gdXNlUGxheWVyUm9sZShyb29tSWQ6IHN0cmluZywgcm9vbTogYW55KSB7XG4gIGNvbnN0IFtzZXNzaW9uLCBzZXRTZXNzaW9uXSA9IFJlYWN0LnVzZVN0YXRlPFBsYXllclNlc3Npb24gfCBudWxsPihudWxsKVxuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gUmVhY3QudXNlU3RhdGUodHJ1ZSlcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghcm9vbSkgcmV0dXJuXG5cbiAgICAvLyBDaGVjayBpZiB3ZSBhbHJlYWR5IGhhdmUgYSByb2xlIGZvciB0aGlzIHJvb21cbiAgICBsZXQgcGxheWVyU2Vzc2lvbiA9IHJvbGVNYW5hZ2VyLmdldFJvbGUocm9vbUlkKVxuICAgIFxuICAgIGlmICghcGxheWVyU2Vzc2lvbikge1xuICAgICAgLy8gRGV0ZXJtaW5lIHJvbGUgYmFzZWQgb24gcm9vbSBkYXRhIHVzaW5nIHRoZSBTQU1FIHNlc3Npb24gSURcbiAgICAgIGxldCByb2xlOiAncGxheWVyX2EnIHwgJ3BsYXllcl9iJyB8ICdzcGVjdGF0b3InID0gJ3NwZWN0YXRvcidcbiAgICAgIGNvbnN0IHNlc3Npb25JZCA9IHJvbGVNYW5hZ2VyLmdldFNlc3Npb25JZCgpIC8vIFRoaXMgd2lsbCBiZSBjb25zaXN0ZW50IG5vd1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn8J+OrSBSb2xlIGRldGVybWluYXRpb246Jywge1xuICAgICAgICBzZXNzaW9uSWQ6IHNlc3Npb25JZC5zbGljZSgtOCksXG4gICAgICAgIHJvb21QbGF5ZXJBOiByb29tLnBsYXllcl9hX2lkPy5zbGljZSgtOCksXG4gICAgICAgIHJvb21QbGF5ZXJCOiByb29tLnBsYXllcl9iX2lkPy5zbGljZSgtOClcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIGlmIChyb29tLnBsYXllcl9hX2lkID09PSBzZXNzaW9uSWQpIHtcbiAgICAgICAgcm9sZSA9ICdwbGF5ZXJfYSdcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBNYXRjaGVkIGFzIFBsYXllciBBJylcbiAgICAgIH0gZWxzZSBpZiAocm9vbS5wbGF5ZXJfYl9pZCA9PT0gc2Vzc2lvbklkKSB7XG4gICAgICAgIHJvbGUgPSAncGxheWVyX2InXG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgTWF0Y2hlZCBhcyBQbGF5ZXIgQicpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygn8J+RgCBObyBtYXRjaCAtIHNwZWN0YXRvciByb2xlJylcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcGxheWVyU2Vzc2lvbiA9IHJvbGVNYW5hZ2VyLnNldFJvbGUocm9vbUlkLCByb29tLCByb2xlKVxuICAgIH1cbiAgICBcbiAgICBzZXRTZXNzaW9uKHBsYXllclNlc3Npb24pXG4gICAgc2V0SXNMb2FkaW5nKGZhbHNlKVxuICB9LCBbcm9vbUlkLCByb29tPy5pZCwgcm9vbT8uc3RhdHVzXSlcblxuICByZXR1cm4geyBzZXNzaW9uLCBpc0xvYWRpbmcgfVxufSJdLCJuYW1lcyI6WyJSZWFjdCIsImdlbmVyYXRlVVVJRCIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJyZXBsYWNlIiwiYyIsInIiLCJNYXRoIiwicmFuZG9tIiwidiIsInRvU3RyaW5nIiwiUm9sZU1hbmFnZXIiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwiZ2V0U2Vzc2lvbklkIiwiZ2xvYmFsU2Vzc2lvbklkIiwiY29uc29sZSIsImxvZyIsInNsaWNlIiwic3RvcmVkIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIm5ld0lkIiwic2V0SXRlbSIsInNldFJvbGUiLCJyb29tSWQiLCJyb29tIiwicGxheWVyUm9sZSIsInNlc3Npb25JZCIsInJvbGUiLCJzZXNzaW9uIiwiYXNzaWduZWRBdCIsIkRhdGUiLCJub3ciLCJpc0xvY2tlZCIsInN0YXR1cyIsInNlc3Npb25LZXkiLCJKU09OIiwic3RyaW5naWZ5IiwiY3VycmVudFNlc3Npb24iLCJnZXRSb2xlIiwicGFyc2UiLCJlcnJvciIsInJlbW92ZUl0ZW0iLCJjbGVhclJvbGUiLCJsb2NrUm9sZSIsImdldEN1cnJlbnRTZXNzaW9uIiwiZGVidWdTZXNzaW9uIiwic3RvcmVkU2Vzc2lvbnMiLCJPYmplY3QiLCJrZXlzIiwiZmlsdGVyIiwiayIsImluY2x1ZGVzIiwiY2xlYXJBbGwiLCJmb3JFYWNoIiwia2V5Iiwic3RhcnRzV2l0aCIsInJvbGVNYW5hZ2VyIiwidXNlUGxheWVyUm9sZSIsInNldFNlc3Npb24iLCJ1c2VTdGF0ZSIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsInVzZUVmZmVjdCIsInBsYXllclNlc3Npb24iLCJyb29tUGxheWVyQSIsInBsYXllcl9hX2lkIiwicm9vbVBsYXllckIiLCJwbGF5ZXJfYl9pZCIsImlkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/roleManager.ts\n"));

/***/ })

});